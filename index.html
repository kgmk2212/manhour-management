<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工数管理システム</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@holiday-jp/holiday_jp/holiday_jp.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 15px;
        }

        h1 {
            font-size: 22px;
            margin-bottom: 8px;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .tabs {
            display: flex;
            gap: 4px;
            background: #ecf0f1;
            padding: 8px;
            overflow-x: auto;
        }

        .tab {
            padding: 10px 16px;
            background: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }

        .tab.active {
            color: white;
        }

        /* テーマが適用されていないアクティブタブのフォールバック */
        .tab.active:not([class*="tab-theme-"]) {
            background: #3498db;
        }

        .content {
            padding: 15px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .form-group {
            margin-bottom: 12px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            font-size: 13px;
        }

        input, select {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .quick-input {
            padding: 15px;
            border-radius: 10px;
            color: white;
            margin-bottom: 15px;
        }

        .quick-form {
            display: grid;
            gap: 8px;
            margin-top: 10px;
        }

        /* 見積テーブル用スタイル */
        .estimate-table {
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .estimate-table th {
            background: #e8f5e9;
            color: #2c3e50;
            font-size: 12px;
            font-weight: 600;
            padding: 8px;
            border-bottom: 2px solid #4caf50;
        }

        .estimate-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
        }

        .estimate-table select,
        .estimate-table input {
            padding: 6px 8px;
            font-size: 13px;
        }

        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            min-width: 600px;
        }

        th {
            background: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
            white-space: nowrap;
        }

        td {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
        }

        /* マトリクス表示用のスタイル */
        table tr td:first-child,
        table tr th:first-child {
            position: sticky;
            left: 0;
            background: white;
            z-index: 1;
        }

        table tr th:first-child {
            z-index: 2;
        }

        /* rowspan固定列の改善 - デスクトップでは改行しない */
        table td[rowspan] {
            white-space: nowrap;
            position: sticky;
            left: 0;
            z-index: 1;
        }

        /* タブレット以下で改行を許可 */
        @media (max-width: 1024px) {
            table td[rowspan] {
                white-space: normal;
                word-wrap: break-word;
                overflow-wrap: break-word;
                max-width: 14vw; /* 画面幅の14% (16%→14%) */
            }

            table tr td:first-child {
                max-width: 14vw;
                white-space: normal;
                word-wrap: break-word;
            }
        }

        /* モバイル用の固定列の幅制限 */
        @media (max-width: 768px) {
            /* すべてのth, tdのmin-widthをリセットしてコンパクトに */
            table th,
            table td {
                min-width: auto !important;
                padding: 6px 8px;
            }

            table td[rowspan] {
                max-width: 18vw; /* 画面幅の18% (20%→18%) */
                padding: 8px 6px;
            }

            table tr td:first-child,
            table tr th:first-child {
                max-width: 18vw;
                min-width: 80px !important; /* 固定列の最小幅を80pxに制限 */
                padding: 8px 6px;
            }
        }

        /* 小型モバイル */
        @media (max-width: 480px) {
            /* パディングをさらに縮小 */
            table th,
            table td {
                padding: 4px 6px;
                font-size: 12px;
            }

            table td[rowspan] {
                max-width: 25vw; /* 画面幅の25% */
                padding: 6px 4px;
            }

            table tr td:first-child,
            table tr th:first-child {
                max-width: 25vw;
                min-width: 70px !important; /* 固定列の最小幅を70pxに制限 */
                padding: 6px 4px;
            }

            /* コンテンツエリアをさらに縮小 */
            .content {
                padding: 8px !important;
            }

            /* バージョンヘッダーをさらに縮小 */
            .version-header {
                padding: 6px 10px !important;
                font-size: 14px !important;
                margin-bottom: 8px !important;
            }

            /* カード要素をさらに縮小 */
            [style*="padding: 15px"],
            [style*="padding: 20px"],
            [style*="padding: 10px"] {
                padding: 8px !important;
            }

            /* フォントサイズを全体的に縮小 */
            h3 {
                font-size: 14px !important;
                margin-bottom: 8px !important;
            }
        }

        /* 週末・祝日の行の固定列背景色 */
        table tr[style*="ffebee"] td:first-child,
        table tr[style*="ffebee"] td[rowspan] {
            background: #ffebee;
        }

        /* 小計行 */
        table tr[style*="fff3cd"] td:first-child,
        table tr[style*="fff3cd"] td[rowspan] {
            background: #fff3cd;
        }

        /* 版数合計行（グレー背景） */
        table tr[style*="f5f5f5"] td:first-child {
            background: #f5f5f5;
        }

        /* 総合計行（濃いグレー） */
        table tr[style*="2c3e50"] td:first-child,
        table tr[style*="2c3e50"] td[rowspan] {
            background: #2c3e50;
            color: white;
        }

        /* 総合計行（青） */
        table tr[style*="1565c0"] td:first-child,
        table tr[style*="1565c0"] td[rowspan],
        table tr[style*="1565c0"] th:first-child {
            background: #1565c0;
            color: white;
        }

        /* 祝日表示のレスポンシブ制御 */
        /* デスクトップ: 1行で表示 */
        .holiday-inline {
            display: inline;
        }
        .holiday-break {
            display: none;
        }

        /* タブレット以下: 2行で表示 */
        @media (max-width: 1024px) {
            .holiday-inline {
                display: none;
            }
            .holiday-break {
                display: inline;
            }
        }

        /* 対応名の表示制御（祝日と同じ方式） */
        /* デスクトップ: 1行で表示 */
        .task-separator-inline {
            display: inline;
        }
        .task-separator-break {
            display: none;
        }

        /* タブレット以下: 「:」「：」で改行 */
        @media (max-width: 1024px) {
            .task-separator-inline {
                display: none;
            }
            .task-separator-break {
                display: inline;
            }
        }

        /* モーダル */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.2s;
        }

        .custom-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            margin-top: 4px;
        }

        .custom-dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            font-size: 14px;
            color: #333;
        }

        .custom-dropdown-item:last-child {
            border-bottom: none;
        }

        .custom-dropdown-item:hover {
            background-color: #e3f2fd;
            color: #000;
        }

        .custom-dropdown-item.selected {
            background-color: #e3f2fd;
            color: #000;
        }

        .custom-dropdown-empty {
            padding: 20px;
            text-align: center;
            color: #999;
            font-size: 14px;
        }

        #quickTaskSearch {
            cursor: text;
        }

        #quickTaskSearch:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s;
        }

        .modal-header {
            color: white;
            padding: 15px 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* モーダルヘッダーのデフォルト色（テーマ適用前） */
        .modal-header:not([class*="modal-theme-"]) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* モーダル用テーマ色 */
        .modal-theme-purple { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .modal-theme-deep-blue { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .modal-theme-teal { background: linear-gradient(135deg, #0f766e 0%, #14b8a6 100%); }
        .modal-theme-cyan { background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); }
        .modal-theme-ocean { background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%); }
        .modal-theme-sky { background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); }
        .modal-theme-indigo { background: linear-gradient(135deg, #4338ca 0%, #6366f1 100%); }
        .modal-theme-navy { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); }
        .modal-theme-slate { background: linear-gradient(135deg, #334155 0%, #475569 100%); }
        .modal-theme-green { background: linear-gradient(135deg, #047857 0%, #10b981 100%); }
        .modal-theme-emerald { background: linear-gradient(135deg, #059669 0%, #34d399 100%); }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .modal-close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
        }

        .modal-close:hover {
            opacity: 0.8;
        }

        .modal-body {
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .work-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .work-item:last-child {
            margin-bottom: 0;
        }

        .work-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .work-item-title {
            font-weight: 600;
            font-size: 15px;
            color: #2c3e50;
        }

        .work-item-hours {
            font-size: 18px;
            font-weight: 700;
            color: #3498db;
        }

        .work-item-details {
            font-size: 13px;
            color: #666;
            line-height: 1.6;
        }

        .work-item-details span {
            display: inline-block;
            margin-right: 12px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-ui { background: #e3f2fd; color: #1976d2; }
        .badge-pg { background: #f3e5f5; color: #7b1fa2; }
        .badge-pt { background: #fff3e0; color: #f57c00; }
        .badge-it { background: #e8f5e9; color: #388e3c; }
        .badge-st { background: #fce4ec; color: #c2185b; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            padding: 20px;
            border-radius: 10px;
            color: white;
        }

        .stat-card h3 {
            font-size: 14px;
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 32px;
            font-weight: 700;
        }

        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
            }

            h1 {
                font-size: 18px;
            }

            .header-buttons {
                flex-direction: column;
            }

            .header-buttons .btn {
                width: 100%;
            }

            .quick-form {
                grid-template-columns: 1fr;
            }

            /* 見積テーブルのモバイル対応 */
            .estimate-table-wrapper {
                /* overflow-x削除で全列表示 */
            }

            .estimate-table {
                display: table;
                table-layout: fixed;
                width: 100%;
                min-width: 100%;
            }

            .estimate-table th,
            .estimate-table td {
                padding: 4px 6px;
            }

            /* 見積登録の各列幅をモバイル用に調整 */
            .estimate-table th:nth-child(1),
            .estimate-table td:nth-child(1) {
                width: 20%;
            }

            .estimate-table th:nth-child(2),
            .estimate-table td:nth-child(2) {
                width: 42%;
            }

            .estimate-table th:nth-child(3),
            .estimate-table td:nth-child(3) {
                width: 38%;
            }

            .estimate-table td:nth-child(2) select {
                font-size: 12px;
                padding: 4px 6px;
                width: 100%;
                box-sizing: border-box;
            }

            .estimate-table td:nth-child(3) input {
                font-size: 12px;
                padding: 4px 6px;
                width: 100%;
                box-sizing: border-box;
            }

            table {
                font-size: 13px;
            }

            /* コンテンツエリアのパディングを縮小 */
            .content {
                padding: 10px;
            }

            /* バージョンヘッダーのパディングを縮小 */
            .version-header {
                padding: 8px 12px !important;
                font-size: 16px !important;
                margin-bottom: 10px !important;
            }

            /* カード要素のパディング・マージンを縮小 */
            [style*="padding: 15px"],
            [style*="padding: 20px"] {
                padding: 10px !important;
            }

            /* h3のマージンを縮小 */
            h3 {
                margin-bottom: 10px !important;
            }

            /* 作業月割り当てモードのモバイル対応 */
            #workMonthAssignmentMode > div {
                flex-direction: column;
                align-items: stretch !important;
            }

            #workMonthAssignmentMode > div > div,
            #workMonthAssignmentMode > div > button {
                width: 100%;
            }

            #selectedWorkHours {
                margin-left: 0 !important;
                margin-top: 10px;
                text-align: center;
            }
        }
        
        /* テーマカラー用CSS */
        .theme-bg {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        /* 色の定義 */
        .theme-purple { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .theme-deep-blue { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .theme-teal { background: linear-gradient(135deg, #0f766e 0%, #14b8a6 100%); }
        .theme-cyan { background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); }
        .theme-ocean { background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%); }
        .theme-sky { background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); }
        .theme-indigo { background: linear-gradient(135deg, #4338ca 0%, #6366f1 100%); }
        .theme-navy { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); }
        .theme-slate { background: linear-gradient(135deg, #334155 0%, #475569 100%); }
        .theme-green { background: linear-gradient(135deg, #047857 0%, #10b981 100%); }
        .theme-emerald { background: linear-gradient(135deg, #059669 0%, #34d399 100%); }
        
        /* タブ用の色クラス（模様なし、position/overflowなし） */
        .tab-theme-purple { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .tab-theme-deep-blue { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .tab-theme-teal { background: linear-gradient(135deg, #0f766e 0%, #14b8a6 100%); }
        .tab-theme-cyan { background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); }
        .tab-theme-ocean { background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%); }
        .tab-theme-sky { background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); }
        .tab-theme-indigo { background: linear-gradient(135deg, #4338ca 0%, #6366f1 100%); }
        .tab-theme-navy { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); }
        .tab-theme-slate { background: linear-gradient(135deg, #334155 0%, #475569 100%); }
        .tab-theme-green { background: linear-gradient(135deg, #047857 0%, #10b981 100%); }
        .tab-theme-emerald { background: linear-gradient(135deg, #059669 0%, #34d399 100%); }
        
        /* グロー効果 */
        .theme-cyan.pattern-glow { box-shadow: 0 4px 20px rgba(8, 145, 178, 0.3); }
        
        /* 模様の定義 */
        .theme-bg.pattern-wave::before {
            content: '';
            position: absolute;
            top: -30%;
            right: -5%;
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.08);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-wave::after {
            content: '';
            position: absolute;
            bottom: -20%;
            left: -5%;
            width: 100px;
            height: 100px;
            background: rgba(255,255,255,0.05);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-stripe::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 3px;
            background: rgba(255,255,255,0.25);
            pointer-events: none;
        }
        
        .theme-bg.pattern-corner::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.12);
            border-radius: 0 10px 0 100%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-dot::before {
            content: '';
            position: absolute;
            top: 20px;
            right: 20px;
            width: 10px;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-dots::before {
            content: '';
            position: absolute;
            top: 20px;
            right: 20px;
            width: 8px;
            height: 8px;
            background: rgba(255,255,255,0.25);
            border-radius: 50%;
            box-shadow: 18px 0 0 rgba(255,255,255,0.25), 36px 0 0 rgba(255,255,255,0.25);
            pointer-events: none;
        }
        
        .theme-bg.pattern-diagonal::before {
            content: '';
            position: absolute;
            top: -20px;
            right: 40px;
            width: 80px;
            height: 150%;
            background: rgba(255,255,255,0.06);
            transform: skewX(-15deg);
            pointer-events: none;
        }
        
        .theme-bg.pattern-circle::before {
            content: '';
            position: absolute;
            top: 50%;
            right: -30px;
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.05);
            border-radius: 50%;
            transform: translateY(-50%);
            pointer-events: none;
        }
        
        .theme-bg.pattern-layer::before {
            content: '';
            position: absolute;
            top: 0;
            right: -60px;
            width: 180px;
            height: 100%;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.04) 100%);
            transform: skewX(-20deg);
            pointer-events: none;
        }
        
        .theme-bg.pattern-line::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
            pointer-events: none;
        }
        
        .theme-bg.pattern-bar {
            border-left: 3px solid rgba(255,255,255,0.35);
        }
        
        .theme-bg.pattern-border {
            border-top: 2px solid rgba(255,255,255,0.25);
        }
        
        .theme-bg.pattern-glow::after {
            content: '';
            position: absolute;
            top: -20%;
            right: -10%;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
            pointer-events: none;
        }
        
        /* 作業月表示のレスポンシブ対応 */
        /* デフォルト（広い画面）: 1行表示 */
        .work-month-inline {
            display: inline;
        }
        .work-month-block {
            display: none;
        }
        
        /* 狭い画面（1024px以下）: 2行表示 */
        @media (max-width: 1024px) {
            .work-month-inline {
                display: none;
            }
            .work-month-block {
                display: block;
            }
        }
        
        /* その他作業モーダル用スタイル */
        .other-work-tab {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .other-work-tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
            font-weight: 600;
        }
        
        .other-work-tab:hover {
            color: #3498db;
        }
        
        .other-work-form {
            animation: fadeIn 0.3s;
        }

        /* セグメントボタンコンテナのスクロールバースタイル */
        #estimateMonthButtons2,
        #actualMemberButtons2,
        #actualMonthButtons2,
        #reportMonthButtons2 {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 #f1f5f9;
        }

        #estimateMonthButtons2::-webkit-scrollbar,
        #actualMemberButtons2::-webkit-scrollbar,
        #actualMonthButtons2::-webkit-scrollbar,
        #reportMonthButtons2::-webkit-scrollbar {
            height: 6px;
        }

        #estimateMonthButtons2::-webkit-scrollbar-track,
        #actualMemberButtons2::-webkit-scrollbar-track,
        #actualMonthButtons2::-webkit-scrollbar-track,
        #reportMonthButtons2::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        #estimateMonthButtons2::-webkit-scrollbar-thumb,
        #actualMemberButtons2::-webkit-scrollbar-thumb,
        #actualMonthButtons2::-webkit-scrollbar-thumb,
        #reportMonthButtons2::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }

        #estimateMonthButtons2::-webkit-scrollbar-thumb:hover,
        #actualMemberButtons2::-webkit-scrollbar-thumb:hover,
        #actualMonthButtons2::-webkit-scrollbar-thumb:hover,
        #reportMonthButtons2::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>工数管理システム</h1>
            <div class="header-buttons">
                <button class="btn btn-success" onclick="exportBackup()">バックアップ</button>
                <button class="btn btn-primary" onclick="importBackup()">復元</button>
            </div>
        </header>

        <div class="tabs">
            <button class="tab active tab-theme-purple" onclick="showTab('quick')">クイック入力</button>
            <button class="tab" onclick="showTab('estimate')">見積一覧</button>
            <button class="tab" onclick="showTab('actual')">実績一覧</button>
            <button class="tab" onclick="showTab('report')">レポート</button>
            <button class="tab" onclick="showTab('settings')">⚙️ 設定</button>
        </div>

        <div class="content">
            <div id="quick" class="tab-content active">
                <div class="quick-input theme-bg theme-purple">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2 id="quickModeTitle" style="margin: 0;">今日の実績を入力</h2>

                        <!-- セグメントボタン -->
                        <div style="display: inline-flex; border: 2px solid rgba(255,255,255,0.3); border-radius: 6px; overflow: hidden; background: rgba(255,255,255,0.1);">
                            <button id="quickActualModeBtn" onclick="switchQuickInputMode('actual')" style="padding: 6px 16px; border: none; background: rgba(255,255,255,0.9); color: rgba(0,0,0,0.85); cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s;">実績入力</button>
                            <button id="quickEstimateModeBtn" onclick="switchQuickInputMode('estimate')" style="padding: 6px 16px; border: none; background: transparent; color: rgba(255,255,255,0.85); cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s;">見積登録</button>
                        </div>
                    </div>

                    <!-- 実績入力フォーム -->
                    <div id="quickActualForm" class="quick-form">
                        <div class="form-group">
                            <label>対応検索・選択</label>
                            <div style="position: relative;">
                                <input 
                                    type="text" 
                                    id="quickTaskSearch" 
                                    placeholder="クリックして対応を選択..." 
                                    autocomplete="off"
                                    oninput="filterQuickTaskList()"
                                    onclick="showQuickTaskDropdown()"
                                    style="padding-right: 35px;">
                                <button 
                                    id="quickTaskClearBtn"
                                    onclick="clearQuickTaskSelection()"
                                    style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #999; cursor: pointer; font-size: 18px; padding: 4px 8px; line-height: 1;"
                                    title="クリア">×</button>
                                <div id="quickTaskDropdown" class="custom-dropdown" style="display: none;">
                                    <!-- JavaScriptで動的に生成 -->
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div class="form-group">
                                <label>担当</label>
                                <select id="quickMemberSelect" onchange="handleMemberChange()">
                                    <option value="">（自動）</option>
                                </select>
                                <small style="color: #999; font-size: 11px;">通常は自動、必要時のみ変更</small>
                            </div>
                            <div class="form-group">
                                <label>実績工数 (h)</label>
                                <input type="number" id="quickHours" step="0.5" min="0">
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-success" onclick="quickAddActual()" style="flex: 2;">追加</button>
                            <button class="btn" onclick="openOtherWorkModal()" style="flex: 1; background: rgba(255,255,255,0.2); color: white;">その他</button>
                        </div>
                    </div>

                    <!-- 見積登録フォーム -->
                    <div id="quickEstimateForm" class="quick-form" style="display: none;">
                        <div class="form-group">
                            <label>版数</label>
                            <select id="quickEstVersion" onchange="handleVersionChange('quickEstVersion')">
                                <option value="">-- 版数を選択 --</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>対応名</label>
                            <input type="text" id="quickEstTask" placeholder="帳票A_X対応">
                        </div>
                        <div class="form-group">
                            <label>作業月</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="quickEstStartMonth" onchange="updateQuickEstWorkMonthUI()"></select>
                                <span id="quickEstMonthSeparator" style="display: none;">〜</span>
                                <select id="quickEstEndMonth" onchange="updateQuickEstWorkMonthUI()" style="display: none;"></select>
                            </div>
                        </div>
                        <h4 style="margin-bottom: 10px; color: rgba(255,255,255,0.9);">各工程の見積</h4>
                        <div class="estimate-table-wrapper">
                            <table class="estimate-table" id="quickEstimateTable" style="width: 100%; margin: 0;">
                                <thead>
                                    <tr>
                                        <th style="width: 60px; padding: 8px; text-align: center;">工程</th>
                                        <th style="width: 120px; padding: 8px;">担当</th>
                                        <th style="width: 100px; padding: 8px;">時間</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-ui">UI</span></td>
                                        <td><select id="quickEstUI_member" style="margin: 0;"></select></td>
                                        <td><input type="number" id="quickEstUI" placeholder="h" step="0.5" style="margin: 0;"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-pg">PG</span></td>
                                        <td><select id="quickEstPG_member" style="margin: 0;"></select></td>
                                        <td><input type="number" id="quickEstPG" placeholder="h" step="0.5" style="margin: 0;"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-pt">PT</span></td>
                                        <td><select id="quickEstPT_member" style="margin: 0;"></select></td>
                                        <td><input type="number" id="quickEstPT" placeholder="h" step="0.5" style="margin: 0;"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-it">IT</span></td>
                                        <td><select id="quickEstIT_member" style="margin: 0;"></select></td>
                                        <td><input type="number" id="quickEstIT" placeholder="h" step="0.5" style="margin: 0;"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-st">ST</span></td>
                                        <td><select id="quickEstST_member" style="margin: 0;"></select></td>
                                        <td><input type="number" id="quickEstST" placeholder="h" step="0.5" style="margin: 0;"></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- 月分割アシスタント -->
                        <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid rgba(255,255,255,0.3);">
                            <div class="form-group" style="margin-bottom: 10px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="quickEnableMonthSplit" onchange="toggleQuickMonthSplit()" style="width: auto; margin-right: 10px;">
                                    <span style="font-weight: 600; color: #1976d2;">複数月に分割して登録</span>
                                </label>
                                <small style="color: rgba(255,255,255,0.7); display: block; margin-top: 5px;">
                                    一つの工程を複数月で作業する場合に、月別の工数を設定できます
                                </small>
                            </div>

                            <div id="quickMonthSplitPanel" style="display: none; margin-top: 15px;">
                                <div class="form-group">
                                    <label>分割する工程を選択</label>
                                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitUI" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>UI</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitPG" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>PG</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitPT" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>PT</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitIT" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>IT</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitST" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>ST</span>
                                        </label>
                                    </div>
                                    <small style="color: rgba(255,255,255,0.7); display: block; margin-top: 5px;">
                                        チェックした工程のみが月分割されます。チェックしていない工程は通常通り登録されます。
                                    </small>
                                </div>

                                <div class="form-group">
                                    <label>総工数</label>
                                    <input type="number" id="quickTotalHours" step="0.1" min="0" placeholder="例: 80" oninput="updateQuickMonthPreview()">
                                    <span style="margin-left: 5px;">時間</span>
                                </div>

                                <div class="form-group">
                                    <label>作業期間</label>
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <select id="quickStartMonth" onchange="updateQuickMonthPreview()"></select>
                                        <span>〜</span>
                                        <select id="quickEndMonth" onchange="updateQuickMonthPreview()"></select>
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label>分割方法</label>
                                    <div style="display: flex; gap: 20px;">
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="radio" name="quickSplitMethod" value="equal" checked onchange="updateQuickMonthPreview()" style="width: auto; margin-right: 5px;">
                                            <span>均等分割</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="radio" name="quickSplitMethod" value="manual" onchange="updateQuickMonthPreview()" style="width: auto; margin-right: 5px;">
                                            <span>手動設定</span>
                                        </label>
                                    </div>
                                </div>

                                <div id="quickMonthPreview" style="margin-top: 15px;"></div>
                            </div>
                        </div>

                        <button class="btn" onclick="addQuickEstimate()" style="margin-top: 15px; background: rgba(255,255,255,0.9); color: #7b3ff2; font-weight: 600;">登録</button>
                    </div>
                </div>

                <h3 id="quickBottomTitle">今日の入力済み実績</h3>
                <div id="todayActuals"></div>
            </div>

            <div id="estimate" class="tab-content">
                <h2>見積一覧</h2>

                <!-- 合計工数表示 -->
                <div id="estimateTotalCard" style="color: white; padding: 15px 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">合計工数</div>
                            <div style="font-size: 28px; font-weight: bold;" id="estimateTotalHours">0h</div>
                        </div>
                        <div>
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">人日 / 人月</div>
                            <div style="font-size: 18px; font-weight: 600;" id="estimateTotalManpower">0人日 / 0人月</div>
                        </div>
                    </div>
                </div>

                <!-- 担当者別合計表示 -->
                <div id="estimateMemberSummary" style="background: #f8f9fa; padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; display: none;">
                    <div style="font-size: 14px; font-weight: 600; color: #495057; margin-bottom: 10px;">担当者別合計</div>
                    <div id="estimateMemberSummaryContent" style="display: flex; flex-wrap: wrap; gap: 12px;">
                    </div>
                </div>

                <!-- バージョン1: 横並びコンパクトレイアウト -->
                <div id="estimateFiltersCompact" style="display: flex; flex-wrap: nowrap; gap: 10px; align-items: center; margin-bottom: 20px; background: #f8f9fa; padding: 10px; border-radius: 6px; overflow-x: auto;">
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                        <select id="estimateViewType" onchange="renderEstimateList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="grouped">グループ</option>
                            <option value="matrix">マトリクス</option>
                            <option value="list">リスト</option>
                        </select>
                    </div>

                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示月:</label>
                        <select id="estimateMonthFilter" onchange="renderEstimateList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全期間</option>
                        </select>
                    </div>

                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="display: flex; align-items: center; cursor: pointer; user-select: none; font-size: 12px; font-weight: 500; white-space: nowrap;">
                            <input type="checkbox" id="workMonthSelectionMode" onchange="toggleWorkMonthSelectionMode()" style="width: auto; margin-right: 5px;">
                            <span>作業月割り当て</span>
                        </label>
                    </div>
                </div>

                <!-- バージョン2: セグメントボタンレイアウト（切り替え用） -->
                <div id="estimateFiltersSegmented" style="display: none; margin-bottom: 20px; background: #f8f9fa; padding: 12px; border-radius: 6px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <div style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow: hidden; background: white;">
                                <button id="btnEstimateGrouped" onclick="setEstimateViewType('grouped')" style="padding: 6px 14px; border: none; background: white; cursor: pointer; font-size: 13px; transition: all 0.2s;">グループ</button>
                                <button id="btnEstimateMatrix" onclick="setEstimateViewType('matrix')" style="padding: 6px 14px; border: none; border-left: 1px solid #dee2e6; background: white; cursor: pointer; font-size: 13px; transition: all 0.2s;">マトリクス</button>
                                <button id="btnEstimateList" onclick="setEstimateViewType('list')" style="padding: 6px 14px; border: none; border-left: 1px solid #dee2e6; background: white; cursor: pointer; font-size: 13px; transition: all 0.2s;">リスト</button>
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示月:</label>
                            <div id="estimateMonthButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: 600px;">
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="display: flex; align-items: center; cursor: pointer; user-select: none; font-size: 13px; font-weight: 500; white-space: nowrap;">
                                <input type="checkbox" id="workMonthSelectionMode2" onchange="toggleWorkMonthSelectionMode()" style="width: auto; margin-right: 5px;">
                                <span>作業月割り当て</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- 作業月割り当てモード（フロート表示） -->
                <div id="workMonthAssignmentMode" style="display: none; background: linear-gradient(135deg, #fff3cd 0%, #ffe5a0 100%); padding: 18px; border-radius: 8px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; box-shadow: 0 4px 20px rgba(0,0,0,0.2); border-left: 4px solid #ffc107; max-width: 90vw;">
                    <!-- ドラッグハンドル -->
                    <div id="dragHandle" style="position: absolute; top: 0; left: 0; right: 0; height: 8px; background: rgba(0,0,0,0.1); border-radius: 8px 8px 0 0; cursor: ns-resize; display: flex; align-items: center; justify-content: center; z-index: 1;">
                        <div style="width: 40px; height: 4px; background: rgba(0,0,0,0.3); border-radius: 2px;"></div>
                    </div>

                    <!-- 閉じるボタン -->
                    <button onclick="closeWorkMonthAssignmentMode()" style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); border: 2px solid #856404; font-size: 20px; font-weight: bold; color: #856404; cursor: pointer; padding: 0; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.2); line-height: 1;" onmouseover="this.style.background='#856404'; this.style.color='white';" onmouseout="this.style.background='rgba(255,255,255,0.9)'; this.style.color='#856404';">&times;</button>

                    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; margin-top: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="font-weight: 600; color: #856404;">割り当て先:</label>
                            <select id="assignWorkMonth" style="padding: 8px 12px; border: 2px solid #ffc107; border-radius: 6px; font-weight: 500; font-size: 14px; background: white;">
                            </select>
                        </div>
                        <button class="btn btn-success" onclick="executeWorkMonthAssignment()" style="margin: 0; font-weight: 600; padding: 8px 20px;">
                            ✓ 割り当て実行
                        </button>
                        <button class="btn" onclick="cancelWorkMonthSelection()" style="margin: 0; background: #6c757d; color: white; padding: 8px 16px;">
                            選択解除
                        </button>
                        <div id="selectedWorkHours" style="margin-left: auto; font-weight: 700; font-size: 18px; color: #1976d2; white-space: nowrap;">
                            選択中: 0h (0人日 / 0人月)
                        </div>
                    </div>
                </div>
                
                <div id="estimateList"></div>
            </div>

            <div id="actual" class="tab-content">
                <h2>実績データ一覧</h2>

                <!-- バージョン1: 横並びコンパクトレイアウト -->
                <div id="actualFiltersCompact" style="display: flex; flex-wrap: nowrap; gap: 10px; align-items: center; margin-bottom: 20px; background: #f8f9fa; padding: 10px; border-radius: 6px; overflow-x: auto;">
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示モード:</label>
                        <select id="actualViewMode" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全担当者</option>
                            <option value="member">担当者別</option>
                        </select>
                    </div>

                    <div id="memberSelectGroup" style="display: none; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">担当者:</label>
                        <select id="actualMemberSelect" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                        </select>
                    </div>

                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                        <select id="actualViewType" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="matrix">カレンダー</option>
                            <option value="list">リスト</option>
                        </select>
                    </div>

                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示期間:</label>
                        <select id="actualMonthFilter" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全期間</option>
                        </select>
                    </div>
                </div>

                <!-- バージョン2: セグメントボタンレイアウト（切り替え用） -->
                <div id="actualFiltersSegmented" style="display: none; margin-bottom: 20px; background: #f8f9fa; padding: 12px; border-radius: 6px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示モード:</label>
                            <select id="actualViewMode2" onchange="document.getElementById('actualViewMode').value = this.value; renderActualList()" style="padding: 4px 8px; font-size: 13px;">
                                <option value="all">全担当者</option>
                                <option value="member">担当者別</option>
                            </select>
                        </div>

                        <div id="memberSelectGroup2" style="display: none; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">担当者:</label>
                            <!-- セグメントボタン版 -->
                            <div id="actualMemberButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: 600px;">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="actualMemberSelect2" onchange="document.getElementById('actualMemberSelect').value = this.value; renderActualList()" style="padding: 4px 8px; font-size: 13px; display: none;">
                            </select>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <div style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow: hidden; background: white;">
                                <button onclick="setActualViewType('matrix')" id="btnActualMatrix" style="padding: 4px 12px; font-size: 12px; border: none; background: #007bff; color: white; cursor: pointer; transition: all 0.2s;">カレンダー</button>
                                <button onclick="setActualViewType('list')" id="btnActualList" style="padding: 4px 12px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; border-left: 1px solid #dee2e6; transition: all 0.2s;">リスト</button>
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示期間:</label>
                            <!-- セグメントボタン版 -->
                            <div id="actualMonthButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: 800px;">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="actualMonthFilter2" onchange="document.getElementById('actualMonthFilter').value = this.value; renderActualList()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全期間</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="actualList"></div>
            </div>

            <div id="report" class="tab-content">
                <h2>工数レポート</h2>

                <!-- バージョン1: 横並びコンパクトレイアウト -->
                <div id="reportFiltersCompact" style="display: flex; flex-wrap: nowrap; gap: 10px; align-items: center; margin-bottom: 20px; background: #f8f9fa; padding: 10px; border-radius: 6px; overflow-x: auto;">
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示月:</label>
                        <select id="reportMonth" onchange="updateReport()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全期間</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                        <select id="reportViewType" onchange="updateReport()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="summary">サマリー</option>
                            <option value="grouped" selected>グループ</option>
                            <option value="matrix">マトリクス</option>
                        </select>
                    </div>
                </div>

                <!-- バージョン2: セグメントボタンレイアウト（切り替え用） -->
                <div id="reportFiltersSegmented" style="display: none; margin-bottom: 20px; background: #f8f9fa; padding: 12px; border-radius: 6px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示月:</label>
                            <!-- セグメントボタン版 -->
                            <div id="reportMonthButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: 800px;">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="reportMonth2" onchange="document.getElementById('reportMonth').value = this.value; updateReport()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全期間</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <div style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow: hidden; background: white;">
                                <button onclick="setReportViewType('summary')" id="btnReportSummary" style="padding: 4px 10px; font-size: 12px; border: none; background: #007bff; color: white; cursor: pointer; transition: all 0.2s;">サマリー</button>
                                <button onclick="setReportViewType('grouped')" id="btnReportGrouped" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; border-left: 1px solid #dee2e6; transition: all 0.2s;">グループ</button>
                                <button onclick="setReportViewType('matrix')" id="btnReportMatrix" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; border-left: 1px solid #dee2e6; transition: all 0.2s;">マトリクス</button>
                            </div>
                        </div>
                    </div>
                </div>

                <h3 id="reportPeriodTitle">全期間の集計</h3>

                <div class="stats-grid">
                    <div class="stat-card theme-bg theme-purple">
                        <h3>総見積工数</h3>
                        <div class="value" id="totalEstimate">0h</div>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.8); margin-top: 5px;" id="totalEstimateManpower"></div>
                    </div>
                    <div class="stat-card theme-bg theme-purple">
                        <h3>総実績工数</h3>
                        <div class="value" id="totalActual">0h</div>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.8); margin-top: 5px;" id="totalActualManpower"></div>
                    </div>
                    <div class="stat-card theme-bg theme-purple">
                        <h3>差異</h3>
                        <div class="value" id="totalDiff">0h</div>
                    </div>
                    <div class="stat-card theme-bg theme-purple">
                        <h3>実績率</h3>
                        <div class="value" id="actualRate">0%</div>
                    </div>
                </div>

                <div id="reportDetailView"></div>

                <h3>担当者別工数</h3>
                <div id="memberReport"></div>

                <h3 style="margin-top: 20px;">版数別進捗</h3>
                <div id="versionReport"></div>
                
                <!-- Excel出力セクション -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 30px 0;">
                    <h3>📊 Excel出力</h3>
                    <p style="color: #666; margin-bottom: 15px;">実績データと見積データをExcel形式で出力します。</p>
                    
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin-bottom: 8px; font-size: 14px;">出力内容:</h4>
                        <ul style="color: #666; font-size: 13px; margin-left: 20px;">
                            <li><strong>実績シート（担当者別）:</strong> 日付、曜日、備考、作業、時間</li>
                            <li><strong>見積シート:</strong> 版数、作業月、対応名、工程、担当、見積工数</li>
                        </ul>
                    </div>
                    
                    <button class="btn btn-success" onclick="exportToExcel()" style="font-weight: 600;">
                        📥 Excelファイルをダウンロード
                    </button>
                </div>
            </div>

            <div id="settings" class="tab-content">
                <h2>⚙️ 設定</h2>
                
                <!-- テーマカラー設定 -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>🎨 テーマカラー</h3>
                    <p style="color: #666; margin-bottom: 15px;">アプリの配色を変更できます。クイック入力エリア、レポート集計、アクティブタブに適用されます。</p>
                    
                    <div class="form-group">
                        <label>色</label>
                        <select id="themeColor" onchange="applyTheme()">
                            <option value="purple">紫（現在）</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="indigo">インディゴ</option>
                            <option value="navy">ネイビー</option>
                            <option value="slate">スレート</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>デザイン</label>
                        <select id="themePattern" onchange="applyTheme()">
                            <option value="none">シンプル（模様なし）</option>
                            <option value="wave">波模様</option>
                            <option value="stripe">右ストライプ</option>
                            <option value="glow">グロー効果</option>
                            <option value="corner">コーナーアクセント</option>
                            <option value="dot">ドット</option>
                            <option value="dots">複数ドット</option>
                            <option value="diagonal">斜線パターン</option>
                            <option value="circle">サークル</option>
                            <option value="layer">レイヤー</option>
                            <option value="line">グラデーションライン</option>
                            <option value="bar">左バー</option>
                            <option value="border">上部ボーダー</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>タブの色</label>
                        <select id="themeTabColor" onchange="applyTheme()">
                            <option value="same">メインカラーと同じ</option>
                            <option value="default">デフォルト（青）</option>
                            <option value="purple">紫</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="indigo">インディゴ</option>
                            <option value="navy">ネイビー</option>
                            <option value="slate">スレート</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            タブの色を個別に設定できます
                        </small>
                    </div>
                    
                    <div class="form-group">
                        <label>背景色</label>
                        <select id="themeBackgroundColor" onchange="applyTheme()">
                            <option value="same">メインカラーと同じ</option>
                            <option value="purple">紫</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="indigo">インディゴ</option>
                            <option value="navy">ネイビー</option>
                            <option value="slate">スレート</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ページ全体の背景色を個別に設定できます
                        </small>
                    </div>
                    
                    <!-- プレビュー -->
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600;">プレビュー</label>
                        <div id="themePreview" style="padding: 20px; border-radius: 8px; color: white; position: relative; overflow: hidden;">
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">クイック実績入力</div>
                            <div style="font-size: 14px;">レポート集計カード・アクティブタブにも適用されます</div>
                        </div>
                    </div>
                    
                    <small style="color: #666; display: block; margin-top: 10px;">
                        ・設定は自動的に保存されます<br>
                        ・ページをリロードしても設定は保持されます
                    </small>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>自動バックアップ</h3>
                    <p style="color: #666; margin-bottom: 15px;">データ保存時に自動的にJSONファイルをダウンロードします。</p>
                    
                    <div class="form-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="autoBackupEnabled" onchange="saveAutoBackupSetting()" style="width: auto; margin-right: 10px;">
                            <span>自動バックアップを有効にする</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オンにすると、実績や見積の登録・編集時に自動でバックアップファイルがダウンロードされます<br>
                            ・オフにしても、手動バックアップボタンは使用できます
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>クイック入力モード</h3>
                    <p style="color: #666; margin-bottom: 15px;">クイック入力タブの実績入力/見積登録モードの動作を設定できます。</p>

                    <div class="form-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="rememberQuickInputMode" onchange="saveQuickInputModeSetting()" style="width: auto; margin-right: 10px;">
                            <span>前回のモード（実績/見積）を記憶する</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オフ（デフォルト）: 常に実績入力モードで開始します<br>
                            ・オン: 前回使用したモード（実績入力 or 見積登録）を記憶し、次回も同じモードで開始します
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>担当者表示順</h3>
                    <p style="color: #666; margin-bottom: 15px;">担当者の表示順序を指定できます。この順序は実績一覧、レポート、入力フォームなど全ての画面に適用されます。</p>
                    
                    <div class="form-group">
                        <label>表示順序 <button onclick="showMemberOrderHelp()" style="border: none; background: none; cursor: pointer; color: #3498db; font-size: 18px;">ℹ️</button></label>
                        <input type="text" id="memberOrder" placeholder="例: A,B,C,D または 山田,佐藤,田中" onchange="updateAllDisplays()">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・カンマ区切りで入力してください<br>
                            ・指定した順番で表示されます<br>
                            ・指定していない担当者は後ろにアルファベット順で表示されます<br>
                            ・設定は自動的に保存されます
                        </small>
                    </div>
                    
                    <button class="btn btn-primary" onclick="updateAllDisplays()" style="margin-top: 10px;">設定を適用</button>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>📐 表示形式レイアウト</h3>
                    <p style="color: #666; margin-bottom: 15px;">見積一覧、実績一覧、レポートの表示形式選択UIのレイアウトを変更できます。</p>

                    <div class="form-group">
                        <label>見積一覧のレイアウト</label>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="toggleFilterLayout('estimate', 'compact')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">横並び</button>
                            <button onclick="toggleFilterLayout('estimate', 'segmented')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">セグメント</button>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            横並び: コンパクトな横並びレイアウト<br>
                            セグメント: セグメントボタンを使った見やすいレイアウト
                        </small>
                    </div>

                    <div class="form-group">
                        <label>実績一覧のレイアウト</label>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="toggleFilterLayout('actual', 'compact')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">横並び</button>
                            <button onclick="toggleFilterLayout('actual', 'segmented')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">セグメント</button>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            横並び: コンパクトな横並びレイアウト<br>
                            セグメント: セグメントボタンを使った見やすいレイアウト
                        </small>
                    </div>

                    <div class="form-group">
                        <label>レポートのレイアウト</label>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="toggleFilterLayout('report', 'compact')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">横並び</button>
                            <button onclick="toggleFilterLayout('report', 'segmented')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">セグメント</button>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            横並び: コンパクトな横並びレイアウト<br>
                            セグメント: セグメントボタンを使った見やすいレイアウト
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>📊 レポート分析機能</h3>
                    <p style="color: #666; margin-bottom: 15px;">レポートに表示する分析機能を選択できます。</p>

                    <div class="form-group">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">Phase 1: 即効性の高い改善</label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportAccuracyEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>見積精度の%表示（工程別、版数別）</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportAnomalyEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>異常値のハイライト表示（50%超過を強調）</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportWarningTasksEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>要注意タスクのリスト表示</span>
                        </label>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">Phase 2: 視覚化の強化</label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportChartEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>棒グラフ表示（版数別、工程別）</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportTrendEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>月別推移の表示</span>
                        </label>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">Phase 3: 高度な分析</label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportMemberAnalysisEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>担当者別の詳細分析</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportInsightsEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>インサイト・推奨アクションの表示</span>
                        </label>
                    </div>

                    <small style="color: #666; display: block; margin-top: 10px;">
                        ・設定は自動的に保存されます<br>
                        ・不要な機能をオフにすることで、シンプルなレポート表示にできます
                    </small>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json,.xlsx,.xls" style="display: none;" onchange="handleFileImport(event)">

    <!-- 作業詳細モーダル -->
    <div id="workModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">作業詳細</h3>
                <button class="modal-close" onclick="closeWorkModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
            </div>
        </div>
    </div>

    <!-- 実績編集モーダル -->
    <div id="editActualModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>実績データを編集</h3>
                <button class="modal-close" onclick="closeEditActualModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editActualId">
                <div class="form-group">
                    <label>日付</label>
                    <input type="date" id="editActualDate">
                </div>
                <div class="form-group">
                    <label>版数</label>
                    <select id="editActualVersion" onchange="handleVersionChange('editActualVersion')">
                        <option value="">-- 版数を選択 --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>対応名</label>
                    <select id="editActualTaskSelect" onchange="handleActualTaskSelect()" style="margin-bottom: 10px;">
                        <option value="">-- 対応を選択 --</option>
                    </select>
                    <input type="text" id="editActualTaskSearch" placeholder="対応名を入力" style="display: none;">
                    <small style="color: #666; display: block; margin-top: 5px;">
                        ↑ 未完了の対応を選択、または「新規入力」で新しい対応を追加
                    </small>
                </div>
                <div class="form-group">
                    <label>工程</label>
                    <select id="editActualProcess">
                        <option value="UI">UI</option>
                        <option value="PG">PG</option>
                        <option value="PT">PT</option>
                        <option value="IT">IT</option>
                        <option value="ST">ST</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>担当</label>
                    <select id="editActualMember">
                    </select>
                    <span id="editActualMemberDisplay" style="display: none; padding: 10px; background: #f5f5f5; border-radius: 6px; font-weight: 600;"></span>
                </div>
                <div class="form-group">
                    <label>実績工数</label>
                    <input type="number" id="editActualHours" step="0.5" min="0" placeholder="8">
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveActualEdit()">保存</button>
                    <button class="btn" id="editActualOtherBtn" onclick="openOtherWorkFromCalendar()" style="background: #9b59b6; color: white; display: none;">その他作業</button>
                    <button class="btn" onclick="closeEditActualModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 見積編集モーダル -->
    <div id="editEstimateModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>見積データを編集</h3>
                <button class="modal-close" onclick="closeEditEstimateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editEstimateId">
                <div class="form-group">
                    <label>版数</label>
                    <select id="editEstimateVersion" onchange="handleVersionChange('editEstimateVersion')">
                        <option value="">-- 版数を選択 --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>対応名</label>
                    <input type="text" id="editEstimateTaskSearch" placeholder="検索または新規入力" list="editEstimateTaskList" oninput="handleEstimateTaskInput()">
                    <datalist id="editEstimateTaskList">
                    </datalist>
                    <small style="color: #666; display: block; margin-top: 5px;">
                        ↑ 既存の対応名を選択、または新しい名前を入力
                    </small>
                </div>
                <div class="form-group">
                    <label>工程</label>
                    <select id="editEstimateProcess">
                        <option value="UI">UI</option>
                        <option value="PG">PG</option>
                        <option value="PT">PT</option>
                        <option value="IT">IT</option>
                        <option value="ST">ST</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>担当</label>
                    <select id="editEstimateMember">
                    </select>
                </div>
                <div class="form-group">
                    <label>見積工数</label>
                    <input type="number" id="editEstimateHours" step="0.5" min="0" placeholder="8">
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveEstimateEdit()">保存</button>
                    <button class="btn" onclick="closeEditEstimateModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 既存見積の月分割モーダル -->
    <div id="splitEstimateModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>📅 見積を複数月に分割</h3>
                <button class="modal-close" onclick="closeSplitEstimateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="splitEstimateId">
                
                <div style="background: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <strong>対象見積:</strong><br>
                    <div id="splitEstimateInfo" style="margin-top: 5px; color: #666;"></div>
                </div>
                
                <div class="form-group">
                    <label>総工数</label>
                    <input type="number" id="splitTotalHours" step="0.1" min="0" readonly style="background: #f0f0f0;">
                    <span style="margin-left: 5px;">時間</span>
                </div>
                
                <div class="form-group">
                    <label>作業期間</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="splitStartMonth" onchange="updateSplitPreview()"></select>
                        <span>〜</span>
                        <select id="splitEndMonth" onchange="updateSplitPreview()"></select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>分割方法</label>
                    <div style="display: flex; gap: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="splitMethodModal" value="equal" checked onchange="updateSplitPreview()" style="width: auto; margin-right: 5px;">
                            <span>均等分割</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="splitMethodModal" value="manual" onchange="updateSplitPreview()" style="width: auto; margin-right: 5px;">
                            <span>手動設定</span>
                        </label>
                    </div>
                </div>
                
                <div id="splitPreview" style="margin-top: 15px;"></div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="executeSplitEstimate()">分割を適用</button>
                    <button class="btn" onclick="closeSplitEstimateModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- その他作業モーダル -->
    <div id="otherWorkModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>その他作業の登録</h3>
                <button class="modal-close" onclick="closeOtherWorkModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- タブ切り替え -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0;">
                    <button id="meetingTab" class="other-work-tab active" onclick="switchOtherWorkTab('meeting')">打ち合わせ</button>
                    <button id="customTab" class="other-work-tab" onclick="switchOtherWorkTab('custom')">任意作業</button>
                </div>
                
                <!-- 打ち合わせタブ -->
                <div id="meetingForm" class="other-work-form">
                    <p style="color: #666; margin-bottom: 15px;">全担当者に同じ工数で登録されます。</p>
                    <div class="form-group">
                        <label>工数 (h)</label>
                        <input type="number" id="meetingHours" step="0.5" min="0" placeholder="例: 2">
                    </div>
                    <button class="btn btn-success" onclick="addMeeting()">全員分追加</button>
                </div>
                
                <!-- 任意作業タブ -->
                <div id="customForm" class="other-work-form" style="display: none;">
                    <div class="form-group">
                        <label>作業名</label>
                        <input type="text" id="otherWorkName" placeholder="例: 環境構築、ドキュメント作成">
                    </div>
                    <div class="form-group">
                        <label>担当</label>
                        <select id="otherWorkMember">
                            <option value="">選択...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>工数 (h)</label>
                        <input type="number" id="otherWorkHours" step="0.5" min="0" placeholder="例: 4">
                    </div>
                    <button class="btn btn-success" onclick="addOtherWork()">追加</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let estimates = [];
        let actuals = [];

        // レポート分析機能の設定
        let reportSettings = {
            accuracyEnabled: true,
            anomalyEnabled: true,
            warningTasksEnabled: true,
            chartEnabled: true,
            trendEnabled: true,
            memberAnalysisEnabled: true,
            insightsEnabled: true
        };
        let autoBackupEnabled = false; // 自動バックアップの設定

        // テーマ設定
        let currentThemeColor = 'purple';
        let currentThemePattern = 'none';
        let currentTabColor = 'same'; // タブの色（'same'=メインカラーと同じ、'default'=青、または色名）

        // レイアウト設定
        let estimateLayout = 'compact'; // 見積一覧のレイアウト（'compact' or 'segmented'）
        let actualLayout = 'compact'; // 実績一覧のレイアウト（'compact' or 'segmented'）
        let reportLayout = 'compact'; // レポートのレイアウト（'compact' or 'segmented'）

        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            loadAutoBackupSetting(); // 自動バックアップ設定を読み込み
            loadThemeSettings(); // テーマ設定を読み込み
            loadReportSettings(); // レポート分析設定を読み込み
            updateMonthOptions();
            updateEstimateMonthOptions(); // 見積一覧の月選択肢を更新
            updateActualMonthOptions();
            updateMemberOptions();
            updateVersionOptions(); // 版数選択肢を更新
            updateQuickTaskList();
            updateWorkMonthOptions(); // 作業月選択肢を更新

            // クイック入力の見積登録フォームを初期化
            initQuickEstimateForm();

            // 各タブのデフォルト月を設定
            setDefaultEstimateMonth(); // 見積タブ
            setDefaultActualMonth(); // 実績タブ
            setDefaultReportMonth(); // レポートタブ

            renderEstimateList();
            renderActualList();
            renderTodayActuals();
            updateReport();

            // モバイルでタブのスワイプ切り替え機能を追加
            initTabSwipe();
        });

        // タブのスワイプ切り替え機能を初期化
        function initTabSwipe() {
            const content = document.querySelector('.content');
            if (!content) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            let touchStartTarget = null;

            const minSwipeDistance = 100; // 最小スワイプ距離（ピクセル）
            const maxVerticalDistance = 50; // 縦方向の最大移動距離（これ以上動くとスワイプと判定しない）

            // スワイプを無効にすべき要素かどうかを判定
            function shouldDisableSwipe(target) {
                if (!target) return false;

                // 入力要素系でのスワイプは無効
                const tagName = target.tagName;
                if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') {
                    return true;
                }

                // 特定のクラスやその親要素でのスワイプは無効
                const element = target.closest('.table-wrapper, .estimate-table-wrapper, .modal.active, .custom-dropdown, #dragHandle, #workMonthAssignmentMode');
                return element !== null;
            }

            content.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
                touchStartTarget = e.target;
            }, { passive: true });

            content.addEventListener('touchend', function(e) {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            function handleSwipe() {
                // スワイプを無効にすべき要素でタッチが開始された場合は処理しない
                if (shouldDisableSwipe(touchStartTarget)) {
                    return;
                }

                const diffX = touchEndX - touchStartX;
                const diffY = Math.abs(touchEndY - touchStartY);
                const absDiffX = Math.abs(diffX);

                // 縦方向の移動が大きい場合はスワイプと判定しない（スクロールと判断）
                if (diffY > maxVerticalDistance) {
                    return;
                }

                // 縦方向の移動が横方向の移動より大きい場合はスワイプと判定しない
                if (diffY > absDiffX) {
                    return;
                }

                // 左スワイプ（次のタブへ）
                if (diffX < -minSwipeDistance) {
                    nextTab();
                }
                // 右スワイプ（前のタブへ）
                else if (diffX > minSwipeDistance) {
                    prevTab();
                }
            }
        }

        function loadAutoBackupSetting() {
            const saved = localStorage.getItem('autoBackupEnabled');
            autoBackupEnabled = saved === 'true';
            document.getElementById('autoBackupEnabled').checked = autoBackupEnabled;
        }

        function saveAutoBackupSetting() {
            autoBackupEnabled = document.getElementById('autoBackupEnabled').checked;
            localStorage.setItem('autoBackupEnabled', autoBackupEnabled);
        }

        function saveQuickInputModeSetting() {
            rememberQuickInputMode = document.getElementById('rememberQuickInputMode').checked;
            localStorage.setItem('rememberQuickInputMode', rememberQuickInputMode);
        }

        function loadReportSettings() {
            const saved = localStorage.getItem('reportSettings');
            if (saved) {
                reportSettings = JSON.parse(saved);
            }
            // UIに反映
            document.getElementById('reportAccuracyEnabled').checked = reportSettings.accuracyEnabled;
            document.getElementById('reportAnomalyEnabled').checked = reportSettings.anomalyEnabled;
            document.getElementById('reportWarningTasksEnabled').checked = reportSettings.warningTasksEnabled;
            document.getElementById('reportChartEnabled').checked = reportSettings.chartEnabled;
            document.getElementById('reportTrendEnabled').checked = reportSettings.trendEnabled;
            document.getElementById('reportMemberAnalysisEnabled').checked = reportSettings.memberAnalysisEnabled;
            document.getElementById('reportInsightsEnabled').checked = reportSettings.insightsEnabled;
        }

        function saveReportSettings() {
            reportSettings.accuracyEnabled = document.getElementById('reportAccuracyEnabled').checked;
            reportSettings.anomalyEnabled = document.getElementById('reportAnomalyEnabled').checked;
            reportSettings.warningTasksEnabled = document.getElementById('reportWarningTasksEnabled').checked;
            reportSettings.chartEnabled = document.getElementById('reportChartEnabled').checked;
            reportSettings.trendEnabled = document.getElementById('reportTrendEnabled').checked;
            reportSettings.memberAnalysisEnabled = document.getElementById('reportMemberAnalysisEnabled').checked;
            reportSettings.insightsEnabled = document.getElementById('reportInsightsEnabled').checked;
            localStorage.setItem('reportSettings', JSON.stringify(reportSettings));
        }

        function saveData(skipAutoBackup = false) {
            const data = {
                estimates: estimates,
                actuals: actuals,
                settings: {
                    memberOrder: document.getElementById('memberOrder').value.trim(),
                    themeColor: currentThemeColor,
                    themePattern: currentThemePattern,
                    themeTabColor: currentTabColor,
                    autoBackup: autoBackupEnabled,
                    estimateLayout: estimateLayout,
                    actualLayout: actualLayout,
                    reportLayout: reportLayout
                }
            };
            
            localStorage.setItem('manhour_estimates', JSON.stringify(estimates));
            localStorage.setItem('manhour_actuals', JSON.stringify(actuals));
            localStorage.setItem('manhour_settings', JSON.stringify(data.settings));

            // 作業月選択肢を更新
            updateWorkMonthOptions();

            // 版数選択肢を更新
            updateVersionOptions();

            // 自動バックアップが有効な場合のみ実行
            if (!skipAutoBackup && autoBackupEnabled) {
                autoBackup();
            }
        }

        function updateMemberOptions() {
            // 見積と実績データから担当者を抽出
            const members = new Set();
            estimates.forEach(e => members.add(e.member));
            actuals.forEach(a => members.add(a.member));
            
            // 表示順が設定されている場合はそれを使用
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                orderList.forEach(name => {
                    if (members.has(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                Array.from(members).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(members).sort();
            }
            
            // 各工程の担当者選択肢を更新（見積管理タブとクイック入力タブ）
            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            processes.forEach(process => {
                // 見積管理タブ（削除済み）の estXX_member は不要だが、念のため残す
                const select = document.getElementById(`est${process}_member`);
                if (select) {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">-</option>';

                    sortedMembers.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member;
                        option.textContent = member;
                        select.appendChild(option);
                    });

                    // 以前の選択を復元
                    if (currentValue && sortedMembers.includes(currentValue)) {
                        select.value = currentValue;
                    }
                }

                // クイック入力の見積登録フォーム
                const quickEstSelect = document.getElementById(`quickEst${process}_member`);
                if (quickEstSelect) {
                    const currentValue = quickEstSelect.value;
                    quickEstSelect.innerHTML = '<option value="">-</option>';

                    sortedMembers.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member;
                        option.textContent = member;
                        quickEstSelect.appendChild(option);
                    });

                    // 以前の選択を復元
                    if (currentValue && sortedMembers.includes(currentValue)) {
                        quickEstSelect.value = currentValue;
                    }
                }
            });
            
            // クイック入力の担当者選択肢も更新
            const quickMemberSelect = document.getElementById('quickMember');
            if (quickMemberSelect) {
                const currentValue = quickMemberSelect.value;
                quickMemberSelect.innerHTML = '';
                
                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    quickMemberSelect.appendChild(option);
                });
                
                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    quickMemberSelect.value = currentValue;
                } else if (sortedMembers.length > 0) {
                    quickMemberSelect.value = sortedMembers[0];
                }
            }
            
            // その他作業の担当者選択肢も更新
            const otherWorkMemberSelect = document.getElementById('otherWorkMember');
            if (otherWorkMemberSelect) {
                const currentValue = otherWorkMemberSelect.value;
                otherWorkMemberSelect.innerHTML = '<option value="">選択...</option>';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    otherWorkMemberSelect.appendChild(option);
                });

                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    otherWorkMemberSelect.value = currentValue;
                }
            }

            // 実績編集モーダルの担当者選択肢を更新
            const editActualMemberSelect = document.getElementById('editActualMember');
            if (editActualMemberSelect) {
                const currentValue = editActualMemberSelect.value;
                editActualMemberSelect.innerHTML = '';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    editActualMemberSelect.appendChild(option);
                });

                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    editActualMemberSelect.value = currentValue;
                }
            }

            // 見積編集モーダルの担当者選択肢を更新
            const editEstimateMemberSelect = document.getElementById('editEstimateMember');
            if (editEstimateMemberSelect) {
                const currentValue = editEstimateMemberSelect.value;
                editEstimateMemberSelect.innerHTML = '';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    editEstimateMemberSelect.appendChild(option);
                });

                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    editEstimateMemberSelect.value = currentValue;
                }
            }
        }

        // 版数選択肢を更新する関数
        function updateVersionOptions() {
            // 見積と実績データから版数を抽出
            const versions = new Set();
            estimates.forEach(e => {
                if (e.version) versions.add(e.version);
            });
            actuals.forEach(a => {
                if (a.version) versions.add(a.version);
            });

            // 版数をソート（降順：新しいものが上）
            const sortedVersions = Array.from(versions).sort().reverse();

            // 各版数セレクトボックスを更新
            const versionSelects = [
                'estVersion',           // 新規見積登録（削除済みだが念のため残す）
                'quickEstVersion',      // クイック入力の見積登録
                'editActualVersion',    // 実績編集/新規モーダル
                'editEstimateVersion'   // 見積編集モーダル
            ];

            versionSelects.forEach(selectId => {
                const select = document.getElementById(selectId);
                if (select) {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">-- 版数を選択 --</option>';

                    // 「新規追加」オプション
                    const newOption = document.createElement('option');
                    newOption.value = '__new__';
                    newOption.textContent = '+ 新しい版数を追加...';
                    select.appendChild(newOption);

                    // 既存の版数
                    sortedVersions.forEach(version => {
                        const option = document.createElement('option');
                        option.value = version;
                        option.textContent = version;
                        select.appendChild(option);
                    });

                    // 以前の選択を復元
                    if (currentValue && currentValue !== '__new__') {
                        select.value = currentValue;
                    }
                }
            });
        }

        // 版数選択時の処理（新規追加対応）
        function handleVersionChange(selectId) {
            const select = document.getElementById(selectId);
            if (select.value === '__new__') {
                const newVersion = prompt('新しい版数を入力してください（例: 第2025.12版）');
                if (newVersion && newVersion.trim()) {
                    // 新しい版数をオプションに追加
                    const option = document.createElement('option');
                    option.value = newVersion.trim();
                    option.textContent = newVersion.trim();
                    select.insertBefore(option, select.options[2]); // 「新規追加」の次に挿入
                    select.value = newVersion.trim();
                } else {
                    select.value = '';
                }
            }
        }

        function loadData() {
            const savedEstimates = localStorage.getItem('manhour_estimates');
            const savedActuals = localStorage.getItem('manhour_actuals');
            const savedSettings = localStorage.getItem('manhour_settings');
            
            if (savedEstimates) estimates = JSON.parse(savedEstimates);
            if (savedActuals) actuals = JSON.parse(savedActuals);
            
            // 設定を読み込み
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.memberOrder) {
                    document.getElementById('memberOrder').value = settings.memberOrder;
                }
                if (settings.themeColor) currentThemeColor = settings.themeColor;
                if (settings.themePattern) currentThemePattern = settings.themePattern;
                if (settings.themeTabColor) currentTabColor = settings.themeTabColor;
                if (settings.autoBackup !== undefined) autoBackupEnabled = settings.autoBackup;
                if (settings.estimateLayout) estimateLayout = settings.estimateLayout;
                if (settings.actualLayout) actualLayout = settings.actualLayout;
                if (settings.reportLayout) reportLayout = settings.reportLayout;
            } else {
                // 旧形式の設定を読み込み（後方互換性）
                const savedMemberOrder = localStorage.getItem('manhour_memberOrder');
                if (savedMemberOrder) {
                    document.getElementById('memberOrder').value = savedMemberOrder;
                }
            }

            // レイアウト設定を適用
            applyLayoutSettings();
        }

        function updateMonthOptions() {
            const select = document.getElementById('reportMonth');
            const select2 = document.getElementById('reportMonth2');
            const months = new Set();

            // 実績データから月を抽出
            actuals.forEach(a => {
                if (a.date) {
                    const month = a.date.substring(0, 7); // YYYY-MM形式
                    months.add(month);
                }
            });

            // 月を昇順でソート（古い月→新しい月）
            const sortedMonths = Array.from(months).sort();

            // 選択肢を生成（両方のセレクトボックス）
            select.innerHTML = '<option value="all">全期間</option>';
            if (select2) select2.innerHTML = '<option value="all">全期間</option>';

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const option = document.createElement('option');
                option.value = month;
                option.textContent = `${year}年${parseInt(monthNum)}月`;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = month;
                    option2.textContent = `${year}年${parseInt(monthNum)}月`;
                    select2.appendChild(option2);
                }
            });

            // セグメントボタン版を生成（レポートセグメントレイアウト用）
            const items = [
                { value: 'all', label: '全期間' },
                ...sortedMonths.slice().map(month => {
                    const [year, monthNum] = month.split('-');
                    return {
                        value: month,
                        label: `${year}/${parseInt(monthNum)}`
                    };
                })
            ];
            const currentValue = select.value || 'all';
            createSegmentButtons(
                'reportMonthButtons2',
                'reportMonth2',
                items,
                currentValue,
                8, // 最大8個までセグメントボタン表示
                handleReportMonthChange
            );
        }

        function updateEstimateMonthOptions() {
            const select = document.getElementById('estimateMonthFilter');
            if (!select) return;

            const months = new Set();

            // 見積データから作業予定月を抽出
            estimates.forEach(e => {
                const est = normalizeEstimate(e);
                est.workMonths.forEach(month => {
                    if (month && month !== 'unassigned') {
                        months.add(month);
                    }
                });
            });

            // 月を降順でソート（最新が上）
            const sortedMonths = Array.from(months).sort().reverse();

            // 選択肢を生成
            select.innerHTML = '<option value="all">全期間</option>';

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const option = document.createElement('option');
                option.value = month;
                option.textContent = `${year}年${parseInt(monthNum)}月`;
                select.appendChild(option);
            });

            // セグメントボタン版を生成
            const items = [
                { value: 'all', label: '全期間' },
                ...sortedMonths.slice().reverse().map(month => {
                    const [year, monthNum] = month.split('-');
                    return {
                        value: month,
                        label: `${year}/${parseInt(monthNum)}`
                    };
                })
            ];
            const currentValue = select.value || 'all';
            createSegmentButtons(
                'estimateMonthButtons2',
                'estimateMonthFilter',
                items,
                currentValue,
                8, // 最大8個までセグメントボタン表示
                handleEstimateMonthChange
            );
        }

        function updateActualMonthOptions() {
            const select = document.getElementById('actualMonthFilter');
            const select2 = document.getElementById('actualMonthFilter2');
            const months = new Set();

            // 実績データから月を抽出
            actuals.forEach(a => {
                if (a.date) {
                    const month = a.date.substring(0, 7); // YYYY-MM形式
                    months.add(month);
                }
            });

            // 月を降順でソート
            const sortedMonths = Array.from(months).sort().reverse();

            // 選択肢を生成（両方のセレクトボックス）
            select.innerHTML = '<option value="all">全期間</option>';
            if (select2) select2.innerHTML = '<option value="all">全期間</option>';

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const option = document.createElement('option');
                option.value = month;
                option.textContent = `${year}年${parseInt(monthNum)}月`;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = month;
                    option2.textContent = `${year}年${parseInt(monthNum)}月`;
                    select2.appendChild(option2);
                }
            });

            // セグメントボタン版を生成（実績一覧セグメントレイアウト用）
            const items = [
                { value: 'all', label: '全期間' },
                ...sortedMonths.slice().reverse().map(month => {
                    const [year, monthNum] = month.split('-');
                    return {
                        value: month,
                        label: `${year}/${parseInt(monthNum)}`
                    };
                })
            ];
            const currentValue = select.value || 'all';
            createSegmentButtons(
                'actualMonthButtons2',
                'actualMonthFilter2',
                items,
                currentValue,
                8, // 最大8個までセグメントボタン表示
                handleActualMonthChange
            );
        }

        // 現在月または最新の登録月を取得する汎用関数
        function getDefaultMonth(selectElement) {
            // 現在月を計算
            const today = new Date();
            const currentMonth = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;

            // selectElementのオプションを確認
            const options = Array.from(selectElement.options);
            const hasCurrentMonth = options.some(opt => opt.value === currentMonth);

            if (hasCurrentMonth) {
                return currentMonth;
            } else if (options.length > 1) {
                // 現在月のデータがない場合は、最新月を返す（昇順なので最後の要素）
                return options[options.length - 1].value;
            }
            return 'all'; // デフォルトは全期間
        }

        function setDefaultActualMonth() {
            const select = document.getElementById('actualMonthFilter');
            if (!select) return;

            const select2 = document.getElementById('actualMonthFilter2');

            const defaultMonth = getDefaultMonth(select);
            select.value = defaultMonth;
            if (select2) select2.value = defaultMonth;
        }

        function setDefaultReportMonth() {
            const select = document.getElementById('reportMonth');
            if (!select) return;

            const select2 = document.getElementById('reportMonth2');

            const defaultMonth = getDefaultMonth(select);
            select.value = defaultMonth;
            if (select2) select2.value = defaultMonth;
        }

        function setDefaultEstimateMonth() {
            const select = document.getElementById('estimateMonthFilter');
            if (!select) return;

            const defaultMonth = getDefaultMonth(select);
            select.value = defaultMonth;
        }

        function autoBackup() {
            const data = {
                estimates: estimates,
                actuals: actuals,
                memberOrder: document.getElementById('memberOrder').value.trim(),
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            // ローカルタイムでファイル名を生成
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}-${month}-${day}_${hour}-${minute}-${second}`;
            
            a.href = url;
            a.download = `工数管理_バックアップ_${timestamp}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // タブの順序を定義
        const TAB_ORDER = ['quick', 'estimate', 'actual', 'report', 'settings'];

        function showTab(tabName) {
            // 全タブからactiveクラスとテーマクラスを削除
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
                // テーマクラスを削除
                const classes = Array.from(t.classList);
                classes.forEach(cls => {
                    if (cls.startsWith('theme-') || cls.startsWith('pattern-') || cls.startsWith('tab-theme-')) {
                        t.classList.remove(cls);
                    }
                });
            });
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            // 対象のタブボタンを見つけてactiveクラスを追加
            const tabButtons = document.querySelectorAll('.tab');
            const tabIndex = TAB_ORDER.indexOf(tabName);
            if (tabIndex !== -1 && tabButtons[tabIndex]) {
                tabButtons[tabIndex].classList.add('active');
            }

            // タブコンテンツを表示
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }

            // アクティブタブにテーマを適用
            updateThemeElements();
        }

        // 次のタブに切り替え
        function nextTab() {
            const currentIndex = TAB_ORDER.findIndex(tab =>
                document.getElementById(tab).classList.contains('active')
            );
            if (currentIndex !== -1 && currentIndex < TAB_ORDER.length - 1) {
                showTab(TAB_ORDER[currentIndex + 1]);
            }
        }

        // 前のタブに切り替え
        function prevTab() {
            const currentIndex = TAB_ORDER.findIndex(tab =>
                document.getElementById(tab).classList.contains('active')
            );
            if (currentIndex > 0) {
                showTab(TAB_ORDER[currentIndex - 1]);
            }
        }

        function addEstimate() {
            const version = document.getElementById('estVersion').value;
            const task = document.getElementById('estTask').value;
            
            if (!version || !task) {
                alert('版数と対応名を入力してください');
                return;
            }

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const monthSplitEnabled = document.getElementById('enableMonthSplit').checked;
            
            if (monthSplitEnabled) {
                // どの工程を分割するかチェック
                const splitProcesses = [];
                processes.forEach(proc => {
                    if (document.getElementById(`split${proc}`).checked) {
                        splitProcesses.push(proc);
                    }
                });
                
                if (splitProcesses.length === 0) {
                    alert('分割する工程を選択してください');
                    return;
                }
                
                // 月分割モード
                addEstimateWithMonthSplit(version, task, processes, splitProcesses);
            } else {
                // 通常モード
                processes.forEach(proc => {
                    const hours = parseFloat(document.getElementById(`est${proc}`).value);
                    const member = document.getElementById(`est${proc}_member`).value;
                    
                    if (hours > 0 && member) {
                        estimates.push({
                            id: Date.now() + Math.random(),
                            version: version,
                            task: task,
                            process: proc,
                            member: member,
                            hours: hours,
                            workMonth: '',
                            workMonths: [],
                            monthlyHours: {},
                            createdAt: new Date().toISOString()
                        });
                    }
                });
            }

            saveData();
            clearEstimateForm();
            updateMemberOptions();
            renderEstimateList();
            updateQuickTaskList();
            updateReport();
            alert('見積を登録しました');
        }

        function addEstimateWithMonthSplit(version, task, processes, splitProcesses) {
            const totalHours = parseFloat(document.getElementById('totalHours').value) || 0;
            const startMonth = document.getElementById('startMonth').value;
            const endMonth = document.getElementById('endMonth').value;
            const method = document.querySelector('input[name="splitMethod"]:checked').value;
            
            if (totalHours <= 0 || !startMonth || !endMonth) {
                alert('総工数と作業期間を入力してください');
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            
            // 月別工数を計算
            const monthlyHours = {};
            
            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                // 手動設定の場合
                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`monthHours_${index}`);
                    const hours = input ? parseFloat(input.value) || 0 : 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });
                
                // 合計チェック
                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計(${total.toFixed(1)}h)が総工数(${totalHours}h)と一致しません`);
                    return;
                }
            }
            
            // 工程ごとに見積を作成
            processes.forEach(proc => {
                const member = document.getElementById(`est${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`est${proc}`).value);
                
                if (!member) return;
                
                // この工程が分割対象かチェック
                if (splitProcesses.includes(proc)) {
                    // 月分割見積を作成
                    estimates.push({
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: totalHours,
                        workMonth: startMonth,
                        workMonths: months,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    });
                } else {
                    // 通常の見積を作成（工数入力があれば）
                    if (hours > 0) {
                        estimates.push({
                            id: Date.now() + Math.random(),
                            version: version,
                            task: task,
                            process: proc,
                            member: member,
                            hours: hours,
                            workMonth: '',
                            workMonths: [],
                            monthlyHours: {},
                            createdAt: new Date().toISOString()
                        });
                    }
                }
            });
        }

        function toggleMonthSplit() {
            const enabled = document.getElementById('enableMonthSplit').checked;
            const panel = document.getElementById('monthSplitPanel');
            
            if (enabled) {
                panel.style.display = 'block';
                
                // 月選択肢を初期化
                const now = new Date();
                const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                generateMonthOptions('startMonth', currentMonth);
                generateMonthOptions('endMonth', currentMonth);
                
                // 通常の工数入力は有効のまま（分割しない工程用）
                
                updateMonthPreview();
            } else {
                panel.style.display = 'none';
            }
        }

        function updateMonthPreview() {
            const totalHours = parseFloat(document.getElementById('totalHours').value) || 0;
            const startMonth = document.getElementById('startMonth').value;
            const endMonth = document.getElementById('endMonth').value;
            const method = document.querySelector('input[name="splitMethod"]:checked').value;
            const preview = document.getElementById('monthPreview');
            
            if (!startMonth || !endMonth || totalHours <= 0) {
                preview.innerHTML = '<p style="color: #999; font-size: 14px;">総工数と作業期間を入力してください</p>';
                return;
            }
            
            if (startMonth > endMonth) {
                preview.innerHTML = '<p style="color: #e74c3c; font-size: 14px;">⚠️ 開始月は終了月より前にしてください</p>';
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            let html = '<div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #2196f3;">';
            html += '<strong style="color: #1976d2;">📋 プレビュー</strong><br>';
            html += '<div style="margin-top: 10px;">';
            
            if (method === 'equal') {
                const hoursPerMonth = (totalHours / months.length).toFixed(1);
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; border-bottom: 1px solid #eee;">`;
                    html += `${y}年${parseInt(m)}月: <strong>${hoursPerMonth}h</strong>`;
                    html += `</div>`;
                });
                html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #2196f3; font-weight: 600;">`;
                html += `合計: ${totalHours}h (${months.length}ヶ月)`;
                html += `</div>`;
            } else {
                // 手動設定UI
                let manualTotal = 0;
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; display: flex; align-items: center; gap: 10px;">`;
                    html += `<label style="flex: 1;">${y}年${parseInt(m)}月:</label>`;
                    html += `<input type="number" id="monthHours_${index}" value="0" step="0.1" min="0" `;
                    html += `onchange="updateManualTotal()" style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"> h`;
                    html += `</div>`;
                });
                html += `<div id="manualTotal" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #2196f3; font-weight: 600;">`;
                html += `合計: 0h / 目標: ${totalHours}h`;
                html += `</div>`;
            }
            
            html += '</div></div>';
            preview.innerHTML = html;
        }

        function updateManualTotal() {
            const totalHours = parseFloat(document.getElementById('totalHours').value) || 0;
            const startMonth = document.getElementById('startMonth').value;
            const endMonth = document.getElementById('endMonth').value;
            
            if (!startMonth || !endMonth) return;
            
            const months = generateMonthRange(startMonth, endMonth);
            let total = 0;
            
            months.forEach((month, index) => {
                const input = document.getElementById(`monthHours_${index}`);
                if (input) {
                    total += parseFloat(input.value) || 0;
                }
            });
            
            const manualTotalDiv = document.getElementById('manualTotal');
            if (manualTotalDiv) {
                const diff = total - totalHours;
                const color = Math.abs(diff) < 0.01 ? '#27ae60' : (diff > 0 ? '#e74c3c' : '#f39c12');
                manualTotalDiv.innerHTML = `合計: <span style="color: ${color};">${total.toFixed(1)}h</span> / 目標: ${totalHours}h`;
                
                if (Math.abs(diff) < 0.01) {
                    manualTotalDiv.innerHTML += ' <span style="color: #27ae60;">✓</span>';
                } else if (diff > 0) {
                    manualTotalDiv.innerHTML += ` <span style="color: #e74c3c;">(+${diff.toFixed(1)}h 超過)</span>`;
                } else {
                    manualTotalDiv.innerHTML += ` <span style="color: #f39c12;">(${diff.toFixed(1)}h 不足)</span>`;
                }
            }
        }

        // 既存見積の月分割機能
        function openSplitEstimateModal(id) {
            const estimate = estimates.find(e => e.id === id);
            if (!estimate) {
                alert('データが見つかりません');
                return;
            }
            
            const est = normalizeEstimate(estimate);
            
            // モーダルに情報を設定
            document.getElementById('splitEstimateId').value = id;
            document.getElementById('splitEstimateInfo').innerHTML = `
                <strong>${est.version}</strong> - ${est.task} [${est.process}] (${est.member})<br>
                現在の工数: ${est.hours.toFixed(1)}h
            `;
            document.getElementById('splitTotalHours').value = est.hours;
            
            // 月選択肢を初期化
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
            
            // 既存の作業月がある場合はそれを使用
            let defaultStart = currentMonth;
            let defaultEnd = currentMonth;
            
            if (est.workMonths.length > 0) {
                defaultStart = est.workMonths[0];
                defaultEnd = est.workMonths[est.workMonths.length - 1];
            }
            
            generateMonthOptions('splitStartMonth', defaultStart);
            generateMonthOptions('splitEndMonth', defaultEnd);
            
            // 分割方法をリセット
            document.querySelector('input[name="splitMethodModal"][value="equal"]').checked = true;
            
            updateSplitPreview();
            
            // モーダルを表示
            document.getElementById('splitEstimateModal').style.display = 'block';
        }

        function closeSplitEstimateModal() {
            document.getElementById('splitEstimateModal').style.display = 'none';
        }

        function updateSplitPreview() {
            const totalHours = parseFloat(document.getElementById('splitTotalHours').value) || 0;
            const startMonth = document.getElementById('splitStartMonth').value;
            const endMonth = document.getElementById('splitEndMonth').value;
            const method = document.querySelector('input[name="splitMethodModal"]:checked').value;
            const preview = document.getElementById('splitPreview');
            
            if (!startMonth || !endMonth || totalHours <= 0) {
                preview.innerHTML = '<p style="color: #999; font-size: 14px;">作業期間を選択してください</p>';
                return;
            }
            
            if (startMonth > endMonth) {
                preview.innerHTML = '<p style="color: #e74c3c; font-size: 14px;">⚠️ 開始月は終了月より前にしてください</p>';
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            let html = '<div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #3498db;">';
            html += '<strong style="color: #2c3e50;">📋 分割プレビュー</strong><br>';
            html += '<div style="margin-top: 10px;">';
            
            if (method === 'equal') {
                const hoursPerMonth = (totalHours / months.length).toFixed(1);
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; border-bottom: 1px solid #eee;">`;
                    html += `${y}年${parseInt(m)}月: <strong>${hoursPerMonth}h</strong>`;
                    html += `</div>`;
                });
                html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #3498db; font-weight: 600;">`;
                html += `合計: ${totalHours}h (${months.length}ヶ月)`;
                html += `</div>`;
            } else {
                // 手動設定UI
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; display: flex; align-items: center; gap: 10px;">`;
                    html += `<label style="flex: 1;">${y}年${parseInt(m)}月:</label>`;
                    html += `<input type="number" id="splitMonthHours_${index}" value="0" step="0.1" min="0" `;
                    html += `onchange="updateSplitManualTotal()" style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"> h`;
                    html += `</div>`;
                });
                html += `<div id="splitManualTotal" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #3498db; font-weight: 600;">`;
                html += `合計: 0h / 目標: ${totalHours}h`;
                html += `</div>`;
            }
            
            html += '</div></div>';
            preview.innerHTML = html;
        }

        function updateSplitManualTotal() {
            const totalHours = parseFloat(document.getElementById('splitTotalHours').value) || 0;
            const startMonth = document.getElementById('splitStartMonth').value;
            const endMonth = document.getElementById('splitEndMonth').value;
            
            if (!startMonth || !endMonth) return;
            
            const months = generateMonthRange(startMonth, endMonth);
            let total = 0;
            
            months.forEach((month, index) => {
                const input = document.getElementById(`splitMonthHours_${index}`);
                if (input) {
                    total += parseFloat(input.value) || 0;
                }
            });
            
            const manualTotalDiv = document.getElementById('splitManualTotal');
            if (manualTotalDiv) {
                const diff = total - totalHours;
                const color = Math.abs(diff) < 0.01 ? '#27ae60' : (diff > 0 ? '#e74c3c' : '#f39c12');
                manualTotalDiv.innerHTML = `合計: <span style="color: ${color};">${total.toFixed(1)}h</span> / 目標: ${totalHours}h`;
                
                if (Math.abs(diff) < 0.01) {
                    manualTotalDiv.innerHTML += ' <span style="color: #27ae60;">✓</span>';
                } else if (diff > 0) {
                    manualTotalDiv.innerHTML += ` <span style="color: #e74c3c;">(+${diff.toFixed(1)}h 超過)</span>`;
                } else {
                    manualTotalDiv.innerHTML += ` <span style="color: #f39c12;">(${diff.toFixed(1)}h 不足)</span>`;
                }
            }
        }

        function executeSplitEstimate() {
            const id = parseFloat(document.getElementById('splitEstimateId').value);
            const totalHours = parseFloat(document.getElementById('splitTotalHours').value) || 0;
            const startMonth = document.getElementById('splitStartMonth').value;
            const endMonth = document.getElementById('splitEndMonth').value;
            const method = document.querySelector('input[name="splitMethodModal"]:checked').value;
            
            if (!startMonth || !endMonth || totalHours <= 0) {
                alert('作業期間を正しく設定してください');
                return;
            }
            
            if (startMonth > endMonth) {
                alert('開始月は終了月より前にしてください');
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            const monthlyHours = {};
            
            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                // 手動設定の場合
                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`splitMonthHours_${index}`);
                    const hours = input ? parseFloat(input.value) || 0 : 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });
                
                // 合計チェック
                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計(${total.toFixed(1)}h)が総工数(${totalHours}h)と一致しません`);
                    return;
                }
            }
            
            // 見積を更新
            const estimateIndex = estimates.findIndex(e => e.id === id);
            if (estimateIndex !== -1) {
                estimates[estimateIndex] = {
                    ...estimates[estimateIndex],
                    workMonth: startMonth,
                    workMonths: months,
                    monthlyHours: monthlyHours
                };
                
                saveData();
                closeSplitEstimateModal();
                renderEstimateList();
                updateReport();
                
                alert('見積を月別に分割しました');
            } else {
                alert('データの更新に失敗しました');
            }
        }

        function clearEstimateForm() {
            document.getElementById('estVersion').value = '';
            document.getElementById('estTask').value = '';
            ['UI', 'PG', 'PT', 'IT', 'ST'].forEach(proc => {
                document.getElementById(`est${proc}`).value = '';
                document.getElementById(`est${proc}_member`).value = '';
                // 工程チェックボックスもクリア
                const checkbox = document.getElementById(`split${proc}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            // 月分割アシスタントをクリア
            document.getElementById('enableMonthSplit').checked = false;
            toggleMonthSplit();
        }

        // クイック入力用の変数
        let allQuickTasks = [];
        let selectedQuickTask = null;
        let selectedMemberFilter = null; // 担当者フィルタ
        let quickInputMode = 'actual'; // 'actual' or 'estimate'
        let rememberQuickInputMode = false; // 前回モードを記憶するかどうか

        // 作業月割り当て用の変数
        let workMonthSelectionMode = false;
        let selectedEstimateIds = new Set(); // 選択された見積IDのセット

        // 月分割モード用の変数
        let monthSplitEnabled = false;

        // 見積データの正規化（旧形式→新形式）
        function normalizeEstimate(e) {
            // 新形式がすでにある場合
            if (e.workMonths && e.monthlyHours) {
                return e;
            }
            
            // 旧形式（workMonthのみ）を新形式に変換
            if (e.workMonth && !e.workMonths) {
                return {
                    ...e,
                    workMonths: [e.workMonth],
                    monthlyHours: { [e.workMonth]: e.hours }
                };
            }
            
            // workMonthもworkMonthsもない場合（未設定）
            if (!e.workMonth && !e.workMonths) {
                return {
                    ...e,
                    workMonths: [],
                    monthlyHours: {}
                };
            }
            
            return e;
        }

        // 月の範囲を生成（YYYY-MM形式）
        function generateMonthRange(startMonth, endMonth) {
            const months = [];
            let current = startMonth;
            
            while (current <= endMonth) {
                months.push(current);
                const [y, m] = current.split('-').map(Number);
                const nextDate = new Date(y, m, 1); // 次の月の1日
                const nextYear = nextDate.getFullYear();
                const nextMonth = nextDate.getMonth() + 1;
                current = `${nextYear}-${String(nextMonth).padStart(2, '0')}`;
            }
            
            return months;
        }

        // 月選択肢を生成
        function generateMonthOptions(selectId, selectedValue = '') {
            const select = document.getElementById(selectId);
            if (!select) return;
            
            select.innerHTML = '';
            
            // 過去1年から未来2年まで
            const now = new Date();
            const startDate = new Date(now.getFullYear() - 1, 0, 1);
            const endDate = new Date(now.getFullYear() + 2, 11, 31);
            
            const months = [];
            let current = new Date(startDate);
            
            while (current <= endDate) {
                const year = current.getFullYear();
                const month = current.getMonth() + 1;
                const value = `${year}-${String(month).padStart(2, '0')}`;
                months.push({ value, label: `${year}年${month}月` });
                current.setMonth(current.getMonth() + 1);
            }
            
            months.forEach(m => {
                const option = document.createElement('option');
                option.value = m.value;
                option.textContent = m.label;
                if (m.value === selectedValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        function updateQuickTaskList() {
            // 見積データから一意のタスクを抽出（担当者情報も含む）
            const taskMap = new Map();
            estimates.forEach(e => {
                const key = `${e.version}|${e.task}|${e.process}|${e.member}`;
                if (!taskMap.has(key)) {
                    taskMap.set(key, {
                        version: e.version,
                        task: e.task,
                        process: e.process,
                        member: e.member,
                        display: `${e.version} - ${e.task} [${e.process}] (${e.member})`
                    });
                }
            });
            
            allQuickTasks = Array.from(taskMap.values());
            
            // 担当者セレクトボックスを更新
            updateQuickMemberSelect();
        }

        function updateQuickMemberSelect() {
            const select = document.getElementById('quickMemberSelect');
            const members = new Set();
            
            // 見積データから担当者を抽出
            estimates.forEach(e => members.add(e.member));
            
            // 表示順が設定されている場合はそれを使用
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = orderList.filter(m => members.has(m));
                const unorderedMembers = Array.from(members).filter(m => !orderedMembers.includes(m)).sort();
                sortedMembers = [...orderedMembers, ...unorderedMembers];
            } else {
                sortedMembers = Array.from(members).sort();
            }
            
            // オプションを生成
            const currentValue = select.value;
            select.innerHTML = '<option value="">（自動）</option>';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                select.appendChild(option);
            });
            
            // 前回選択していた値を復元
            if (currentValue && sortedMembers.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        function handleMemberChange() {
            const selectedMember = document.getElementById('quickMemberSelect').value;
            selectedMemberFilter = selectedMember || null;
            
            // 対応が既に選択されている場合
            if (selectedQuickTask) {
                // 何もしない（担当者変更として扱う）
                return;
            }
            
            // 対応が未選択の場合、ドロップダウンを更新
            const searchInput = document.getElementById('quickTaskSearch');
            if (searchInput.value) {
                filterQuickTaskList();
            }
        }

        function showQuickTaskDropdown() {
            filterQuickTaskList();
        }

        function hideQuickTaskDropdown() {
            document.getElementById('quickTaskDropdown').style.display = 'none';
        }

        function clearQuickTaskSelection() {
            document.getElementById('quickTaskSearch').value = '';
            document.getElementById('quickTaskClearBtn').style.display = 'none';
            selectedQuickTask = null;
            // 担当者もリセット
            document.getElementById('quickMemberSelect').value = '';
            selectedMemberFilter = null;
            // ドロップダウンを非表示
            hideQuickTaskDropdown();
        }

        function filterQuickTaskList() {
            const searchText = document.getElementById('quickTaskSearch').value.toLowerCase();
            const dropdown = document.getElementById('quickTaskDropdown');
            
            // 担当者フィルタが設定されている場合は絞り込む
            let filtered = allQuickTasks;
            if (selectedMemberFilter) {
                filtered = filtered.filter(taskInfo => taskInfo.member === selectedMemberFilter);
            }
            
            // 検索テキストで絞り込む
            if (searchText) {
                filtered = filtered.filter(taskInfo => 
                    taskInfo.display.toLowerCase().includes(searchText)
                );
            }
            
            if (filtered.length === 0) {
                const msg = selectedMemberFilter 
                    ? `${selectedMemberFilter}さんの対応が見つかりません` 
                    : '該当する対応が見つかりません';
                dropdown.innerHTML = `<div class="custom-dropdown-empty">${msg}</div>`;
            } else {
                dropdown.innerHTML = filtered.map(taskInfo => {
                    const value = `${taskInfo.version}|${taskInfo.task}|${taskInfo.process}|${taskInfo.member}`;
                    return `<div class="custom-dropdown-item" onmousedown="selectQuickTask('${value.replace(/'/g, "\\'")}', '${taskInfo.display.replace(/'/g, "\\'")}')">${taskInfo.display}</div>`;
                }).join('');
            }
            
            dropdown.style.display = 'block';
        }

        function selectQuickTask(value, display) {
            selectedQuickTask = value;
            const [version, task, process, member] = value.split('|');
            
            // 表示を更新
            document.getElementById('quickTaskSearch').value = `${version} - ${task} [${process}]`;
            
            // ×ボタンを表示
            document.getElementById('quickTaskClearBtn').style.display = 'block';
            
            // 担当者セレクトを更新
            const memberSelect = document.getElementById('quickMemberSelect');
            
            // 担当者フィルタが未設定の場合、見積の担当者を自動設定
            if (!selectedMemberFilter) {
                memberSelect.value = member;
            }
            // 担当者フィルタが設定されていて、見積の担当者と異なる場合は変更として扱う
            // （何もしない。ユーザーが選んだ担当者を維持）
            
            document.getElementById('quickTaskDropdown').style.display = 'none';
        }

        // 外部クリックでドロップダウンを閉じる
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('quickTaskDropdown');
            const searchInput = document.getElementById('quickTaskSearch');
            
            if (dropdown && searchInput) {
                // クリックされた要素がドロップダウンまたは検索入力欄でない場合
                if (!dropdown.contains(event.target) && event.target !== searchInput) {
                    hideQuickTaskDropdown();
                }
            }
        });

        function quickAddActual() {
            const hours = parseFloat(document.getElementById('quickHours').value);
            const memberOverride = document.getElementById('quickMemberSelect').value;
            
            if (!selectedQuickTask || !hours) {
                alert('対応と実績工数を入力してください');
                return;
            }

            const [version, task, process, originalMember] = selectedQuickTask.split('|');
            
            // 担当者の決定ロジック:
            // 1. ユーザーが明示的に選択した担当者があればそれを使用
            // 2. なければ見積の担当者を使用
            const finalMember = memberOverride || originalMember;

            actuals.push({
                id: Date.now(),
                date: new Date().toISOString().split('T')[0],
                version: version,
                task: task,
                process: process,
                member: finalMember,
                hours: hours,
                createdAt: new Date().toISOString()
            });

            saveData();
            
            // 入力欄をクリア
            document.getElementById('quickTaskSearch').value = '';
            document.getElementById('quickHours').value = '';
            document.getElementById('quickTaskClearBtn').style.display = 'none';
            // 担当者選択はリセット（次の入力に備える）
            document.getElementById('quickMemberSelect').value = '';
            selectedQuickTask = null;
            selectedMemberFilter = null;
            
            updateMonthOptions();
            updateActualMonthOptions();
            updateMemberOptions();
            renderTodayActuals();
            renderActualList();
            updateReport();
            alert('実績を追加しました');
        }

        function renderTodayActuals() {
            const today = new Date().toISOString().split('T')[0];
            const todayData = actuals.filter(a => a.date === today);
            
            const container = document.getElementById('todayActuals');
            
            if (todayData.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">まだ実績が入力されていません</p>';
                return;
            }

            let html = '<div class="table-wrapper"><table><tr><th>時刻</th><th>版数</th><th>対応名</th><th>工程</th><th>担当</th><th>工数</th><th>操作</th></tr>';
            
            todayData.forEach(a => {
                const time = new Date(a.createdAt).toLocaleTimeString('ja-JP');
                html += `
                    <tr>
                        <td>${time}</td>
                        <td>${a.version}</td>
                        <td>${a.task}</td>
                        <td><span class="badge badge-${a.process.toLowerCase()}">${a.process}</span></td>
                        <td>${a.member}</td>
                        <td>${a.hours}h</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editActual(${a.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-danger btn-small" onclick="deleteActual(${a.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        // クイック入力モード切り替え
        function switchQuickInputMode(mode) {
            quickInputMode = mode;

            const actualForm = document.getElementById('quickActualForm');
            const estimateForm = document.getElementById('quickEstimateForm');
            const modeTitle = document.getElementById('quickModeTitle');
            const bottomTitle = document.getElementById('quickBottomTitle');
            const actualBtn = document.getElementById('quickActualModeBtn');
            const estimateBtn = document.getElementById('quickEstimateModeBtn');

            if (mode === 'actual') {
                actualForm.style.display = 'block';
                estimateForm.style.display = 'none';
                modeTitle.textContent = '今日の実績を入力';
                bottomTitle.textContent = '今日の入力済み実績';
                bottomTitle.style.display = 'block';
                document.getElementById('todayActuals').style.display = 'block';

                actualBtn.style.background = 'rgba(255,255,255,0.9)';
                actualBtn.style.color = 'rgba(0,0,0,0.85)';
                estimateBtn.style.background = 'transparent';
                estimateBtn.style.color = 'rgba(255,255,255,0.85)';
            } else {
                actualForm.style.display = 'none';
                estimateForm.style.display = 'block';
                modeTitle.textContent = '新規見積登録';
                bottomTitle.style.display = 'none';
                document.getElementById('todayActuals').style.display = 'none';

                actualBtn.style.background = 'transparent';
                actualBtn.style.color = 'rgba(255,255,255,0.85)';
                estimateBtn.style.background = 'rgba(255,255,255,0.9)';
                estimateBtn.style.color = 'rgba(0,0,0,0.85)';
            }

            // 設定で記憶が有効な場合、localStorageに保存
            if (rememberQuickInputMode) {
                localStorage.setItem('quickInputMode', mode);
            }
        }

        // 作業月UIの更新（単一月/複数月の切り替え）
        function updateQuickEstWorkMonthUI() {
            const startMonth = document.getElementById('quickEstStartMonth').value;
            const endMonthSelect = document.getElementById('quickEstEndMonth');
            const separator = document.getElementById('quickEstMonthSeparator');

            if (!startMonth) return;

            // 終了月セレクトと区切り文字の表示を切り替え
            if (endMonthSelect.options.length === 0 || endMonthSelect.value === '' || startMonth === endMonthSelect.value) {
                // 単一月モード
                separator.style.display = 'none';
                endMonthSelect.style.display = 'none';
                updateQuickEstimateTableHeader(false);
            } else {
                // 複数月モード
                separator.style.display = 'inline';
                endMonthSelect.style.display = 'inline-block';
                updateQuickEstimateTableHeader(true);
                updateDefaultProcessMonths(startMonth, endMonthSelect.value);
            }
        }

        // 工程表のヘッダーと作業月列を更新
        function updateQuickEstimateTableHeader(showWorkMonthColumn) {
            const table = document.getElementById('quickEstimateTable');
            const headerRow = table.querySelector('thead tr');
            const bodyRows = table.querySelectorAll('tbody tr');

            if (showWorkMonthColumn) {
                // 作業月列を追加
                if (headerRow.children.length === 3) {
                    const th = document.createElement('th');
                    th.style.width = '150px';
                    th.style.padding = '8px';
                    th.textContent = '作業月';
                    headerRow.appendChild(th);
                }

                bodyRows.forEach((row, index) => {
                    if (row.children.length === 3) {
                        const td = document.createElement('td');
                        const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
                        const processName = processes[index];
                        td.innerHTML = `
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <select id="quickEst${processName}_startMonth" style="margin: 0; flex: 1;"></select>
                                <span>〜</span>
                                <select id="quickEst${processName}_endMonth" style="margin: 0; flex: 1;"></select>
                            </div>
                        `;
                        row.appendChild(td);
                    }
                });
            } else {
                // 作業月列を削除
                if (headerRow.children.length === 4) {
                    headerRow.removeChild(headerRow.lastChild);
                }

                bodyRows.forEach(row => {
                    if (row.children.length === 4) {
                        row.removeChild(row.lastChild);
                    }
                });
            }
        }

        // ウォーターフォール方式でデフォルトの作業月を計算
        function calculateDefaultWorkMonths(startMonth, endMonth) {
            if (!startMonth || !endMonth) return [];

            const months = generateMonthRange(startMonth, endMonth);
            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const result = [];

            processes.forEach((process, index) => {
                const monthIndex = Math.floor(index * months.length / processes.length);
                const assignedMonth = months[monthIndex];
                result.push({
                    process: process,
                    startMonth: assignedMonth,
                    endMonth: assignedMonth
                });
            });

            return result;
        }

        // 各工程のデフォルト作業月を設定
        function updateDefaultProcessMonths(startMonth, endMonth) {
            const defaults = calculateDefaultWorkMonths(startMonth, endMonth);
            const months = generateMonthRange(startMonth, endMonth);

            defaults.forEach(item => {
                const startSelect = document.getElementById(`quickEst${item.process}_startMonth`);
                const endSelect = document.getElementById(`quickEst${item.process}_endMonth`);

                if (startSelect && endSelect) {
                    // セレクトボックスに選択肢を設定
                    startSelect.innerHTML = '';
                    endSelect.innerHTML = '';
                    months.forEach(month => {
                        startSelect.innerHTML += `<option value="${month}">${month.substring(0, 4)}年${parseInt(month.substring(5))}月</option>`;
                        endSelect.innerHTML += `<option value="${month}">${month.substring(0, 4)}年${parseInt(month.substring(5))}月</option>`;
                    });

                    // デフォルト値を設定
                    startSelect.value = item.startMonth;
                    endSelect.value = item.endMonth;
                }
            });
        }

        // 見積登録関数（クイック入力タブ用）
        function addQuickEstimate() {
            const version = document.getElementById('quickEstVersion').value;
            const task = document.getElementById('quickEstTask').value.trim();
            const startMonth = document.getElementById('quickEstStartMonth').value;
            const endMonth = document.getElementById('quickEstEndMonth');

            if (!version || version === '新規追加') {
                alert('版数を選択してください');
                return;
            }

            if (!task) {
                alert('対応名を入力してください');
                return;
            }

            if (!startMonth) {
                alert('作業月を選択してください');
                return;
            }

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const monthSplitEnabled = document.getElementById('quickEnableMonthSplit').checked;

            if (monthSplitEnabled) {
                // 月分割モード
                const splitProcesses = [];
                processes.forEach(proc => {
                    if (document.getElementById(`quickSplit${proc}`).checked) {
                        splitProcesses.push(proc);
                    }
                });

                if (splitProcesses.length === 0) {
                    alert('分割する工程を少なくとも一つ選択してください');
                    return;
                }

                addQuickEstimateWithMonthSplit(version, task, processes, splitProcesses);
            } else {
                // 通常モード
                addQuickEstimateNormal(version, task, processes, startMonth, endMonth);
            }
        }

        // 通常モードで見積登録
        function addQuickEstimateNormal(version, task, processes, startMonth, endMonthSelect) {
            const isSingleMonth = !endMonthSelect || endMonthSelect.style.display === 'none' || !endMonthSelect.value || startMonth === endMonthSelect.value;

            processes.forEach(proc => {
                const member = document.getElementById(`quickEst${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`quickEst${proc}`).value) || 0;

                if (hours > 0) {
                    let workMonths, monthlyHours, workMonth;

                    if (isSingleMonth) {
                        // 単一月モード
                        workMonth = startMonth;
                        workMonths = [startMonth];
                        monthlyHours = { [startMonth]: hours };
                    } else {
                        // 複数月モード: 各工程の作業月を取得
                        const procStartMonth = document.getElementById(`quickEst${proc}_startMonth`).value;
                        const procEndMonth = document.getElementById(`quickEst${proc}_endMonth`).value;

                        if (procStartMonth === procEndMonth) {
                            workMonth = procStartMonth;
                            workMonths = [procStartMonth];
                            monthlyHours = { [procStartMonth]: hours };
                        } else {
                            const months = generateMonthRange(procStartMonth, procEndMonth);
                            workMonth = procStartMonth;
                            workMonths = months;
                            const hoursPerMonth = hours / months.length;
                            monthlyHours = {};
                            months.forEach(m => {
                                monthlyHours[m] = hoursPerMonth;
                            });
                        }
                    }

                    estimates.push({
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: hours,
                        workMonth: workMonth,
                        workMonths: workMonths,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    });
                }
            });

            saveData();
            clearQuickEstimateForm();
            updateMonthOptions();
            updateQuickTaskList();
            updateMemberOptions();
            renderEstimateList();
            updateReport();
            alert('見積を登録しました');
        }

        // 月分割モードで見積登録
        function addQuickEstimateWithMonthSplit(version, task, processes, splitProcesses) {
            const totalHours = parseFloat(document.getElementById('quickTotalHours').value) || 0;
            const startMonth = document.getElementById('quickStartMonth').value;
            const endMonth = document.getElementById('quickEndMonth').value;
            const method = document.querySelector('input[name="quickSplitMethod"]:checked').value;

            if (totalHours === 0) {
                alert('総工数を入力してください');
                return;
            }

            if (!startMonth || !endMonth) {
                alert('作業期間を選択してください');
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);
            const monthlyHours = {};

            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`quickMonthHours_${index}`);
                    const hours = input ? parseFloat(input.value) || 0 : 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });

                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計（${total}h）が総工数（${totalHours}h）と一致しません`);
                    return;
                }
            }

            processes.forEach(proc => {
                const member = document.getElementById(`quickEst${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`quickEst${proc}`).value) || 0;

                if (hours > 0) {
                    const est = {
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: totalHours,
                        workMonth: startMonth,
                        workMonths: months,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    };

                    if (splitProcesses.includes(proc)) {
                        estimates.push(est);
                    } else {
                        estimates.push({
                            id: Date.now() + Math.random(),
                            version: version,
                            task: task,
                            process: proc,
                            member: member,
                            hours: hours,
                            workMonth: '',
                            workMonths: [],
                            monthlyHours: {},
                            createdAt: new Date().toISOString()
                        });
                    }
                }
            });

            saveData();
            clearQuickEstimateForm();
            updateMonthOptions();
            updateQuickTaskList();
            updateMemberOptions();
            renderEstimateList();
            updateReport();
            alert('見積を登録しました（月分割）');
        }

        // 見積フォームのクリア
        function clearQuickEstimateForm() {
            document.getElementById('quickEstTask').value = '';

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            processes.forEach(proc => {
                document.getElementById(`quickEst${proc}`).value = '';
            });

            // 月分割アシスタントをクリア
            document.getElementById('quickEnableMonthSplit').checked = false;
            toggleQuickMonthSplit();
        }

        // 月分割アシスタントの表示切り替え
        function toggleQuickMonthSplit() {
            const enabled = document.getElementById('quickEnableMonthSplit').checked;
            const panel = document.getElementById('quickMonthSplitPanel');

            if (enabled) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // 月分割プレビューの更新
        function updateQuickMonthPreview() {
            const totalHours = parseFloat(document.getElementById('quickTotalHours').value) || 0;
            const startMonth = document.getElementById('quickStartMonth').value;
            const endMonth = document.getElementById('quickEndMonth').value;
            const method = document.querySelector('input[name="quickSplitMethod"]:checked').value;
            const preview = document.getElementById('quickMonthPreview');

            if (!startMonth || !endMonth || totalHours === 0) {
                preview.innerHTML = '';
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);

            let html = '<div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px;">';
            html += '<div style="font-weight: 600; margin-bottom: 8px; color: rgba(255,255,255,0.9);">月別工数設定</div>';

            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="margin-bottom: 4px; color: rgba(255,255,255,0.8);">${y}年${parseInt(m)}月: ${hoursPerMonth.toFixed(1)}h</div>`;
                });
            } else {
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    html += `<div style="margin-bottom: 6px;">
                        <label style="display: inline-block; width: 100px; color: rgba(255,255,255,0.9);">${y}年${parseInt(m)}月:</label>
                        <input type="number" id="quickMonthHours_${index}" step="0.1" min="0" placeholder="h" style="width: 80px; margin: 0;" oninput="updateQuickMonthPreview()">
                        <span style="margin-left: 5px;">h</span>
                    </div>`;
                });

                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`quickMonthHours_${index}`);
                    if (input) total += parseFloat(input.value) || 0;
                });

                html += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.9);">
                    合計: ${total.toFixed(1)}h / 目標: ${totalHours}h
                    ${Math.abs(total - totalHours) > 0.01 ? '<span style="color: #ff6b6b; margin-left: 10px;">⚠ 合計が一致していません</span>' : '<span style="color: #51cf66; margin-left: 10px;">✓ OK</span>'}
                </div>`;
            }

            html += '</div>';
            preview.innerHTML = html;
        }

        // クイック入力の見積登録フォーム初期化
        function initQuickEstimateForm() {
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

            // 作業月セレクトボックスの初期化
            generateMonthOptions('quickEstStartMonth', currentMonth);
            generateMonthOptions('quickEstEndMonth', currentMonth);
            generateMonthOptions('quickStartMonth', currentMonth);
            generateMonthOptions('quickEndMonth', currentMonth);

            // 終了月セレクトを最初は非表示に
            document.getElementById('quickEstEndMonth').style.display = 'none';
            document.getElementById('quickEstMonthSeparator').style.display = 'none';

            // 前回モードを記憶する設定の読み込み
            const savedRememberMode = localStorage.getItem('rememberQuickInputMode');
            rememberQuickInputMode = savedRememberMode === 'true';

            // チェックボックスのUIに反映
            const rememberCheckbox = document.getElementById('rememberQuickInputMode');
            if (rememberCheckbox) {
                rememberCheckbox.checked = rememberQuickInputMode;
            }

            // 前回モードの復元
            if (rememberQuickInputMode) {
                const savedMode = localStorage.getItem('quickInputMode');
                if (savedMode && (savedMode === 'actual' || savedMode === 'estimate')) {
                    quickInputMode = savedMode;
                    switchQuickInputMode(savedMode);
                }
            }
        }

        function renderEstimateList() {
            const container = document.getElementById('estimateList');
            if (!container) return;

            const viewTypeElement = document.getElementById('estimateViewType');
            const monthFilterElement = document.getElementById('estimateMonthFilter');

            if (!viewTypeElement || !monthFilterElement) return;

            const viewType = viewTypeElement.value;
            const monthFilter = monthFilterElement.value;

            if (estimates.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">見積データがありません</p>';
                // 合計を0にリセット
                const totalHoursElement = document.getElementById('estimateTotalHours');
                const totalManpowerElement = document.getElementById('estimateTotalManpower');
                if (totalHoursElement) totalHoursElement.textContent = '0h';
                if (totalManpowerElement) totalManpowerElement.textContent = '0人日 / 0人月';
                // 担当者別合計を非表示
                const memberSummaryContainer = document.getElementById('estimateMemberSummary');
                if (memberSummaryContainer) memberSummaryContainer.style.display = 'none';
                return;
            }

            // 月フィルタを適用
            let filteredEstimates = estimates;
            if (monthFilter !== 'all') {
                filteredEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.includes(monthFilter);
                });
            }

            // 合計工数を計算
            let totalHours = 0;
            if (monthFilter === 'all') {
                totalHours = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
            } else {
                filteredEstimates.forEach(e => {
                    const est = normalizeEstimate(e);
                    if (est.monthlyHours[monthFilter]) {
                        totalHours += est.monthlyHours[monthFilter];
                    }
                });
            }

            // 人日・人月を計算
            let workingDaysPerMonth = 20; // デフォルト
            if (monthFilter !== 'all') {
                const [year, month] = monthFilter.split('-');
                workingDaysPerMonth = getWorkingDays(parseInt(year), parseInt(month));
            }
            const totalManDays = (totalHours / 8).toFixed(1);
            const totalManMonths = (totalHours / 8 / workingDaysPerMonth).toFixed(2);

            // 合計を表示
            const totalHoursElement = document.getElementById('estimateTotalHours');
            const totalManpowerElement = document.getElementById('estimateTotalManpower');
            if (totalHoursElement) totalHoursElement.textContent = totalHours.toFixed(1) + 'h';
            if (totalManpowerElement) totalManpowerElement.textContent = `${totalManDays}人日 / ${totalManMonths}人月`;

            // 合計カードにテーマカラーのグラデーションを適用
            const totalCard = document.getElementById('estimateTotalCard');
            if (totalCard) {
                const gradients = {
                    'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                    'teal': 'linear-gradient(135deg, #0f766e 0%, #0d9488 100%)',
                    'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                    'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #075985 100%)',
                    'sky': 'linear-gradient(135deg, #0369a1 0%, #0284c7 100%)',
                    'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                    'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                    'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                    'green': 'linear-gradient(135deg, #047857 0%, #059669 100%)',
                    'emerald': 'linear-gradient(135deg, #059669 0%, #10b981 100%)'
                };
                totalCard.style.background = gradients[currentThemeColor] || gradients['purple'];
            }

            // 担当者別の合計を集計
            const memberSummary = {};
            filteredEstimates.forEach(e => {
                const est = normalizeEstimate(e);
                const member = est.member || '未設定';

                if (!memberSummary[member]) {
                    memberSummary[member] = 0;
                }

                // 月フィルタが適用されている場合は分割後の工数を使用
                if (monthFilter === 'all') {
                    memberSummary[member] += est.hours;
                } else if (est.monthlyHours[monthFilter]) {
                    memberSummary[member] += est.monthlyHours[monthFilter];
                }
            });

            // 担当者別合計を表示
            const memberSummaryContainer = document.getElementById('estimateMemberSummary');
            const memberSummaryContent = document.getElementById('estimateMemberSummaryContent');
            if (memberSummaryContainer && memberSummaryContent) {
                // memberOrderの順序に従ってソート
                const memberSet = new Set(Object.keys(memberSummary));
                let sortedMembers = [];
                const memberOrderElement = document.getElementById('memberOrder');
                const memberOrderInput = memberOrderElement ? memberOrderElement.value.trim() : '';

                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = orderList.filter(m => memberSet.has(m));
                    const unorderedMembers = Array.from(memberSet).filter(m => !orderedMembers.includes(m)).sort();
                    sortedMembers = [...orderedMembers, ...unorderedMembers];
                } else {
                    sortedMembers = Array.from(memberSet).sort();
                }

                if (sortedMembers.length > 0) {
                    memberSummaryContainer.style.display = 'block';
                    // テーマカラーを取得
                    const themeColors = {
                        'purple': '#667eea',
                        'deep-blue': '#1e3c72',
                        'teal': '#0f766e',
                        'cyan': '#0891b2',
                        'ocean': '#0c4a6e',
                        'sky': '#0369a1',
                        'indigo': '#4338ca',
                        'navy': '#1e40af',
                        'slate': '#334155',
                        'green': '#047857',
                        'emerald': '#059669'
                    };
                    const borderColor = themeColors[currentThemeColor] || '#667eea';

                    let memberHtml = '';
                    sortedMembers.forEach(member => {
                        const hours = memberSummary[member];
                        const days = (hours / 8).toFixed(1);
                        const months = (hours / 8 / workingDaysPerMonth).toFixed(2);
                        memberHtml += `
                            <div style="background: white; padding: 10px 15px; border-radius: 6px; border-left: 4px solid ${borderColor}; min-width: 150px;">
                                <div style="font-size: 13px; color: #666; margin-bottom: 3px;">${member}</div>
                                <div style="font-size: 18px; font-weight: 700; color: #333;">${hours.toFixed(1)}h</div>
                                <div style="font-size: 11px; color: #999;">${days}人日 / ${months}人月</div>
                            </div>
                        `;
                    });
                    memberSummaryContent.innerHTML = memberHtml;
                } else {
                    memberSummaryContainer.style.display = 'none';
                }
            }

            if (viewType === 'grouped') {
                renderEstimateGrouped();
            } else if (viewType === 'matrix') {
                renderEstimateMatrix();
            } else {
                renderEstimateDetailList();
            }
        }

        // 月の実働日数を計算（土日祝日を除く）
        function getWorkingDays(year, month) {
            const lastDay = new Date(year, month, 0).getDate();
            let workingDays = 0;
            
            for (let day = 1; day <= lastDay; day++) {
                const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const date = new Date(year, month - 1, day);
                const dayOfWeek = date.getDay();
                const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6); // 日曜or土曜
                const holiday = getHoliday(dateStr);
                
                if (!isWeekend && !holiday) {
                    workingDays++;
                }
            }
            
            return workingDays;
        }
        
        // 現在の年月の実働日数を取得（デフォルト値として使用）
        function getCurrentMonthWorkingDays() {
            const now = new Date();
            return getWorkingDays(now.getFullYear(), now.getMonth() + 1);
        }

        // 実績または見積が「その他付随作業」かどうかを判定
        function isOtherWork(item) {
            const hasVersion = item.version && item.version.trim() !== '';
            const hasTask = item.task && item.task.trim() !== '';
            return !hasVersion || !hasTask;
        }

        // 数値を整数表示（小数点以下が0の場合）または小数表示
        function formatNumber(num, decimals = 1) {
            const rounded = parseFloat(num.toFixed(decimals));
            return rounded % 1 === 0 ? rounded.toFixed(0) : rounded.toFixed(decimals);
        }

        function renderEstimateGrouped() {
            const container = document.getElementById('estimateList');

            // 対応全体の作業月を計算する関数
            function getTaskWorkMonths(version, task) {
                // この対応の全工程を取得
                const taskEstimates = estimates.filter(e => e.version === version && e.task === task);

                // 全工程の作業月を収集（重複なし）
                const allMonths = new Set();
                taskEstimates.forEach(e => {
                    const est = normalizeEstimate(e);
                    est.workMonths.forEach(month => allMonths.add(month));
                });

                return Array.from(allMonths).sort();
            }

            // 作業予定月フィルタを適用
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const workMonthFilter = monthFilterElement ? monthFilterElement.value : 'all';

            // 実働日数を取得（人月計算用）
            let workingDaysPerMonth = 20; // デフォルト
            if (workMonthFilter !== 'all') {
                const [year, month] = workMonthFilter.split('-');
                workingDaysPerMonth = getWorkingDays(parseInt(year), parseInt(month));
            }

            let filteredEstimates = estimates;

            if (workMonthFilter !== 'all') {
                // 特定月: その月に割り当たっている工程のみ表示
                filteredEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.includes(workMonthFilter);
                });
            }

            // フィルタ内の工程がない場合
            if (filteredEstimates.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">該当する見積データがありません</p>';
                return;
            }

            // 表示する全ての見積
            const allDisplayEstimates = filteredEstimates;

            // 版数ごとにグループ化
            const versionGroups = {};
            allDisplayEstimates.forEach(e => {
                if (!versionGroups[e.version]) {
                    versionGroups[e.version] = {};
                }
                const taskKey = e.task;
                if (!versionGroups[e.version][taskKey]) {
                    versionGroups[e.version][taskKey] = {
                        task: e.task,
                        processes: []
                    };
                }

                // 月フィルタが適用されている場合は分割後の工数を使用
                const est = normalizeEstimate(e);
                let displayHours = e.hours;
                if (workMonthFilter !== 'all' && est.monthlyHours[workMonthFilter]) {
                    displayHours = est.monthlyHours[workMonthFilter];
                }

                versionGroups[e.version][taskKey].processes.push({
                    process: e.process,
                    member: e.member,
                    hours: displayHours,
                    id: e.id
                });
            });

            let html = '<div style="margin-bottom: 30px;">';

            // 換算基準の表示を生成
            let workDaysLabel = 'デフォルト20日';
            if (workMonthFilter !== 'all' && workMonthFilter !== 'unassigned') {
                const [year, month] = workMonthFilter.split('-');
                workDaysLabel = `${year}年${parseInt(month)}月の営業日数（${workingDaysPerMonth}日）`;
            }

            html += `<div style="background: #e3f2fd; padding: 12px 20px; border-radius: 8px; margin-bottom: 20px; font-size: 14px; color: #1565c0;">
                <strong>換算基準:</strong> 1人日 = 8h、1人月 = ${workingDaysPerMonth}人日（${workDaysLabel}）
            </div>`;

            // 版数ごとに表示
            Object.keys(versionGroups).sort().forEach(version => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                html += '<div class="table-wrapper"><table>';
                
                // 選択モードの場合、選択列を追加
                if (workMonthSelectionMode) {
                    html += '<tr><th style="min-width: 50px;">選択</th><th style="min-width: 200px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">工数</th><th style="min-width: 150px;">対応合計</th><th style="min-width: 150px;">操作</th></tr>';
                } else {
                    html += '<tr><th style="min-width: 200px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">工数</th><th style="min-width: 150px;">対応合計</th><th style="min-width: 150px;">操作</th></tr>';
                }
                
                Object.values(versionGroups[version]).forEach(taskGroup => {
                    const total = taskGroup.processes.reduce((sum, p) => sum + p.hours, 0);
                    const days = total / 8;
                    const months = total / 8 / workingDaysPerMonth;
                    
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];
                    const sortedProcesses = taskGroup.processes.sort((a, b) => 
                        processOrder.indexOf(a.process) - processOrder.indexOf(b.process)
                    );
                    
                    // 対応全体の作業月を計算
                    const taskWorkMonths = getTaskWorkMonths(version, taskGroup.task);

                    // 作業月バッジの生成（レスポンシブ対応）
                    let workMonthBadgeInline = ''; // 広い画面用（1行表示）
                    let workMonthBadgeBlock = ''; // 狭い画面用（改行表示）

                    if (taskWorkMonths.length === 0) {
                        workMonthBadgeInline = ' <span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">未設定</span>';
                        workMonthBadgeBlock = '<div style="margin-top: 4px;"><span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">未設定</span></div>';
                    } else if (taskWorkMonths.length === 1) {
                        const [y, m] = taskWorkMonths[0].split('-');
                        workMonthBadgeInline = ` <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y}年${parseInt(m)}月</span>`;
                        workMonthBadgeBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y}年${parseInt(m)}月</span></div>`;
                    } else {
                        // 複数月の場合
                        const [y1, m1] = taskWorkMonths[0].split('-');
                        const [y2, m2] = taskWorkMonths[taskWorkMonths.length - 1].split('-');
                        // 広い画面用: 1行表示
                        workMonthBadgeInline = ` <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月</span>`;
                        // 狭い画面用: 〜の前で改行可能にするため2つのバッジに分割
                        workMonthBadgeBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y1}年${parseInt(m1)}月</span> <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">〜${y2}年${parseInt(m2)}月</span></div>`;
                    }
                    
                    // 対応名を「:」または「：」で分割してレスポンシブ表示（祝日と同じ方式）
                    let taskDisplayHtml = taskGroup.task;
                    if (taskGroup.task.includes(':') || taskGroup.task.includes('：')) {
                        // 半角と全角の両方に対応
                        let separator = ':';
                        let parts;
                        
                        if (taskGroup.task.includes(':')) {
                            parts = taskGroup.task.split(':');
                        } else {
                            separator = '：';
                            parts = taskGroup.task.split('：');
                        }
                        
                        const restPart = parts.slice(1).join(separator);
                        // デスクトップ: コロンあり、モバイル: コロンなし
                        taskDisplayHtml = `${parts[0]}<span class="task-separator-inline">${separator} ${restPart}</span><span class="task-separator-break"><br><span style="font-size: 13px; font-weight: normal;">${restPart}</span></span>`;
                    }
                    
                    // 作業月バッジを追加（レスポンシブ対応）
                    taskDisplayHtml += `<span class="work-month-inline">${workMonthBadgeInline}</span><span class="work-month-block">${workMonthBadgeBlock}</span>`;
                    
                    // 対応の全工程が選択されているかチェック
                    const taskIds = taskGroup.processes.map(p => p.id);
                    const allSelected = taskIds.every(id => selectedEstimateIds.has(id));
                    
                    sortedProcesses.forEach((proc, index) => {
                        // この工程の見積データを取得
                        const estimate = estimates.find(e => e.id === proc.id);
                        const est = normalizeEstimate(estimate);
                        
                        // フィルタ外かどうか
                        const isOutOfFilter = proc.isOutOfFilter || false;
                        const grayStyle = isOutOfFilter ? 'opacity: 0.4;' : '';
                        const grayPrefix = isOutOfFilter ? '○ ' : '';
                        
                        // 作業月の表示を生成（レスポンシブ対応）
                        let processWorkMonthInline = ''; // 広い画面用（1行表示）
                        let processWorkMonthBlock = ''; // 狭い画面用（2行表示）
                        
                        if (est.workMonths.length > 0) {
                            if (est.workMonths.length === 1) {
                                const [y, m] = est.workMonths[0].split('-');
                                processWorkMonthInline = `<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px; white-space: nowrap;">${y}年${parseInt(m)}月</span>`;
                                processWorkMonthBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap;">${y}年${parseInt(m)}月</span></div>`;
                            } else {
                                const [y1, m1] = est.workMonths[0].split('-');
                                const [y2, m2] = est.workMonths[est.workMonths.length - 1].split('-');
                                processWorkMonthInline = `<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px; white-space: nowrap;">${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月</span>`;
                                processWorkMonthBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap;">${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月</span></div>`;
                            }
                        } else {
                            processWorkMonthInline = `<span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px; white-space: nowrap;">未設定</span>`;
                            processWorkMonthBlock = `<div style="margin-top: 4px;"><span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap;">未設定</span></div>`;
                        }
                        
                        html += '<tr>';
                        
                        // 選択モードの場合、チェックボックスを追加
                        if (workMonthSelectionMode) {
                            if (index === 0) {
                                // 対応名の行: 対応全体の選択チェックボックス（グレーなし）
                                html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; text-align: center; cursor: pointer;" onclick="selectTaskEstimates('${version}', '${taskGroup.task.replace(/'/g, "\\'")}', event)">
                                    <input type="checkbox" ${allSelected ? 'checked' : ''} style="width: auto; cursor: pointer;" onclick="selectTaskEstimates('${version}', '${taskGroup.task.replace(/'/g, "\\'")}', event)">
                                </td>`;
                            }
                        }
                        
                        if (index === 0) {
                            // 対応名（グレーなし）
                            html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; font-weight: 600;">${taskDisplayHtml}</td>`;
                        }
                        
                        // 選択モードではないときは通常の工程バッジ
                        // 選択モードのときは個別選択チェックボックスを表示
                        if (workMonthSelectionMode) {
                            const isSelected = selectedEstimateIds.has(proc.id);
                            // 工程セル（グレー適用）
                            html += `<td style="cursor: pointer; ${grayStyle}" onclick="toggleEstimateSelection(${proc.id}, event)">
                                <input type="checkbox" ${isSelected ? 'checked' : ''} style="width: auto; margin-right: 6px; cursor: pointer;" onclick="toggleEstimateSelection(${proc.id}, event)">
                                <div>
                                    <span>${grayPrefix}</span><span class="badge badge-${proc.process.toLowerCase()}">${proc.process}</span>
                                    <span class="work-month-inline">${processWorkMonthInline}</span>
                                </div>
                                <div class="work-month-block">${processWorkMonthBlock}</div>
                            </td>`;
                        } else {
                            // 工程セル（グレー適用）
                            html += `<td style="${grayStyle}"><span>${grayPrefix}</span><span class="badge badge-${proc.process.toLowerCase()}">${proc.process}</span></td>`;
                        }
                        
                        // 担当セル（グレー適用）
                        html += `<td style="${grayStyle}">${proc.member}</td>`;
                        // 工数セル（グレー適用）
                        html += `<td style="text-align: right; ${grayStyle}">${proc.hours}h</td>`;
                        
                        if (index === 0) {
                            // 対応合計（グレーなし）
                            html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; text-align: right;">
                                <div style="font-weight: 700; color: #1976d2; font-size: 16px; margin-bottom: 4px;">${formatNumber(total, 1)}h</div>
                                <div style="font-size: 13px; color: #666;">${formatNumber(days, 1)}人日 / ${formatNumber(months, 2)}人月</div>
                            </td>`;
                        }
                        
                        // 操作ボタン（グレーなし）
                        html += `<td>
                            <button class="btn btn-primary btn-small" onclick="editEstimate(${proc.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-danger btn-small" onclick="deleteEstimate(${proc.id})">削除</button>
                        </td>`;
                        html += '</tr>';
                    });
                });
                
                // 版数の合計
                const versionTotal = Object.values(versionGroups[version])
                    .reduce((sum, taskGroup) => sum + taskGroup.processes.reduce((s, p) => s + p.hours, 0), 0);
                const versionDays = versionTotal / 8;
                const versionMonths = versionTotal / 8 / workingDaysPerMonth;
                
                html += `<tr style="background: #f5f5f5; font-weight: 700;">`;
                if (workMonthSelectionMode) {
                    html += `<td></td>`;
                }
                html += `<td style="text-align: right; padding-right: 20px;">${version} 合計</td>`;
                html += `<td colspan="2"></td>`;
                html += `<td style="text-align: right;">${formatNumber(versionTotal, 1)}h</td>`;
                html += `<td style="text-align: right;">
                    <div style="font-size: 15px; margin-bottom: 3px;">${formatNumber(versionDays, 1)}人日 / ${formatNumber(versionMonths, 2)}人月</div>
                </td>`;
                html += `<td></td>`;
                html += `</tr>`;
                
                html += '</table></div>';
                html += '</div>';
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        function renderEstimateMatrix() {
            const container = document.getElementById('estimateList');

            // 月フィルタを取得
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const workMonthFilter = monthFilterElement ? monthFilterElement.value : 'all';

            // フィルタを適用
            let filteredEstimates = estimates;
            if (workMonthFilter !== 'all') {
                filteredEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.includes(workMonthFilter);
                });
            }

            // 版数ごとにグループ化
            const versionGroups = {};
            filteredEstimates.forEach(e => {
                if (!versionGroups[e.version]) {
                    versionGroups[e.version] = {};
                }
                const taskKey = e.task;
                if (!versionGroups[e.version][taskKey]) {
                    versionGroups[e.version][taskKey] = {
                        task: e.task,
                        processes: {}
                    };
                }

                // 月フィルタが適用されている場合は分割後の工数を使用
                const est = normalizeEstimate(e);
                let displayHours = e.hours;
                if (workMonthFilter !== 'all' && est.monthlyHours[workMonthFilter]) {
                    displayHours = est.monthlyHours[workMonthFilter];
                }

                versionGroups[e.version][taskKey].processes[e.process] = {
                    member: e.member,
                    hours: displayHours,
                    id: e.id
                };
            });

            const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

            let html = '<div style="margin-bottom: 30px;">';

            // 版数ごとに表示
            Object.keys(versionGroups).sort().forEach(version => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                html += '<div class="table-wrapper"><table>';
                html += '<tr><th style="min-width: 200px;">対応名</th>';
                processOrder.forEach(proc => {
                    html += `<th style="min-width: 100px; text-align: center;">${proc}</th>`;
                });
                html += '<th style="min-width: 80px; text-align: center;">合計</th><th style="min-width: 150px;">操作</th></tr>';

                Object.values(versionGroups[version]).forEach(group => {
                    // 対応名を「：」（全角コロン）で分割して2行表示
                    let taskDisplayHtml = group.task;
                    if (group.task.includes('：')) {
                        const parts = group.task.split('：');
                        const restPart = parts.slice(1).join('：');
                        taskDisplayHtml = `${parts[0]}<br><span style="font-size: 13px; font-weight: normal;">${restPart}</span>`;
                    }

                    html += '<tr>';
                    html += `<td style="font-weight: 600;">${taskDisplayHtml}</td>`;

                    let total = 0;
                    let firstId = null;
                    processOrder.forEach(proc => {
                        if (group.processes[proc]) {
                            const p = group.processes[proc];
                            total += p.hours;
                            if (!firstId) firstId = p.id;
                            html += `<td style="text-align: center;">
                                <div style="font-weight: 600;">${p.hours.toFixed(1)}h</div>
                                <div style="font-size: 12px; color: #666;">(${p.member})</div>
                            </td>`;
                        } else {
                            html += `<td style="text-align: center; color: #ccc;">-</td>`;
                        }
                    });

                    html += `<td style="text-align: center; font-weight: 700; color: #1976d2;">${total.toFixed(1)}h</td>`;
                    html += `<td>
                        <button class="btn btn-primary btn-small" onclick="editEstimate(${firstId})" style="margin-right: 5px;">編集</button>
                        <button class="btn btn-danger btn-small" onclick="deleteEstimate(${firstId})">削除</button>
                    </td>`;
                    html += '</tr>';
                });

                html += '</table></div>';
                html += '</div>';
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function renderEstimateDetailList() {
            const container = document.getElementById('estimateList');

            // 月フィルタを取得
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const workMonthFilter = monthFilterElement ? monthFilterElement.value : 'all';

            // フィルタを適用
            let filteredEstimates = estimates;
            if (workMonthFilter !== 'all') {
                filteredEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.includes(workMonthFilter);
                });
            }

            let html = '<div class="table-wrapper"><table><tr><th>版数</th><th>対応名</th><th>工程</th><th>担当</th><th>見積工数</th><th>作業予定月</th><th>操作</th></tr>';

            filteredEstimates.forEach(e => {
                const est = normalizeEstimate(e);

                // 月フィルタが適用されている場合は分割後の工数を表示
                let displayHours = est.hours;
                if (workMonthFilter !== 'all' && est.monthlyHours[workMonthFilter]) {
                    displayHours = est.monthlyHours[workMonthFilter];
                }
                
                // 作業予定月の表示
                let workMonthDisplay = '-';
                if (est.workMonths.length > 0) {
                    if (est.workMonths.length === 1) {
                        const [y, m] = est.workMonths[0].split('-');
                        workMonthDisplay = `${y}年${parseInt(m)}月`;
                    } else {
                        const [y1, m1] = est.workMonths[0].split('-');
                        const [y2, m2] = est.workMonths[est.workMonths.length - 1].split('-');
                        workMonthDisplay = `${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月`;
                        // 月別内訳を表示
                        workMonthDisplay += '<br><small style="color: #666;">';
                        est.workMonths.forEach((month, idx) => {
                            const [y, m] = month.split('-');
                            const hours = est.monthlyHours[month] || 0;
                            if (idx > 0) workMonthDisplay += ', ';
                            workMonthDisplay += `${y}年${parseInt(m)}月:${hours.toFixed(1)}h`;
                        });
                        workMonthDisplay += '</small>';
                    }
                }
                
                html += `
                    <tr>
                        <td>${est.version}</td>
                        <td>${est.task}</td>
                        <td><span class="badge badge-${est.process.toLowerCase()}">${est.process}</span></td>
                        <td>${est.member}</td>
                        <td>${displayHours.toFixed(1)}h</td>
                        <td>${workMonthDisplay}</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editEstimate(${est.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-small" onclick="openSplitEstimateModal(${est.id})" style="margin-right: 5px; background: #3498db; color: white;">分割</button>
                            <button class="btn btn-danger btn-small" onclick="deleteEstimate(${est.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        function renderActualList() {
            const container = document.getElementById('actualList');
            const viewType = document.getElementById('actualViewType').value;
            const viewMode = document.getElementById('actualViewMode').value;

            // 担当者別モード時は担当者選択を表示（両方のレイアウトを同期）
            const memberSelectGroup = document.getElementById('memberSelectGroup');
            const memberSelectGroup2 = document.getElementById('memberSelectGroup2');
            if (viewMode === 'member') {
                memberSelectGroup.style.display = 'flex';
                if (memberSelectGroup2) memberSelectGroup2.style.display = 'flex';
                updateMemberSelectOptions();
            } else {
                memberSelectGroup.style.display = 'none';
                if (memberSelectGroup2) memberSelectGroup2.style.display = 'none';
            }
            
            if (actuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">実績データがありません</p>';
                return;
            }

            if (viewType === 'matrix') {
                if (viewMode === 'member') {
                    renderMemberCalendar();
                } else {
                    renderActualMatrix();
                }
            } else {
                renderActualListView();
            }
        }

        function updateMemberSelectOptions() {
            const select = document.getElementById('actualMemberSelect');
            const select2 = document.getElementById('actualMemberSelect2');
            const currentValue = select.value;

            // 担当者を抽出
            const allMembers = new Set();
            actuals.forEach(a => allMembers.add(a.member));
            estimates.forEach(e => allMembers.add(e.member));

            // 表示順でソート
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];

                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });

                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });

                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(allMembers).sort();
            }

            // 両方のセレクトボックスを更新
            select.innerHTML = '';
            if (select2) select2.innerHTML = '';

            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = member;
                    option2.textContent = member;
                    select2.appendChild(option2);
                }
            });

            // 以前の選択を復元
            if (currentValue && sortedMembers.includes(currentValue)) {
                select.value = currentValue;
                if (select2) select2.value = currentValue;
            } else if (sortedMembers.length > 0) {
                select.value = sortedMembers[0];
                if (select2) select2.value = sortedMembers[0];
            }

            // セグメントボタン版を生成（実績一覧セグメントレイアウト用）
            const items = sortedMembers.map(member => ({
                value: member,
                label: member
            }));
            const selectedValue = select.value;
            createSegmentButtons(
                'actualMemberButtons2',
                'actualMemberSelect2',
                items,
                selectedValue,
                6, // 最大6個までセグメントボタン表示
                handleActualMemberChange
            );
        }

        function renderMemberCalendar() {
            const container = document.getElementById('actualList');
            const selectedMonth = document.getElementById('actualMonthFilter').value;
            const selectedMember = document.getElementById('actualMemberSelect').value;
            
            if (!selectedMember) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">担当者を選択してください</p>';
                return;
            }
            
            // 担当者と月でフィルタリング
            let filteredActuals = actuals.filter(a => a.member === selectedMember);
            if (selectedMonth !== 'all') {
                filteredActuals = filteredActuals.filter(a => a.date && a.date.startsWith(selectedMonth));
            }
            
            if (filteredActuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した期間に実績データがありません</p>';
                return;
            }
            
            // 日付範囲を計算
            const dates = filteredActuals.map(a => a.date).sort();
            let startDate, endDate;
            
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                const yearNum = parseInt(year);
                const monthNum = parseInt(month);
                
                startDate = `${year}-${month}-01`;
                const lastDay = new Date(yearNum, monthNum, 0).getDate();
                endDate = `${year}-${month}-${String(lastDay).padStart(2, '0')}`;
            } else {
                const [minYear, minMonth] = dates[0].split('-');
                const [maxYear, maxMonth] = dates[dates.length - 1].split('-');
                
                startDate = `${minYear}-${minMonth}-01`;
                const lastDay = new Date(parseInt(maxYear), parseInt(maxMonth), 0).getDate();
                endDate = `${maxYear}-${maxMonth}-${String(lastDay).padStart(2, '0')}`;
            }
            
            // 日付リスト生成
            const allDates = [];
            let currentDateStr = startDate;
            while (currentDateStr <= endDate) {
                allDates.push(currentDateStr);
                const [y, m, d] = currentDateStr.split('-').map(Number);
                const nextDate = new Date(y, m - 1, d + 1);
                currentDateStr = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}-${String(nextDate.getDate()).padStart(2, '0')}`;
            }
            
            // 合計情報
            const totalHours = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
            const workedDays = new Set(filteredActuals.map(a => a.date)).size;
            
            let html = `<h3 style="margin-bottom: 10px;">${selectedMember}の実績カレンダー</h3>`;
            
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                html += `<div style="margin-bottom: 15px;">
                    <p style="margin: 0 0 5px 0; font-weight: 600;">${year}年${parseInt(month)}月の合計</p>
                    <p style="margin: 0; color: #666; font-size: 14px;">稼働日数: ${workedDays}日 / 合計工数: ${totalHours.toFixed(1)}h</p>
                </div>`;
            }
            
            html += '<div class="table-wrapper" style="overflow-x: auto;"><table style="min-width: 100%;">';
            html += '<tr><th style="min-width: 120px;">日付</th><th style="min-width: 300px;">作業内容</th><th style="min-width: 80px;">工数</th></tr>';
            
            allDates.forEach(date => {
                const dateObj = new Date(date);
                const dayOfWeek = getDayOfWeek(date);
                const holiday = getHoliday(date);
                const isWeekend = dayOfWeek === '土' || dayOfWeek === '日';
                const isHoliday = holiday !== null;
                
                const dayActuals = filteredActuals.filter(a => a.date === date);
                const dayTotal = dayActuals.reduce((sum, a) => sum + a.hours, 0);
                
                const bgColor = (isWeekend || isHoliday) ? '#ffebee' : 'white';
                const dateColor = (isWeekend || isHoliday) ? 'color: #c62828;' : '';
                
                const [year, m, day] = date.split('-');
                // 祝日の場合、クラスで制御して画面幅に応じて表示を変える
                const dateDisplay = isHoliday 
                    ? `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})<span class="holiday-inline"> ${holiday}</span><span class="holiday-break"><br><span style="font-size: 11px; font-weight: normal;">${holiday}</span></span>`
                    : `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})`;
                
                if (dayActuals.length === 0) {
                    html += `<tr style="background: ${bgColor};">`;
                    html += `<td style="font-weight: 500; ${dateColor}">${dateDisplay}</td>`;
                    html += `<td style="color: #999;">-</td>`;
                    html += `<td style="text-align: center; color: #999;">-</td>`;
                    html += `</tr>`;
                } else {
                    dayActuals.forEach((actual, index) => {
                        if (index === 0) {
                            html += `<tr style="background: ${bgColor};">`;
                            html += `<td rowspan="${dayActuals.length}" style="font-weight: 500; ${dateColor} vertical-align: top; padding-top: 12px;">${dateDisplay}</td>`;
                        } else {
                            html += `<tr style="background: ${bgColor};">`;
                        }
                        // HTMLエスケープ関数
                        const escapeHtml = (str) => {
                            const div = document.createElement('div');
                            div.textContent = str;
                            return div.innerHTML;
                        };
                        html += `<td style="font-size: 14px;">${escapeHtml(actual.version)} - ${escapeHtml(actual.task)} [${actual.process}]</td>`;
                        html += `<td style="text-align: center; font-weight: 600;">${actual.hours}h</td>`;
                        html += `</tr>`;
                    });
                }
            });
            
            // 総合計行
            html += `<tr style="background: #1565c0; color: white; font-weight: 700;">`;
            html += `<td>総合計</td>`;
            html += `<td style="text-align: right;">${workedDays}日稼働</td>`;
            html += `<td style="text-align: center;">${totalHours.toFixed(1)}h</td>`;
            html += `</tr>`;
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        function renderActualMatrix() {
            const container = document.getElementById('actualList');
            const selectedMonth = document.getElementById('actualMonthFilter').value;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            
            // 月でフィルタリング
            let filteredActuals = actuals;
            if (selectedMonth !== 'all') {
                filteredActuals = actuals.filter(a => a.date && a.date.startsWith(selectedMonth));
            }
            
            if (filteredActuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した期間に実績データがありません</p>';
                return;
            }
            
            // 担当者を抽出して並び替え
            let members = [...new Set(filteredActuals.map(a => a.member))];
            
            // 表示順が指定されている場合
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                // 指定された順序で追加
                orderList.forEach(name => {
                    if (members.includes(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                // 指定されていない担当者を後ろに追加
                members.forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                members = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                members.sort();
            }
            
            // 実績データの日付範囲を取得
            const dates = filteredActuals.map(a => a.date).sort();
            
            // 表示範囲を決定
            let startDate, endDate;
            if (selectedMonth !== 'all') {
                // 選択した月のみ（月初から月末まで正確に）
                const [year, month] = selectedMonth.split('-');
                const yearNum = parseInt(year);
                const monthNum = parseInt(month);
                
                // 月の最初の日
                startDate = `${year}-${month}-01`;
                
                // 月の最後の日を計算
                const lastDay = new Date(yearNum, monthNum, 0).getDate();
                endDate = `${year}-${month}-${String(lastDay).padStart(2, '0')}`;
            } else {
                // 全期間（最小日付の月初から最大日付の月末まで）
                const minDate = dates[0];
                const maxDate = dates[dates.length - 1];
                
                const [minYear, minMonth] = minDate.split('-');
                const [maxYear, maxMonth] = maxDate.split('-');
                
                startDate = `${minYear}-${minMonth}-01`;
                
                const lastDay = new Date(parseInt(maxYear), parseInt(maxMonth), 0).getDate();
                endDate = `${maxYear}-${maxMonth}-${String(lastDay).padStart(2, '0')}`;
            }
            
            // 日付範囲を生成
            const allDates = [];
            let currentDateStr = startDate;
            while (currentDateStr <= endDate) {
                allDates.push(currentDateStr);
                
                // 次の日付を計算
                const [y, m, d] = currentDateStr.split('-').map(Number);
                const nextDate = new Date(y, m - 1, d + 1);
                currentDateStr = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}-${String(nextDate.getDate()).padStart(2, '0')}`;
            }
            
            let html = '';
            
            // 月の合計を最上部に表示（月選択時のみ）
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                
                // 稼働日数を計算（実績が入力されている日数）
                const workedDays = new Set(filteredActuals.map(a => a.date)).size;
                
                html += `<div style="margin-bottom: 15px;">
                    <h3 style="margin: 0 0 5px 0;">${year}年${parseInt(month)}月の合計</h3>
                    <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">稼働日数: ${workedDays}日</p>
                </div>`;
                
                // 同じtable-wrapper内に合計表を配置
                html += '<div class="table-wrapper"><table>';
                
                // 合計行（濃い青色）
                html += '<tr style="background: #1565c0; color: white; font-weight: 700;"><th style="min-width: 100px;">総合計</th>';
                
                let monthGrandTotal = 0;
                members.forEach(member => {
                    const memberTotal = filteredActuals.filter(a => a.member === member).reduce((sum, a) => sum + a.hours, 0);
                    monthGrandTotal += memberTotal;
                    html += `<th style="text-align: center; min-width: 80px;">${memberTotal.toFixed(1)}h</th>`;
                });
                
                html += `<th style="background: #ff9800; text-align: center; min-width: 80px;">${monthGrandTotal.toFixed(1)}h</th>`;
                html += '</tr>';
                
                // ヘッダー行（通常の色）
                html += '<tr><th style="min-width: 100px;">日付</th>';
                
                // 担当者ヘッダー
                members.forEach(member => {
                    html += `<th style="min-width: 80px; text-align: center;">${member}</th>`;
                });
                html += '<th style="min-width: 80px; text-align: center;">日別合計</th></tr>';
            } else {
                // 全期間表示の場合は通常通りヘッダーのみ
                html += '<div class="table-wrapper"><table>';
                html += '<tr><th style="min-width: 100px;">日付</th>';
                
                // 担当者ヘッダー
                members.forEach(member => {
                    html += `<th style="min-width: 80px; text-align: center;">${member}</th>`;
                });
                html += '<th style="min-width: 80px; text-align: center;">日別合計</th></tr>';
            }
            
            let currentMonth = '';
            let monthTotals = {};
            members.forEach(m => monthTotals[m] = 0);
            let monthTotal = 0;
            
            // 日付ごとの行
            allDates.forEach(date => {
                const dateObj = new Date(date);
                const month = `${dateObj.getFullYear()}年${dateObj.getMonth() + 1}月`;
                const dayOfWeek = getDayOfWeek(date);
                const isWeekend = dayOfWeek === '土' || dayOfWeek === '日';
                
                // 祝日判定
                const holiday = getHoliday(date);
                const isHoliday = holiday !== null;
                
                // 月が変わったら月次小計行を挿入（全期間表示時のみ）
                if (selectedMonth === 'all' && currentMonth && currentMonth !== month) {
                    html += '<tr style="background: #fff3cd; font-weight: 600;">';
                    html += `<td>${currentMonth} 小計</td>`;
                    members.forEach(member => {
                        html += `<td style="text-align: center;">${monthTotals[member].toFixed(1)}h</td>`;
                    });
                    html += `<td style="background: #ffc107; color: white; text-align: center;">${monthTotal.toFixed(1)}h</td>`;
                    html += '</tr>';
                    
                    // リセット
                    members.forEach(m => monthTotals[m] = 0);
                    monthTotal = 0;
                }
                
                currentMonth = month;
                
                // 日付行（祝日または週末）
                const bgColor = (isWeekend || isHoliday) ? '#ffebee' : 'white';
                html += `<tr style="background: ${bgColor};">`;
                
                // 日付セル
                const [year, m, day] = date.split('-');
                const dateColor = (isWeekend || isHoliday) ? 'color: #c62828;' : '';
                // 祝日の場合、クラスで制御して画面幅に応じて表示を変える
                const dateDisplay = isHoliday
                    ? `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})<span class="holiday-inline"> ${holiday}</span><span class="holiday-break"><br><span style="font-size: 11px; font-weight: normal;">${holiday}</span></span>`
                    : `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})`;
                html += `<td style="font-weight: 500; ${dateColor}">
                    ${dateDisplay}
                </td>`;
                
                let dayTotal = 0;
                
                // 担当者ごとのセル
                members.forEach(member => {
                    const dayActuals = filteredActuals.filter(a => a.member === member && a.date === date);
                    const memberDayTotal = dayActuals.reduce((sum, a) => sum + a.hours, 0);
                    dayTotal += memberDayTotal;
                    monthTotals[member] += memberDayTotal;
                    
                    if (memberDayTotal > 0) {
                        // クリックで詳細表示
                        html += `<td style="background: #e3f2fd; text-align: center; cursor: pointer;" 
                                    onclick="showWorkDetail('${member}', '${date}')">
                            <strong>${memberDayTotal.toFixed(1)}</strong>
                        </td>`;
                    } else {
                        // クリックで新規登録
                        html += `<td style="background: #fafafa; text-align: center; color: #ccc; cursor: pointer;" 
                                    onclick="addActualFromCalendar('${member}', '${date}')" 
                                    title="実績を登録">-</td>`;
                    }
                });
                
                monthTotal += dayTotal;
                
                // 日別合計
                if (dayTotal > 0) {
                    html += `<td style="font-weight: 700; background: #fff3cd; text-align: center;">${dayTotal.toFixed(1)}h</td>`;
                } else {
                    html += `<td style="background: #fafafa; text-align: center; color: #ccc;">-</td>`;
                }
                
                html += '</tr>';
            });
            
            // 最後の月の小計（全期間表示時のみ）
            if (selectedMonth === 'all' && currentMonth) {
                html += '<tr style="background: #fff3cd; font-weight: 600;">';
                html += `<td>${currentMonth} 小計</td>`;
                members.forEach(member => {
                    html += `<td style="text-align: center;">${monthTotals[member].toFixed(1)}h</td>`;
                });
                html += `<td style="background: #ffc107; color: white; text-align: center;">${monthTotal.toFixed(1)}h</td>`;
                html += '</tr>';
            }
            
            // 全期間の合計行
            html += '<tr style="background: #2c3e50; color: white; font-weight: 700;">';
            html += '<td>総合計</td>';
            let grandTotal = 0;
            
            members.forEach(member => {
                const memberTotal = filteredActuals.filter(a => a.member === member).reduce((sum, a) => sum + a.hours, 0);
                grandTotal += memberTotal;
                html += `<td style="text-align: center;">${memberTotal.toFixed(1)}h</td>`;
            });
            
            html += `<td style="background: #ffc107; text-align: center;">${grandTotal.toFixed(1)}h</td>`;
            html += '</tr>';
            
            html += '</table></div>';
            
            // 詳細リスト（削除用）
            html += '<h3 style="margin-top: 30px;">詳細データ（削除用）</h3>';
            html += '<div class="table-wrapper"><table>';
            html += '<tr><th>日付</th><th>担当者</th><th>版数</th><th>対応名</th><th>工程</th><th>実績工数</th><th>操作</th></tr>';
            
            const sortedActuals = [...filteredActuals].sort((a, b) => {
                if (a.date !== b.date) return b.date.localeCompare(a.date);
                return a.member.localeCompare(b.member);
            });
            
            sortedActuals.forEach(a => {
                // HTMLエスケープ関数
                const escapeHtml = (str) => {
                    const div = document.createElement('div');
                    div.textContent = str;
                    return div.innerHTML;
                };
                
                html += `
                    <tr>
                        <td>${a.date}</td>
                        <td>${escapeHtml(a.member)}</td>
                        <td>${escapeHtml(a.version)}</td>
                        <td>${escapeHtml(a.task)}</td>
                        <td><span class="badge badge-${a.process.toLowerCase()}">${a.process}</span></td>
                        <td>${a.hours}h</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editActual(${a.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-danger btn-small" onclick="deleteActual(${a.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }


        function renderActualListView() {
            const container = document.getElementById('actualList');
            const viewMode = document.getElementById('actualViewMode').value;
            const selectedMonth = document.getElementById('actualMonthFilter').value;
            
            // フィルタリング処理
            let filteredActuals = actuals;
            
            // 担当者別モードの場合
            if (viewMode === 'member') {
                const selectedMember = document.getElementById('actualMemberSelect').value;
                if (selectedMember) {
                    filteredActuals = filteredActuals.filter(a => a.member === selectedMember);
                }
            }
            
            // 月でフィルタリング
            if (selectedMonth !== 'all') {
                filteredActuals = filteredActuals.filter(a => a.date && a.date.startsWith(selectedMonth));
            }
            
            let html = '<div class="table-wrapper"><table><tr><th>日付</th><th>版数</th><th>対応名</th><th>工程</th><th>担当</th><th>実績工数</th><th>操作</th></tr>';
            
            const sortedActuals = [...filteredActuals].sort((a, b) => new Date(b.date) - new Date(a.date));
            
            if (sortedActuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した条件に該当する実績データがありません</p>';
                return;
            }
            
            sortedActuals.forEach(a => {
                html += `
                    <tr>
                        <td>${a.date}</td>
                        <td>${a.version}</td>
                        <td>${a.task}</td>
                        <td><span class="badge badge-${a.process.toLowerCase()}">${a.process}</span></td>
                        <td>${a.member}</td>
                        <td>${a.hours}h</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editActual(${a.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-danger btn-small" onclick="deleteActual(${a.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        function getDayOfWeek(dateStr) {
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            const date = new Date(dateStr);
            return days[date.getDay()];
        }

        function getHoliday(dateStr) {
            // @holiday-jp/holiday_jp ライブラリを使用
            if (typeof holiday_jp !== 'undefined' && typeof holiday_jp.isHoliday === 'function') {
                try {
                    const date = new Date(dateStr + 'T00:00:00');
                    const holiday = holiday_jp.isHoliday(date);
                    if (holiday) {
                        // holiday.name が祝日名
                        return holiday.name || holiday;
                    }
                } catch (error) {
                    console.error('Holiday check error:', error);
                }
            }
            
            // フォールバック: 主要な祝日のみ対応（2025-2030年）
            const holidays = {
                // 2025年
                '2025-01-01': '元日',
                '2025-01-13': '成人の日',
                '2025-02-11': '建国記念の日',
                '2025-02-23': '天皇誕生日',
                '2025-02-24': '振替休日',
                '2025-03-20': '春分の日',
                '2025-04-29': '昭和の日',
                '2025-05-03': '憲法記念日',
                '2025-05-04': 'みどりの日',
                '2025-05-05': 'こどもの日',
                '2025-05-06': '振替休日',
                '2025-07-21': '海の日',
                '2025-08-11': '山の日',
                '2025-09-15': '敬老の日',
                '2025-09-23': '秋分の日',
                '2025-10-13': 'スポーツの日',
                '2025-11-03': '文化の日',
                '2025-11-23': '勤労感謝の日',
                '2025-11-24': '振替休日',
                // 2026年
                '2026-01-01': '元日',
                '2026-01-12': '成人の日',
                '2026-02-11': '建国記念の日',
                '2026-02-23': '天皇誕生日',
                '2026-03-20': '春分の日',
                '2026-04-29': '昭和の日',
                '2026-05-03': '憲法記念日',
                '2026-05-04': 'みどりの日',
                '2026-05-05': 'こどもの日',
                '2026-05-06': '振替休日',
                '2026-07-20': '海の日',
                '2026-08-11': '山の日',
                '2026-09-21': '敬老の日',
                '2026-09-22': '秋分の日',
                '2026-10-12': 'スポーツの日',
                '2026-11-03': '文化の日',
                '2026-11-23': '勤労感謝の日',
                '2026-12-23': '天皇誕生日',
                // 2027年
                '2027-01-01': '元日',
                '2027-01-11': '成人の日',
                '2027-02-11': '建国記念の日',
                '2027-02-23': '天皇誕生日',
                '2027-03-21': '春分の日',
                '2027-03-22': '振替休日',
                '2027-04-29': '昭和の日',
                '2027-05-03': '憲法記念日',
                '2027-05-04': 'みどりの日',
                '2027-05-05': 'こどもの日',
                '2027-07-19': '海の日',
                '2027-08-11': '山の日',
                '2027-09-20': '敬老の日',
                '2027-09-23': '秋分の日',
                '2027-10-11': 'スポーツの日',
                '2027-11-03': '文化の日',
                '2027-11-23': '勤労感謝の日',
                '2027-12-23': '天皇誕生日',
                // 2028年
                '2028-01-01': '元日',
                '2028-01-10': '成人の日',
                '2028-02-11': '建国記念の日',
                '2028-02-23': '天皇誕生日',
                '2028-03-20': '春分の日',
                '2028-04-29': '昭和の日',
                '2028-05-03': '憲法記念日',
                '2028-05-04': 'みどりの日',
                '2028-05-05': 'こどもの日',
                '2028-07-17': '海の日',
                '2028-08-11': '山の日',
                '2028-09-18': '敬老の日',
                '2028-09-22': '秋分の日',
                '2028-10-09': 'スポーツの日',
                '2028-11-03': '文化の日',
                '2028-11-23': '勤労感謝の日',
                '2028-12-23': '天皇誕生日',
                // 2029年
                '2029-01-01': '元日',
                '2029-01-08': '成人の日',
                '2029-02-11': '建国記念の日',
                '2029-02-12': '振替休日',
                '2029-02-23': '天皇誕生日',
                '2029-03-20': '春分の日',
                '2029-04-29': '昭和の日',
                '2029-04-30': '振替休日',
                '2029-05-03': '憲法記念日',
                '2029-05-04': 'みどりの日',
                '2029-05-05': 'こどもの日',
                '2029-07-16': '海の日',
                '2029-08-11': '山の日',
                '2029-09-17': '敬老の日',
                '2029-09-23': '秋分の日',
                '2029-09-24': '振替休日',
                '2029-10-08': 'スポーツの日',
                '2029-11-03': '文化の日',
                '2029-11-23': '勤労感謝の日',
                '2029-12-23': '天皇誕生日',
                '2029-12-24': '振替休日',
                // 2030年
                '2030-01-01': '元日',
                '2030-01-14': '成人の日',
                '2030-02-11': '建国記念の日',
                '2030-02-23': '天皇誕生日',
                '2030-03-20': '春分の日',
                '2030-04-29': '昭和の日',
                '2030-05-03': '憲法記念日',
                '2030-05-04': 'みどりの日',
                '2030-05-05': 'こどもの日',
                '2030-05-06': '振替休日',
                '2030-07-15': '海の日',
                '2030-08-11': '山の日',
                '2030-08-12': '振替休日',
                '2030-09-16': '敬老の日',
                '2030-09-23': '秋分の日',
                '2030-10-14': 'スポーツの日',
                '2030-11-03': '文化の日',
                '2030-11-04': '振替休日',
                '2030-11-23': '勤労感謝の日',
                '2030-12-23': '天皇誕生日'
            };
            
            return holidays[dateStr] || null;
        }

        function showWorkDetail(member, date) {
            const dayActuals = actuals.filter(a => a.member === member && a.date === date);
            
            if (dayActuals.length === 0) return;
            
            const dateObj = new Date(date);
            const [year, month, day] = date.split('-');
            const dayOfWeek = getDayOfWeek(date);
            
            // モーダルタイトル
            document.getElementById('modalTitle').textContent = 
                `${member}さんの作業 - ${year}年${parseInt(month)}月${parseInt(day)}日(${dayOfWeek})`;
            
            // モーダル本文
            let html = '';
            const totalHours = dayActuals.reduce((sum, a) => sum + a.hours, 0);
            
            dayActuals.forEach(actual => {
                html += `
                    <div class="work-item">
                        <div class="work-item-header">
                            <div class="work-item-title">${actual.task}</div>
                            <div class="work-item-hours">${actual.hours}h</div>
                        </div>
                        <div class="work-item-details">
                            <span><strong>版数:</strong> ${actual.version || '(なし)'}</span>
                            <span><strong>工程:</strong> ${actual.process ? `<span class="badge badge-${actual.process.toLowerCase()}">${actual.process}</span>` : '(なし)'}</span>
                        </div>
                        <div style="margin-top: 8px; text-align: right;">
                            <button onclick="editActualFromModal(${actual.id})" style="background: none; border: none; color: #3498db; cursor: pointer; font-size: 12px; padding: 4px 8px; text-decoration: underline;">編集</button>
                            <button onclick="deleteActualFromModal(${actual.id}, '${member}', '${date}')" style="background: none; border: none; color: #95a5a6; cursor: pointer; font-size: 12px; padding: 4px 8px; text-decoration: underline;">削除</button>
                        </div>
                    </div>
                `;
            });
            
            html += `
                <div style="margin-top: 20px; padding-top: 15px; border-top: 2px solid #eee; text-align: right;">
                    <strong style="font-size: 16px;">合計: ${totalHours.toFixed(1)}時間</strong>
                    <span style="color: #666; font-size: 14px; margin-left: 10px;">(${dayActuals.length}件)</span>
                </div>
                <div style="margin-top: 15px; text-align: center;">
                    <button onclick="addActualFromCalendar('${member}', '${date}'); closeWorkModal();"
                            style="padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                        + 新しい実績を追加
                    </button>
                </div>
            `;

            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('workModal').style.display = 'block';
        }

        function closeWorkModal() {
            document.getElementById('workModal').style.display = 'none';
        }
        
        // カレンダーから実績を新規登録
        function addActualFromCalendar(member, date) {
            // 実績編集モーダルを開く（新規登録モード）
            document.getElementById('editActualId').value = '';
            document.getElementById('editActualDate').value = date;

            // 版数を最新のものにデフォルト設定
            const versionSelect = document.getElementById('editActualVersion');
            if (versionSelect.options.length > 2) {
                // options[0]="-- 版数を選択 --", options[1]="+ 新しい版数を追加...", options[2]以降が実際の版数
                versionSelect.value = versionSelect.options[2].value;
            } else {
                versionSelect.value = '';
            }

            // 対応名のselect/inputを初期化
            document.getElementById('editActualTaskSelect').style.display = 'block';
            document.getElementById('editActualTaskSelect').value = '';
            document.getElementById('editActualTaskSearch').style.display = 'none';
            document.getElementById('editActualTaskSearch').value = '';
            document.getElementById('editActualProcess').value = 'UI';
            
            // 担当者を設定（カレンダーからの場合は表示のみ）
            const memberSelect = document.getElementById('editActualMember');
            const memberDisplay = document.getElementById('editActualMemberDisplay');
            memberSelect.value = member;
            memberSelect.style.display = 'none';
            memberDisplay.style.display = 'block';
            memberDisplay.textContent = member;

            document.getElementById('editActualHours').value = '';

            // モーダルのタイトルを変更
            const modalTitle = document.querySelector('#editActualModal .modal-header h3');
            const [year, month, day] = date.split('-');
            modalTitle.textContent = `実績を新規登録 - ${member} (${year}/${parseInt(month)}/${parseInt(day)})`;

            // この担当者の未完了対応を取得してdatalistに設定
            updateEditActualTaskList(member);

            // 「その他作業」ボタンを表示し、データを保持
            document.getElementById('editActualOtherBtn').style.display = 'block';
            document.getElementById('editActualModal').dataset.calendarMember = member;
            document.getElementById('editActualModal').dataset.calendarDate = date;

            document.getElementById('editActualModal').style.display = 'flex';
        }

        // カレンダーからその他作業モーダルを開く
        function openOtherWorkFromCalendar() {
            const modal = document.getElementById('editActualModal');
            const member = modal.dataset.calendarMember;
            const date = modal.dataset.calendarDate;

            // 実績編集モーダルを閉じる
            closeEditActualModal();

            // その他作業モーダルを開き、担当者と日付を設定
            openOtherWorkModalWithContext(member, date);
        }

        // コンテキスト付きでその他作業モーダルを開く
        function openOtherWorkModalWithContext(member, date) {
            // 担当者選択肢を更新
            const otherWorkMemberSelect = document.getElementById('otherWorkMember');
            if (otherWorkMemberSelect) {
                const allMembers = new Set();
                estimates.forEach(e => allMembers.add(e.member));
                actuals.forEach(a => allMembers.add(a.member));

                let sortedMembers;
                const memberOrderInput = document.getElementById('memberOrder').value.trim();
                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = orderList.filter(name => allMembers.has(name));
                    const unorderedMembers = Array.from(allMembers).filter(m => !orderedMembers.includes(m)).sort();
                    sortedMembers = [...orderedMembers, ...unorderedMembers];
                } else {
                    sortedMembers = Array.from(allMembers).sort();
                }

                otherWorkMemberSelect.innerHTML = '<option value="">選択...</option>';
                sortedMembers.forEach(m => {
                    const option = document.createElement('option');
                    option.value = m;
                    option.textContent = m;
                    otherWorkMemberSelect.appendChild(option);
                });

                // 担当者を選択
                otherWorkMemberSelect.value = member;
            }

            // 日付を保持（保存時に使用）
            document.getElementById('otherWorkModal').dataset.calendarDate = date;

            // モーダルのタイトルを更新
            const [year, month, day] = date.split('-');
            document.querySelector('#otherWorkModal .modal-header h3').textContent =
                `その他作業を登録 - ${member} (${year}/${parseInt(month)}/${parseInt(day)})`;

            document.getElementById('otherWorkModal').style.display = 'flex';
        }
        
        // 実績編集モーダルの対応名リストを更新（担当者に応じた未完了対応）
        function updateEditActualTaskList(member) {
            const select = document.getElementById('editActualTaskSelect');

            // この担当者の見積データを取得
            const memberEstimates = estimates.filter(e => e.member === member);

            // 実績工数を集計
            const actualTotals = {};
            actuals.forEach(a => {
                const key = `${a.version}_${a.task}_${a.process}`;
                actualTotals[key] = (actualTotals[key] || 0) + a.hours;
            });

            // 未完了対応を抽出
            const incompleteTasks = [];
            memberEstimates.forEach(est => {
                const key = `${est.version}_${est.task}_${est.process}`;
                const actualHours = actualTotals[key] || 0;

                if (actualHours < est.hours) {
                    const remaining = est.hours - actualHours;
                    incompleteTasks.push({
                        version: est.version,
                        task: est.task,
                        process: est.process,
                        remaining: remaining,
                        display: `${est.task} [${est.process}] (残: ${remaining.toFixed(1)}h)`
                    });
                }
            });

            // selectを更新
            select.innerHTML = '<option value="">-- 対応を選択 --</option>';
            incompleteTasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task.task;
                option.setAttribute('data-version', task.version);
                option.setAttribute('data-process', task.process);
                option.textContent = task.display;
                select.appendChild(option);
            });

            // 「新規入力」オプションを追加
            const newOption = document.createElement('option');
            newOption.value = '__NEW__';
            newOption.textContent = '新規入力...';
            select.appendChild(newOption);
        }
        
        // 作業詳細モーダルから編集
        function editActualFromModal(id) {
            closeWorkModal();
            editActual(id);
        }
        
        // 作業詳細モーダルから削除
        function deleteActualFromModal(id, member, date) {
            if (confirm('この実績を削除しますか？')) {
                actuals = actuals.filter(a => a.id !== id);
                saveData();
                renderActualList();
                renderTodayActuals();
                updateReport();
                
                // モーダルを更新（まだ他の作業がある場合）
                const remainingActuals = actuals.filter(a => a.member === member && a.date === date);
                if (remainingActuals.length > 0) {
                    showWorkDetail(member, date);
                } else {
                    closeWorkModal();
                }
            }
        }

        function editActual(id) {
            const actual = actuals.find(a => a.id === id);
            if (!actual) {
                alert('データが見つかりません');
                return;
            }
            
            // フォームに既存データを設定
            document.getElementById('editActualId').value = id;
            document.getElementById('editActualDate').value = actual.date;
            document.getElementById('editActualVersion').value = actual.version;

            // 既存の実績を編集する場合は、入力欄を表示して値を設定
            document.getElementById('editActualTaskSelect').style.display = 'none';
            document.getElementById('editActualTaskSearch').style.display = 'block';
            document.getElementById('editActualTaskSearch').value = actual.task;

            document.getElementById('editActualProcess').value = actual.process;
            document.getElementById('editActualHours').value = actual.hours;
            
            // 担当者選択肢を更新
            const memberSelect = document.getElementById('editActualMember');
            const allMembers = new Set();
            estimates.forEach(e => allMembers.add(e.member));
            actuals.forEach(a => allMembers.add(a.member));
            
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(allMembers).sort();
            }
            
            memberSelect.innerHTML = '';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                memberSelect.appendChild(option);
            });

            memberSelect.value = actual.member;

            // 編集時はセレクトを表示、表示用spanを非表示
            memberSelect.style.display = 'block';
            document.getElementById('editActualMemberDisplay').style.display = 'none';

            // 編集時は「その他作業」ボタンを非表示
            document.getElementById('editActualOtherBtn').style.display = 'none';

            // モーダルを表示
            document.getElementById('editActualModal').style.display = 'block';
        }

        function closeEditActualModal() {
            document.getElementById('editActualModal').style.display = 'none';
        }

        function saveActualEdit() {
            const id = parseFloat(document.getElementById('editActualId').value);
            const date = document.getElementById('editActualDate').value;
            const version = document.getElementById('editActualVersion').value;

            // selectまたはinputから対応名を取得
            const taskSelect = document.getElementById('editActualTaskSelect');
            const taskInput = document.getElementById('editActualTaskSearch');
            const task = taskSelect.style.display !== 'none' && taskSelect.value && taskSelect.value !== '__NEW__'
                ? taskSelect.value
                : taskInput.value;

            const process = document.getElementById('editActualProcess').value;
            const member = document.getElementById('editActualMember').value;
            const hours = parseFloat(document.getElementById('editActualHours').value);
            
            if (!date || !version || !task || !process || !member || !hours) {
                alert('すべての項目を入力してください');
                return;
            }

            // 新規登録か既存データの更新かを判定
            if (id && !isNaN(id)) {
                // 既存データの更新
                const actualIndex = actuals.findIndex(a => a.id === id);
                if (actualIndex !== -1) {
                    actuals[actualIndex] = {
                        ...actuals[actualIndex],
                        date: date,
                        version: version,
                        task: task,
                        process: process,
                        member: member,
                        hours: hours
                    };

                    saveData();
                    closeEditActualModal();

                    updateMonthOptions();
                    updateActualMonthOptions();
                    updateMemberOptions();
                    updateQuickTaskList();
                    renderTodayActuals();
                    renderActualList();
                    updateReport();

                    alert('実績データを更新しました');
                } else {
                    alert('データの更新に失敗しました');
                }
            } else {
                // 新規登録
                const newActual = {
                    id: Date.now() + Math.random(),
                    date: date,
                    version: version,
                    task: task,
                    process: process,
                    member: member,
                    hours: hours
                };

                actuals.push(newActual);

                saveData();
                closeEditActualModal();

                updateMonthOptions();
                updateActualMonthOptions();
                updateMemberOptions();
                updateQuickTaskList();
                renderTodayActuals();
                renderActualList();
                updateReport();

                alert('実績を登録しました');
            }
        }

        function editEstimate(id) {
            const estimate = estimates.find(e => e.id === id);
            if (!estimate) {
                alert('データが見つかりません');
                return;
            }
            
            // フォームに既存データを設定
            document.getElementById('editEstimateId').value = id;
            document.getElementById('editEstimateVersion').value = estimate.version;
            document.getElementById('editEstimateTaskSearch').value = estimate.task;
            document.getElementById('editEstimateProcess').value = estimate.process;
            document.getElementById('editEstimateHours').value = estimate.hours;
            
            // 対応名リストを生成
            const taskDatalist = document.getElementById('editEstimateTaskList');
            taskDatalist.innerHTML = '';
            const uniqueTasks = [...new Set([...estimates.map(e => e.task), ...actuals.map(a => a.task)])];
            uniqueTasks.sort().forEach(task => {
                const option = document.createElement('option');
                option.value = task;
                taskDatalist.appendChild(option);
            });
            
            // 担当者選択肢を更新
            const memberSelect = document.getElementById('editEstimateMember');
            const allMembers = new Set();
            estimates.forEach(e => allMembers.add(e.member));
            actuals.forEach(a => allMembers.add(a.member));
            
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(allMembers).sort();
            }
            
            memberSelect.innerHTML = '';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                memberSelect.appendChild(option);
            });
            
            memberSelect.value = estimate.member;
            
            // モーダルを表示
            document.getElementById('editEstimateModal').style.display = 'block';
        }

        function closeEditEstimateModal() {
            document.getElementById('editEstimateModal').style.display = 'none';
        }

        function saveEstimateEdit() {
            const id = parseFloat(document.getElementById('editEstimateId').value);
            const version = document.getElementById('editEstimateVersion').value;
            const task = document.getElementById('editEstimateTaskSearch').value;
            const process = document.getElementById('editEstimateProcess').value;
            const member = document.getElementById('editEstimateMember').value;
            const hours = parseFloat(document.getElementById('editEstimateHours').value);
            
            if (!version || !task || !process || !member || !hours) {
                alert('すべての項目を入力してください');
                return;
            }
            
            // データを更新
            const estimateIndex = estimates.findIndex(e => e.id === id);
            if (estimateIndex !== -1) {
                estimates[estimateIndex] = {
                    ...estimates[estimateIndex],
                    version: version,
                    task: task,
                    process: process,
                    member: member,
                    hours: hours
                };
                
                saveData();
                closeEditEstimateModal();
                
                updateMemberOptions();
                updateQuickTaskList();
                renderEstimateList();
                updateReport();
                
                alert('見積データを更新しました');
            } else {
                alert('データの更新に失敗しました');
            }
        }

        function handleActualTaskSelect() {
            const select = document.getElementById('editActualTaskSelect');
            const input = document.getElementById('editActualTaskSearch');
            const selectedOption = select.options[select.selectedIndex];

            if (select.value === '__NEW__') {
                // 新規入力モード
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            } else if (select.value) {
                // 既存の対応を選択
                const version = selectedOption.getAttribute('data-version');
                const process = selectedOption.getAttribute('data-process');

                if (version) {
                    document.getElementById('editActualVersion').value = version;
                }
                if (process) {
                    document.getElementById('editActualProcess').value = process;
                }
            }
        }

        function handleActualTaskInput() {
            // 新規入力時の処理（将来的に拡張可能）
        }

        function handleEstimateTaskInput() {
            // 対応名入力時の処理（将来的に拡張可能）
        }

        function showMemberOrderHelp() {
            alert('担当者の表示順を指定できます。\n\n例:\nA,B,C,D\n山田,佐藤,田中\n\n・カンマ区切りで入力\n・指定した順番で表示されます\n・指定していない担当者は後ろにアルファベット順で表示されます');
        }

        function updateAllDisplays() {
            saveData();
            updateMemberOptions();
            renderActualList();
            updateReport();
            alert('設定を適用しました');
        }
        
        // テーマ関連の関数
        function loadThemeSettings() {
            // データから読み込み（優先）
            const savedSettings = localStorage.getItem('manhour_settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.themeColor) {
                    currentThemeColor = settings.themeColor;
                    document.getElementById('themeColor').value = settings.themeColor;
                }
                if (settings.themePattern) {
                    currentThemePattern = settings.themePattern;
                    document.getElementById('themePattern').value = settings.themePattern;
                }
                if (settings.themeTabColor) {
                    currentTabColor = settings.themeTabColor;
                    document.getElementById('themeTabColor').value = settings.themeTabColor;
                }
                if (settings.themeBackgroundColor) {
                    currentBackgroundColor = settings.themeBackgroundColor;
                    document.getElementById('themeBackgroundColor').value = settings.themeBackgroundColor;
                }
            } else {
                // 旧形式から読み込み（後方互換性）
                const savedColor = localStorage.getItem('manhour_themeColor');
                const savedPattern = localStorage.getItem('manhour_themePattern');
                const savedTabColor = localStorage.getItem('manhour_themeTabColor');
                
                if (savedColor) {
                    currentThemeColor = savedColor;
                    document.getElementById('themeColor').value = savedColor;
                }
                
                if (savedPattern) {
                    currentThemePattern = savedPattern;
                    document.getElementById('themePattern').value = savedPattern;
                }
                
                if (savedTabColor) {
                    currentTabColor = savedTabColor;
                    document.getElementById('themeTabColor').value = savedTabColor;
                }
            }
            
            applyTheme();
        }
        
        function applyTheme() {
            const color = document.getElementById('themeColor').value;
            const pattern = document.getElementById('themePattern').value;
            const tabColor = document.getElementById('themeTabColor').value;
            const backgroundColor = document.getElementById('themeBackgroundColor').value;
            
            currentThemeColor = color;
            currentThemePattern = pattern;
            currentTabColor = tabColor;
            currentBackgroundColor = backgroundColor;
            
            // プレビューを更新
            updateThemePreview();
            
            // 全ての該当要素にテーマを適用
            updateThemeElements();
            
            // データに保存
            saveData(true); // 自動バックアップはスキップ
        }
        
        function updateThemePreview() {
            const preview = document.getElementById('themePreview');
            const colorClass = `theme-${currentThemeColor}`;
            const patternClass = currentThemePattern !== 'none' ? `pattern-${currentThemePattern}` : '';
            
            // 既存のクラスを削除
            preview.className = '';
            preview.classList.add('theme-bg', colorClass);
            if (patternClass) {
                preview.classList.add(patternClass);
            }
        }
        
        function updateThemeElements() {
            // ページ全体の背景
            updateBodyBackground();

            // クイック入力エリア
            const quickInput = document.querySelector('.quick-input');
            if (quickInput) {
                updateElementTheme(quickInput);
            }

            // レポートサマリーカード
            const summaryCards = document.querySelectorAll('.stats-grid .stat-card');
            summaryCards.forEach(card => updateElementTheme(card));

            // 版数ヘッダー
            const versionHeaders = document.querySelectorAll('.version-header');
            versionHeaders.forEach(header => updateElementTheme(header));

            // アクティブタブ
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                updateElementTheme(activeTab);
            }

            // モーダルヘッダー
            const modalHeaders = document.querySelectorAll('.modal-header');
            modalHeaders.forEach(header => {
                // 既存のモーダルテーマクラスを削除
                header.className = header.className.replace(/modal-theme-\w+/g, '').trim();
                header.classList.add('modal-header', `modal-theme-${currentThemeColor}`);
            });

            // 設定タブのレイアウト切り替えボタン
            updateLayoutToggleButtons();

            // セグメントボタンの色を更新
            updateSegmentedButtons();

            // 見積合計カードの色を更新
            const estimateTotalCard = document.getElementById('estimateTotalCard');
            if (estimateTotalCard) {
                const gradients = {
                    'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                    'teal': 'linear-gradient(135deg, #0f766e 0%, #0d9488 100%)',
                    'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                    'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #075985 100%)',
                    'sky': 'linear-gradient(135deg, #0369a1 0%, #0284c7 100%)',
                    'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                    'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                    'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                    'green': 'linear-gradient(135deg, #047857 0%, #059669 100%)',
                    'emerald': 'linear-gradient(135deg, #059669 0%, #10b981 100%)'
                };
                estimateTotalCard.style.background = gradients[currentThemeColor] || gradients['purple'];
            }
        }
        
        function updateBodyBackground() {
            const colorGradients = {
                'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                'teal': 'linear-gradient(135deg, #0f766e 0%, #14b8a6 100%)',
                'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%)',
                'sky': 'linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%)',
                'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                'green': 'linear-gradient(135deg, #047857 0%, #10b981 100%)',
                'emerald': 'linear-gradient(135deg, #059669 0%, #34d399 100%)'
            };
            
            // 背景色を決定（個別設定がある場合はそれを使用、なければメインカラー）
            const bgColorToUse = (currentBackgroundColor && currentBackgroundColor !== 'same') 
                ? currentBackgroundColor 
                : currentThemeColor;
            
            const gradient = colorGradients[bgColorToUse] || colorGradients['purple'];
            document.body.style.background = gradient;
        }
        
        function updateElementTheme(element) {
            const isTab = element.classList.contains('tab');
            
            // タブの色を決定
            let tabColorToUse = currentThemeColor;
            if (isTab) {
                if (currentTabColor === 'same') {
                    tabColorToUse = currentThemeColor;
                } else if (currentTabColor === 'default') {
                    // デフォルト色の場合は何もクラスを追加しない
                    tabColorToUse = null;
                } else {
                    tabColorToUse = currentTabColor;
                }
            }
            
            const colorClass = isTab && tabColorToUse ? `tab-theme-${tabColorToUse}` : `theme-${currentThemeColor}`;
            const patternClass = !isTab && currentThemePattern !== 'none' ? `pattern-${currentThemePattern}` : '';
            
            // theme-で始まるクラス、tab-theme-で始まるクラス、pattern-で始まるクラスを削除
            const classes = Array.from(element.classList);
            classes.forEach(cls => {
                if (cls.startsWith('theme-') || cls.startsWith('pattern-') || cls.startsWith('tab-theme-')) {
                    element.classList.remove(cls);
                }
            });
            
            // 新しいテーマを適用
            if (isTab) {
                // タブの場合
                if (tabColorToUse) {
                    // 色指定あり: tab-theme-クラスを追加
                    element.classList.add(`tab-theme-${tabColorToUse}`);
                }
                // currentTabColor === 'default'の場合は何も追加しない（CSSのフォールバックが適用される）
            } else {
                // タブ以外: theme-bgと色クラスを適用
                element.classList.add('theme-bg', colorClass);
                if (patternClass) {
                    element.classList.add(patternClass);
                }
            }
        }

        // 設定タブのレイアウト切り替えボタンの色を更新
        function updateLayoutToggleButtons() {
            const themeColor = getThemeColor();

            // 見積一覧のボタン
            const estimateButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'estimate\'"]');
            if (estimateButtons.length >= 2) {
                const estimateCompact = document.getElementById('estimateFiltersCompact');
                const isCompactActive = estimateCompact && estimateCompact.style.display !== 'none';
                estimateButtons[0].style.background = isCompactActive ? themeColor : 'white';
                estimateButtons[0].style.color = isCompactActive ? 'white' : '#333';
                estimateButtons[1].style.background = !isCompactActive ? themeColor : 'white';
                estimateButtons[1].style.color = !isCompactActive ? 'white' : '#333';
            }

            // 実績一覧のボタン
            const actualButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'actual\'"]');
            if (actualButtons.length >= 2) {
                const actualCompact = document.getElementById('actualFiltersCompact');
                const isCompactActive = actualCompact && actualCompact.style.display !== 'none';
                actualButtons[0].style.background = isCompactActive ? themeColor : 'white';
                actualButtons[0].style.color = isCompactActive ? 'white' : '#333';
                actualButtons[1].style.background = !isCompactActive ? themeColor : 'white';
                actualButtons[1].style.color = !isCompactActive ? 'white' : '#333';
            }

            // レポートのボタン
            const reportButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'report\'"]');
            if (reportButtons.length >= 2) {
                const reportCompact = document.getElementById('reportFiltersCompact');
                const isCompactActive = reportCompact && reportCompact.style.display !== 'none';
                reportButtons[0].style.background = isCompactActive ? themeColor : 'white';
                reportButtons[0].style.color = isCompactActive ? 'white' : '#333';
                reportButtons[1].style.background = !isCompactActive ? themeColor : 'white';
                reportButtons[1].style.color = !isCompactActive ? 'white' : '#333';
            }
        }

        // セグメントボタンの色を更新
        function updateSegmentedButtons() {
            const themeColor = getThemeColor();

            // 見積一覧のセグメントボタン（表示形式）
            const btnEstimateGrouped = document.getElementById('btnEstimateGrouped');
            const btnEstimateMatrix = document.getElementById('btnEstimateMatrix');
            const btnEstimateList = document.getElementById('btnEstimateList');
            if (btnEstimateGrouped && btnEstimateMatrix && btnEstimateList) {
                const estimateViewType = document.getElementById('estimateViewType').value;
                btnEstimateGrouped.style.background = estimateViewType === 'grouped' ? themeColor : 'white';
                btnEstimateGrouped.style.color = estimateViewType === 'grouped' ? 'white' : '#333';
                btnEstimateMatrix.style.background = estimateViewType === 'matrix' ? themeColor : 'white';
                btnEstimateMatrix.style.color = estimateViewType === 'matrix' ? 'white' : '#333';
                btnEstimateList.style.background = estimateViewType === 'list' ? themeColor : 'white';
                btnEstimateList.style.color = estimateViewType === 'list' ? 'white' : '#333';
            }

            // 見積一覧のセグメントボタン（表示月）
            const estimateMonthButtons = document.getElementById('estimateMonthButtons2');
            if (estimateMonthButtons) {
                const estimateMonthFilter = document.getElementById('estimateMonthFilter');
                if (estimateMonthFilter) {
                    updateSegmentButtonSelection('estimateMonthButtons2', estimateMonthFilter.value);
                }
            }

            // 実績一覧のセグメントボタン（表示形式）
            const btnActualMatrix = document.getElementById('btnActualMatrix');
            const btnActualList = document.getElementById('btnActualList');
            if (btnActualMatrix && btnActualList) {
                const actualViewType = document.getElementById('actualViewType').value;
                btnActualMatrix.style.background = actualViewType === 'matrix' ? themeColor : 'white';
                btnActualMatrix.style.color = actualViewType === 'matrix' ? 'white' : '#333';
                btnActualList.style.background = actualViewType === 'list' ? themeColor : 'white';
                btnActualList.style.color = actualViewType === 'list' ? 'white' : '#333';
            }

            // 実績一覧のセグメントボタン（担当者）
            const actualMemberButtons = document.getElementById('actualMemberButtons2');
            if (actualMemberButtons) {
                const actualMemberSelect = document.getElementById('actualMemberSelect');
                if (actualMemberSelect) {
                    updateSegmentButtonSelection('actualMemberButtons2', actualMemberSelect.value);
                }
            }

            // 実績一覧のセグメントボタン（表示期間）
            const actualMonthButtons = document.getElementById('actualMonthButtons2');
            if (actualMonthButtons) {
                const actualMonthFilter = document.getElementById('actualMonthFilter');
                if (actualMonthFilter) {
                    updateSegmentButtonSelection('actualMonthButtons2', actualMonthFilter.value);
                }
            }

            // レポートのセグメントボタン（表示形式）
            const btnReportSummary = document.getElementById('btnReportSummary');
            const btnReportGrouped = document.getElementById('btnReportGrouped');
            const btnReportMatrix = document.getElementById('btnReportMatrix');
            if (btnReportSummary && btnReportGrouped && btnReportMatrix) {
                const reportViewType = document.getElementById('reportViewType').value;
                btnReportSummary.style.background = reportViewType === 'summary' ? themeColor : 'white';
                btnReportSummary.style.color = reportViewType === 'summary' ? 'white' : '#333';
                btnReportGrouped.style.background = reportViewType === 'grouped' ? themeColor : 'white';
                btnReportGrouped.style.color = reportViewType === 'grouped' ? 'white' : '#333';
                btnReportMatrix.style.background = reportViewType === 'matrix' ? themeColor : 'white';
                btnReportMatrix.style.color = reportViewType === 'matrix' ? 'white' : '#333';
            }

            // レポートのセグメントボタン（表示月）
            const reportMonthButtons = document.getElementById('reportMonthButtons2');
            if (reportMonthButtons) {
                const reportMonth = document.getElementById('reportMonth');
                if (reportMonth) {
                    updateSegmentButtonSelection('reportMonthButtons2', reportMonth.value);
                }
            }
        }

        // モーダル外をクリック/タップで閉じる
        function handleModalClose(event) {
            const workModal = document.getElementById('workModal');
            const editActualModal = document.getElementById('editActualModal');
            const editEstimateModal = document.getElementById('editEstimateModal');
            const splitEstimateModal = document.getElementById('splitEstimateModal');
            const otherWorkModal = document.getElementById('otherWorkModal');

            if (event.target === workModal) {
                event.stopPropagation();
                event.preventDefault();
                closeWorkModal();
            }
            if (event.target === editActualModal) {
                event.stopPropagation();
                event.preventDefault();
                closeEditActualModal();
            }
            if (event.target === editEstimateModal) {
                event.stopPropagation();
                event.preventDefault();
                closeEditEstimateModal();
            }
            if (event.target === splitEstimateModal) {
                event.stopPropagation();
                event.preventDefault();
                closeSplitEstimateModal();
            }
            if (event.target === otherWorkModal) {
                event.stopPropagation();
                event.preventDefault();
                closeOtherWorkModal();
            }
        }
        
        window.onclick = handleModalClose;
        window.ontouchend = handleModalClose;

        // 作業月割り当てモードを閉じる
        function closeWorkMonthAssignmentMode() {
            if (workMonthSelectionMode) {
                const checkbox1 = document.getElementById('workMonthSelectionMode');
                const checkbox2 = document.getElementById('workMonthSelectionMode2');
                if (checkbox1) checkbox1.checked = false;
                if (checkbox2) checkbox2.checked = false;
                toggleWorkMonthSelectionMode();
            }
        }

        // セグメントボタンを生成する汎用関数
        function createSegmentButtons(containerId, selectId, items, currentValue, maxItems, onClickHandler) {
            const container = document.getElementById(containerId);
            const select = document.getElementById(selectId);
            const themeColor = getThemeColor();

            if (!container || !select) return;

            // セグメントボタンを表示（横スクロール対応）
            container.style.display = 'flex';
            container.style.overflowX = 'auto';
            container.style.gap = '0';
            select.style.display = 'none';
            container.innerHTML = '';

            items.forEach((item, index) => {
                const button = document.createElement('button');
                button.textContent = item.label;
                button.value = item.value;
                button.style.cssText = `
                    padding: 4px 12px;
                    font-size: 12px;
                    border: none;
                    cursor: pointer;
                    transition: all 0.2s;
                    white-space: nowrap;
                    flex-shrink: 0;
                    ${index > 0 ? 'border-left: 1px solid #dee2e6;' : ''}
                `;

                // 選択状態のスタイル
                if (item.value === currentValue) {
                    button.style.background = themeColor;
                    button.style.color = 'white';
                } else {
                    button.style.background = 'white';
                    button.style.color = '#333';
                }

                button.onclick = () => onClickHandler(item.value, containerId);
                container.appendChild(button);
            });
        }

        // セグメントボタンの選択状態を更新
        function updateSegmentButtonSelection(containerId, value) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const themeColor = getThemeColor();
            const buttons = container.querySelectorAll('button');
            buttons.forEach(btn => {
                if (btn.value === value) {
                    btn.style.background = themeColor;
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'white';
                    btn.style.color = '#333';
                }
            });
        }

        // 実績一覧の担当者選択ハンドラー
        function handleActualMemberChange(value, containerId) {
            document.getElementById('actualMemberSelect').value = value;
            document.getElementById('actualMemberSelect2').value = value;
            updateSegmentButtonSelection(containerId, value);
            renderActualList();
        }

        // 実績一覧の月選択ハンドラー
        function handleActualMonthChange(value, containerId) {
            document.getElementById('actualMonthFilter').value = value;
            document.getElementById('actualMonthFilter2').value = value;
            updateSegmentButtonSelection(containerId, value);
            renderActualList();
        }

        // 見積一覧の月選択ハンドラー
        function handleEstimateMonthChange(value, containerId) {
            const filterElement = document.getElementById('estimateMonthFilter');
            if (filterElement) {
                filterElement.value = value;
            }
            updateSegmentButtonSelection(containerId, value);
            renderEstimateList();
        }

        // レポートの月選択ハンドラー
        function handleReportMonthChange(value, containerId) {
            document.getElementById('reportMonth').value = value;
            document.getElementById('reportMonth2').value = value;
            updateSegmentButtonSelection(containerId, value);
            updateReport();
        }

        // テーマカラーから実際の色を取得するヘルパー関数
        function getThemeColor() {
            const themeColors = {
                'purple': '#667eea',
                'deep-blue': '#1e3c72',
                'teal': '#0f766e',
                'cyan': '#0891b2',
                'ocean': '#0c4a6e',
                'sky': '#0369a1',
                'indigo': '#4338ca',
                'navy': '#1e40af',
                'slate': '#334155',
                'green': '#047857',
                'emerald': '#059669'
            };
            return themeColors[currentThemeColor] || '#667eea';
        }

        // セグメントボタン用の関数（見積一覧）
        function setEstimateViewType(type) {
            const viewTypeElement = document.getElementById('estimateViewType');
            if (viewTypeElement) {
                viewTypeElement.value = type;
            }

            // ボタンのスタイルを更新
            const themeColor = getThemeColor();
            const btnGrouped = document.getElementById('btnEstimateGrouped');
            const btnMatrix = document.getElementById('btnEstimateMatrix');
            const btnList = document.getElementById('btnEstimateList');

            if (btnGrouped) {
                btnGrouped.style.background = type === 'grouped' ? themeColor : 'white';
                btnGrouped.style.color = type === 'grouped' ? 'white' : '#333';
            }
            if (btnMatrix) {
                btnMatrix.style.background = type === 'matrix' ? themeColor : 'white';
                btnMatrix.style.color = type === 'matrix' ? 'white' : '#333';
            }
            if (btnList) {
                btnList.style.background = type === 'list' ? themeColor : 'white';
                btnList.style.color = type === 'list' ? 'white' : '#333';
            }

            renderEstimateList();
        }

        // セグメントボタン用の関数（実績一覧）
        function setActualViewType(type) {
            document.getElementById('actualViewType').value = type;
            // ボタンのスタイルを更新
            const themeColor = getThemeColor();
            const btnMatrix = document.getElementById('btnActualMatrix');
            const btnList = document.getElementById('btnActualList');
            if (type === 'matrix') {
                btnMatrix.style.background = themeColor;
                btnMatrix.style.color = 'white';
                btnList.style.background = 'white';
                btnList.style.color = '#333';
            } else {
                btnMatrix.style.background = 'white';
                btnMatrix.style.color = '#333';
                btnList.style.background = themeColor;
                btnList.style.color = 'white';
            }
            renderActualList();
        }

        // セグメントボタン用の関数（レポート）
        function setReportViewType(type) {
            document.getElementById('reportViewType').value = type;
            // ボタンのスタイルを更新
            const themeColor = getThemeColor();
            const btnSummary = document.getElementById('btnReportSummary');
            const btnGrouped = document.getElementById('btnReportGrouped');
            const btnMatrix = document.getElementById('btnReportMatrix');
            btnSummary.style.background = type === 'summary' ? themeColor : 'white';
            btnSummary.style.color = type === 'summary' ? 'white' : '#333';
            btnGrouped.style.background = type === 'grouped' ? themeColor : 'white';
            btnGrouped.style.color = type === 'grouped' ? 'white' : '#333';
            btnMatrix.style.background = type === 'matrix' ? themeColor : 'white';
            btnMatrix.style.color = type === 'matrix' ? 'white' : '#333';
            updateReport();
        }

        // レイアウト設定を適用
        function applyLayoutSettings() {
            // 見積一覧のレイアウトを適用
            const estimateCompact = document.getElementById('estimateFiltersCompact');
            const estimateSegmented = document.getElementById('estimateFiltersSegmented');
            if (estimateLayout === 'compact') {
                if (estimateCompact) estimateCompact.style.display = 'flex';
                if (estimateSegmented) estimateSegmented.style.display = 'none';
            } else {
                if (estimateCompact) estimateCompact.style.display = 'none';
                if (estimateSegmented) estimateSegmented.style.display = 'block';
            }

            // 実績一覧のレイアウトを適用
            const actualCompact = document.getElementById('actualFiltersCompact');
            const actualSegmented = document.getElementById('actualFiltersSegmented');
            if (actualLayout === 'compact') {
                if (actualCompact) actualCompact.style.display = 'flex';
                if (actualSegmented) actualSegmented.style.display = 'none';
            } else {
                if (actualCompact) actualCompact.style.display = 'none';
                if (actualSegmented) actualSegmented.style.display = 'block';
            }

            // レポートのレイアウトを適用
            const reportCompact = document.getElementById('reportFiltersCompact');
            const reportSegmented = document.getElementById('reportFiltersSegmented');
            if (reportLayout === 'compact') {
                if (reportCompact) reportCompact.style.display = 'flex';
                if (reportSegmented) reportSegmented.style.display = 'none';
            } else {
                if (reportCompact) reportCompact.style.display = 'none';
                if (reportSegmented) reportSegmented.style.display = 'block';
            }

            // 設定タブのボタンの状態を更新
            updateLayoutToggleButtons();
        }

        // レイアウト切り替え関数（開発/比較用）
        function toggleFilterLayout(page, version) {
            const themeColor = getThemeColor();

            if (page === 'estimate') {
                const compact = document.getElementById('estimateFiltersCompact');
                const segmented = document.getElementById('estimateFiltersSegmented');

                // 設定タブのボタンを更新
                const settingsButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'estimate\'"]');
                const btnCompact = settingsButtons[0];
                const btnSegmented = settingsButtons[1];

                if (version === 'compact') {
                    compact.style.display = 'flex';
                    segmented.style.display = 'none';
                    btnCompact.style.background = themeColor;
                    btnCompact.style.color = 'white';
                    btnSegmented.style.background = 'white';
                    btnSegmented.style.color = '#333';
                    estimateLayout = 'compact';
                    renderEstimateList();
                } else {
                    const viewType = document.getElementById('estimateViewType').value;
                    setEstimateViewType(viewType);
                    compact.style.display = 'none';
                    segmented.style.display = 'block';
                    btnCompact.style.background = 'white';
                    btnCompact.style.color = '#333';
                    btnSegmented.style.background = themeColor;
                    btnSegmented.style.color = 'white';
                    estimateLayout = 'segmented';
                }
                saveData(true);
            } else if (page === 'actual') {
                const compact = document.getElementById('actualFiltersCompact');
                const segmented = document.getElementById('actualFiltersSegmented');

                // 設定タブのボタンを更新
                const settingsButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'actual\'"]');
                const btnCompact = settingsButtons[0];
                const btnSegmented = settingsButtons[1];

                if (version === 'compact') {
                    // セグメント→コンパクトへ切り替え時、値を同期
                    document.getElementById('actualViewMode').value = document.getElementById('actualViewMode2').value;
                    document.getElementById('actualMemberSelect').value = document.getElementById('actualMemberSelect2').value;
                    document.getElementById('actualMonthFilter').value = document.getElementById('actualMonthFilter2').value;
                    compact.style.display = 'flex';
                    segmented.style.display = 'none';
                    btnCompact.style.background = themeColor;
                    btnCompact.style.color = 'white';
                    btnSegmented.style.background = 'white';
                    btnSegmented.style.color = '#333';
                    // グローバル変数を更新
                    actualLayout = 'compact';
                    // 集計を更新
                    renderActualList();
                } else {
                    // コンパクト→セグメントへ切り替え時、値を同期
                    document.getElementById('actualViewMode2').value = document.getElementById('actualViewMode').value;
                    document.getElementById('actualMemberSelect2').value = document.getElementById('actualMemberSelect').value;
                    document.getElementById('actualMonthFilter2').value = document.getElementById('actualMonthFilter').value;
                    // セグメントボタンの状態を同期（setActualViewType内でrenderActualListが呼ばれる）
                    const viewType = document.getElementById('actualViewType').value;
                    setActualViewType(viewType);
                    compact.style.display = 'none';
                    segmented.style.display = 'block';
                    btnCompact.style.background = 'white';
                    btnCompact.style.color = '#333';
                    btnSegmented.style.background = themeColor;
                    btnSegmented.style.color = 'white';
                    // グローバル変数を更新
                    actualLayout = 'segmented';
                }
                // 設定を保存
                saveData(true);
            } else if (page === 'report') {
                const compact = document.getElementById('reportFiltersCompact');
                const segmented = document.getElementById('reportFiltersSegmented');

                // 設定タブのボタンを更新
                const settingsButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'report\'"]');
                const btnCompact = settingsButtons[0];
                const btnSegmented = settingsButtons[1];

                if (version === 'compact') {
                    // セグメント→コンパクトへ切り替え時、値を同期
                    document.getElementById('reportMonth').value = document.getElementById('reportMonth2').value;
                    compact.style.display = 'flex';
                    segmented.style.display = 'none';
                    btnCompact.style.background = themeColor;
                    btnCompact.style.color = 'white';
                    btnSegmented.style.background = 'white';
                    btnSegmented.style.color = '#333';
                    // グローバル変数を更新
                    reportLayout = 'compact';
                    // 集計を更新
                    updateReport();
                } else {
                    // コンパクト→セグメントへ切り替え時、値を同期
                    document.getElementById('reportMonth2').value = document.getElementById('reportMonth').value;
                    // セグメントボタンの状態を同期（setReportViewType内でupdateReportが呼ばれる）
                    const viewType = document.getElementById('reportViewType').value;
                    setReportViewType(viewType);
                    compact.style.display = 'none';
                    segmented.style.display = 'block';
                    btnCompact.style.background = 'white';
                    btnCompact.style.color = '#333';
                    btnSegmented.style.background = themeColor;
                    btnSegmented.style.color = 'white';
                    // グローバル変数を更新
                    reportLayout = 'segmented';
                }
                // 設定を保存
                saveData(true);
            }
        }

        function updateReport() {
            const selectedMonth = document.getElementById('reportMonth').value;
            const viewType = document.getElementById('reportViewType').value;
            
            // 実績のフィルタリング
            let filteredActuals = actuals;
            if (selectedMonth !== 'all') {
                // 選択月の実績 + その月の「その他付随作業」を含める
                filteredActuals = actuals.filter(a => {
                    // その他付随作業は日付が選択月のものを含める
                    if (isOtherWork(a)) {
                        return a.date && a.date.startsWith(selectedMonth);
                    }
                    // 通常の作業は日付が選択月のものを含める
                    return a.date && a.date.startsWith(selectedMonth);
                });
            }
            
            // 見積のフィルタリング（作業予定月で絞り込み）
            let filteredEstimates = estimates;
            if (selectedMonth !== 'all') {
                // 複数月対応: workMonthsに含まれる見積をフィルタ
                filteredEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.includes(selectedMonth);
                }).map(e => {
                    // 月別工数を使用
                    const est = normalizeEstimate(e);
                    return {
                        ...est,
                        hours: est.monthlyHours[selectedMonth] || est.hours
                    };
                });
            } else {
                // 全期間の場合は正規化のみ
                filteredEstimates = estimates.map(e => normalizeEstimate(e));
            }
            
            // デバッグ情報（コンソール出力）
            if (selectedMonth !== 'all') {
                console.log('=== レポート集計デバッグ ===');
                console.log('選択月:', selectedMonth);
                console.log('全見積数:', estimates.length);
                console.log('フィルタ後見積数:', filteredEstimates.length);
                console.log('全実績数:', actuals.length);
                console.log('フィルタ後実績数:', filteredActuals.length);
                
                // 作業予定月が未設定または空文字の見積を確認
                const noWorkMonthEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.length === 0;
                });
                if (noWorkMonthEstimates.length > 0) {
                    console.log('⚠️ 作業予定月が未設定の見積:', noWorkMonthEstimates.length, '件');
                    console.log('  これらの見積は月別集計に含まれません');
                    console.log('  詳細:', noWorkMonthEstimates.map(e => ({
                        version: e.version,
                        task: e.task,
                        workMonths: normalizeEstimate(e).workMonths
                    })));
                }
                
                // 選択月とは異なる作業予定月の見積を確認
                const otherMonthEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.length > 0 && !est.workMonths.includes(selectedMonth);
                });
                if (otherMonthEstimates.length > 0) {
                    console.log('ℹ️ 他の月に予定されている見積:', otherMonthEstimates.length, '件');
                    const monthCounts = {};
                    otherMonthEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        est.workMonths.forEach(m => {
                            monthCounts[m] = (monthCounts[m] || 0) + 1;
                        });
                    });
                    console.log('  月別内訳:', monthCounts);
                }
                
                // 複数月見積の情報
                const multiMonthEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.length > 1 && est.workMonths.includes(selectedMonth);
                });
                if (multiMonthEstimates.length > 0) {
                    console.log('📅 複数月見積（選択月を含む）:', multiMonthEstimates.length, '件');
                    multiMonthEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        console.log(`  ${est.version} - ${est.task} [${est.process}]:`, est.monthlyHours);
                    });
                }
                
                // 選択月の実績があるが見積がない対応を確認
                const actualTasks = new Set(filteredActuals.map(a => `${a.version}-${a.task}`));
                const estimateTasks = new Set(filteredEstimates.map(e => `${e.version}-${e.task}`));
                const actualOnlyTasks = [...actualTasks].filter(t => !estimateTasks.has(t));
                if (actualOnlyTasks.length > 0) {
                    console.log('ℹ️ 実績のみで見積がない対応:', actualOnlyTasks);
                    console.log('  理由: 見積の作業予定月が設定されていないか、別の月に設定されています');
                }
                
                // 選択月の見積があるが実績がない対応を確認
                const estimateOnlyTasks = [...estimateTasks].filter(t => !actualTasks.has(t));
                if (estimateOnlyTasks.length > 0) {
                    console.log('ℹ️ 見積のみで実績がない対応:', estimateOnlyTasks);
                }
            }
            
            // タイトル更新
            const titleElement = document.getElementById('reportPeriodTitle');
            if (selectedMonth === 'all') {
                titleElement.textContent = '全期間の集計';
            } else {
                const [year, month] = selectedMonth.split('-');
                titleElement.textContent = `${year}年${parseInt(month)}月の集計`;
            }
            
            const totalEst = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
            const totalAct = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
            const diff = totalAct - totalEst;
            const rate = totalEst > 0 ? (totalAct / totalEst * 100).toFixed(1) : 0;

            // 人日と人月の計算（実働日数ベース）
            let workingDaysPerMonth = 20; // デフォルト
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                workingDaysPerMonth = getWorkingDays(parseInt(year), parseInt(month));
            }
            const estManDays = (totalEst / 8).toFixed(1);
            const estManMonths = (totalEst / 8 / workingDaysPerMonth).toFixed(2);
            const actManDays = (totalAct / 8).toFixed(1);
            const actManMonths = (totalAct / 8 / workingDaysPerMonth).toFixed(2);

            document.getElementById('totalEstimate').textContent = totalEst.toFixed(1) + 'h';
            document.getElementById('totalActual').textContent = totalAct.toFixed(1) + 'h';
            document.getElementById('totalDiff').textContent = (diff >= 0 ? '+' : '') + diff.toFixed(1) + 'h';
            document.getElementById('actualRate').textContent = rate + '%';
            
            // 補足情報として人日・人月を表示
            document.getElementById('totalEstimateManpower').textContent = `${estManDays}人日 / ${estManMonths}人月`;
            document.getElementById('totalActualManpower').textContent = `${actManDays}人日 / ${actManMonths}人月`;

            // レポート詳細ビューをクリア
            document.getElementById('reportDetailView').innerHTML = '';

            // 分析機能の表示
            renderReportAnalytics(filteredActuals, filteredEstimates, selectedMonth, workingDaysPerMonth);

            // 詳細ビュー表示
            if (viewType === 'grouped') {
                renderReportGrouped(filteredActuals, filteredEstimates);
            } else if (viewType === 'matrix') {
                renderReportMatrix(filteredActuals, filteredEstimates);
            }
            // viewTypeがnoneの場合は何もしない（分析パネルは保持される）

            renderMemberReport(filteredActuals, filteredEstimates);
            renderVersionReport(filteredActuals, filteredEstimates);
        }

        function renderReportAnalytics(filteredActuals, filteredEstimates, selectedMonth, workingDaysPerMonth) {
            const container = document.getElementById('reportDetailView');
            let html = '';

            // Phase 1: 見積精度と異常値表示
            if (reportSettings.accuracyEnabled || reportSettings.anomalyEnabled || reportSettings.warningTasksEnabled) {
                html += '<div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 12px; margin: 20px 0; color: white;">';
                html += '<h3 style="margin: 0 0 15px 0; color: white;">📊 Phase 1: 見積精度分析</h3>';

                // 工程別の精度計算
                if (reportSettings.accuracyEnabled) {
                    const processSummary = {};
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

                    filteredEstimates.forEach(e => {
                        const processKey = processOrder.includes(e.process) ? e.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].estimate += e.hours;
                    });

                    filteredActuals.forEach(a => {
                        const processKey = processOrder.includes(a.process) ? a.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].actual += a.hours;
                    });

                    html += '<div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
                    html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">工程別見積精度</h4>';
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">';

                    const sortedProcesses = [
                        ...processOrder.filter(p => processSummary[p]),
                        ...(processSummary['その他'] ? ['その他'] : [])
                    ];

                    sortedProcesses.forEach(proc => {
                        const data = processSummary[proc];
                        const accuracy = data.estimate > 0 ? (data.actual / data.estimate * 100).toFixed(1) : 0;
                        const isOverrun = accuracy > 150;
                        const isGood = accuracy >= 80 && accuracy <= 120;

                        html += '<div style="background: rgba(255,255,255,0.2); padding: 10px; border-radius: 6px; text-align: center;">';
                        html += `<div style="font-weight: 600; margin-bottom: 5px;">${proc}</div>`;
                        html += `<div style="font-size: 20px; font-weight: bold; color: ${isOverrun ? '#ff6b6b' : isGood ? '#51cf66' : '#ffd43b'};">${accuracy}%</div>`;
                        html += `<div style="font-size: 12px; opacity: 0.9;">${data.estimate.toFixed(1)}h → ${data.actual.toFixed(1)}h</div>`;
                        html += '</div>';
                    });

                    html += '</div></div>';
                }

                // 異常値の強調表示
                if (reportSettings.anomalyEnabled) {
                    const anomalies = [];
                    const taskSummary = {};

                    filteredEstimates.forEach(e => {
                        const key = `${e.version}-${e.task}-${e.process}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: e.version, task: e.task, process: e.process, estimate: 0, actual: 0 };
                        }
                        taskSummary[key].estimate += e.hours;
                    });

                    filteredActuals.forEach(a => {
                        const key = `${a.version}-${a.task}-${a.process}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: a.version, task: a.task, process: a.process, estimate: 0, actual: 0 };
                        }
                        taskSummary[key].actual += a.hours;
                    });

                    Object.values(taskSummary).forEach(task => {
                        const overrun = task.estimate > 0 ? ((task.actual - task.estimate) / task.estimate * 100) : 0;
                        if (overrun > 50) {
                            anomalies.push({ ...task, overrun });
                        }
                    });

                    if (anomalies.length > 0) {
                        anomalies.sort((a, b) => b.overrun - a.overrun);

                        html += '<div style="background: rgba(255, 107, 107, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 2px solid rgba(255, 107, 107, 0.4);">';
                        html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">⚠️ 異常値検出（50%以上超過）</h4>';
                        html += `<div style="color: white; font-size: 14px; margin-bottom: 10px;">検出数: ${anomalies.length}件</div>`;
                        html += '<div style="max-height: 200px; overflow-y: auto;">';

                        anomalies.slice(0, 10).forEach(anomaly => {
                            html += '<div style="background: rgba(255,255,255,0.15); padding: 8px; border-radius: 4px; margin-bottom: 5px; font-size: 13px;">';
                            html += `<div style="font-weight: 600;">${anomaly.version} - ${anomaly.task} [${anomaly.process}]</div>`;
                            html += `<div>見積: ${anomaly.estimate.toFixed(1)}h → 実績: ${anomaly.actual.toFixed(1)}h <span style="color: #ff6b6b; font-weight: bold;">(+${anomaly.overrun.toFixed(0)}%)</span></div>`;
                            html += '</div>';
                        });

                        if (anomalies.length > 10) {
                            html += `<div style="text-align: center; padding: 5px; color: rgba(255,255,255,0.7);">他 ${anomalies.length - 10}件...</div>`;
                        }

                        html += '</div></div>';
                    }
                }

                // 警告タスク一覧
                if (reportSettings.warningTasksEnabled) {
                    const warnings = [];
                    const taskSummary = {};

                    filteredEstimates.forEach(e => {
                        const key = `${e.version}-${e.task}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: e.version, task: e.task, estimate: 0, actual: 0, processes: new Set() };
                        }
                        taskSummary[key].estimate += e.hours;
                        taskSummary[key].processes.add(e.process);
                    });

                    filteredActuals.forEach(a => {
                        const key = `${a.version}-${a.task}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: a.version, task: a.task, estimate: 0, actual: 0, processes: new Set() };
                        }
                        taskSummary[key].actual += a.hours;
                        taskSummary[key].processes.add(a.process);
                    });

                    Object.values(taskSummary).forEach(task => {
                        const overrun = task.estimate > 0 ? ((task.actual - task.estimate) / task.estimate * 100) : 0;
                        if (overrun > 50) {
                            warnings.push({ ...task, overrun, processCount: task.processes.size });
                        }
                    });

                    if (warnings.length > 0) {
                        warnings.sort((a, b) => b.overrun - a.overrun);

                        html += '<div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">🚨 要注意タスク</h4>';
                        html += '<div style="max-height: 150px; overflow-y: auto;">';

                        warnings.slice(0, 5).forEach((warning, idx) => {
                            html += '<div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 4px; margin-bottom: 5px;">';
                            html += `<div style="font-weight: 600;">#${idx + 1} ${warning.version} - ${warning.task}</div>`;
                            html += `<div style="font-size: 13px;">見積: ${warning.estimate.toFixed(1)}h → 実績: ${warning.actual.toFixed(1)}h <span style="color: #ff6b6b; font-weight: bold;">(+${warning.overrun.toFixed(0)}%)</span></div>`;
                            html += `<div style="font-size: 12px; opacity: 0.8;">工程数: ${warning.processCount}</div>`;
                            html += '</div>';
                        });

                        html += '</div></div>';
                    }
                }

                html += '</div>';
            }

            // Phase 2: グラフと月別推移
            if (reportSettings.chartEnabled || reportSettings.trendEnabled) {
                html += '<div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); padding: 20px; border-radius: 12px; margin: 20px 0; color: white;">';
                html += '<h3 style="margin: 0 0 15px 0; color: white;">📈 Phase 2: ビジュアル分析</h3>';

                // 工程別バーチャート
                if (reportSettings.chartEnabled) {
                    const processSummary = {};
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

                    filteredEstimates.forEach(e => {
                        const processKey = processOrder.includes(e.process) ? e.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].estimate += e.hours;
                    });

                    filteredActuals.forEach(a => {
                        const processKey = processOrder.includes(a.process) ? a.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].actual += a.hours;
                    });

                    const maxHours = Math.max(...Object.values(processSummary).map(p => Math.max(p.estimate, p.actual)));

                    html += '<div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
                    html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">工程別見積vs実績</h4>';

                    const sortedProcesses = [
                        ...processOrder.filter(p => processSummary[p]),
                        ...(processSummary['その他'] ? ['その他'] : [])
                    ];

                    sortedProcesses.forEach(proc => {
                        const data = processSummary[proc];
                        const estWidth = (data.estimate / maxHours * 100).toFixed(1);
                        const actWidth = (data.actual / maxHours * 100).toFixed(1);

                        html += '<div style="margin-bottom: 15px;">';
                        html += `<div style="font-weight: 600; margin-bottom: 5px;">${proc}</div>`;
                        html += '<div style="display: grid; grid-template-columns: 60px 1fr; gap: 10px; align-items: center;">';
                        html += '<div style="text-align: right; font-size: 13px;">見積</div>';
                        html += `<div style="background: rgba(255,255,255,0.3); border-radius: 4px; height: 20px; position: relative;">`;
                        html += `<div style="background: #4dabf7; height: 100%; width: ${estWidth}%; border-radius: 4px; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; min-width: 30px;">`;
                        html += `<span style="font-size: 12px; font-weight: 600;">${data.estimate.toFixed(1)}h</span>`;
                        html += '</div></div>';
                        html += '<div style="text-align: right; font-size: 13px;">実績</div>';
                        html += `<div style="background: rgba(255,255,255,0.3); border-radius: 4px; height: 20px;">`;
                        html += `<div style="background: ${data.actual > data.estimate ? '#ff6b6b' : '#51cf66'}; height: 100%; width: ${actWidth}%; border-radius: 4px; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; min-width: 30px;">`;
                        html += `<span style="font-size: 12px; font-weight: 600;">${data.actual.toFixed(1)}h</span>`;
                        html += '</div></div>';
                        html += '</div></div>';
                    });

                    html += '</div>';
                }

                // 月別推移分析
                if (reportSettings.trendEnabled && selectedMonth === 'all') {
                    const monthlyData = {};

                    filteredEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        est.workMonths.forEach(month => {
                            if (!monthlyData[month]) {
                                monthlyData[month] = { estimate: 0, actual: 0 };
                            }
                            const monthlyHours = est.monthlyHours[month] || 0;
                            monthlyData[month].estimate += monthlyHours;
                        });
                    });

                    filteredActuals.forEach(a => {
                        const month = a.workMonth;
                        if (!monthlyData[month]) {
                            monthlyData[month] = { estimate: 0, actual: 0 };
                        }
                        monthlyData[month].actual += a.hours;
                    });

                    const sortedMonths = Object.keys(monthlyData).sort();

                    if (sortedMonths.length > 1) {
                        html += '<div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">月別推移</h4>';

                        const maxMonthlyHours = Math.max(...Object.values(monthlyData).map(m => Math.max(m.estimate, m.actual)));

                        sortedMonths.slice(-6).forEach(month => {
                            const data = monthlyData[month];
                            const [year, monthNum] = month.split('-');
                            const estWidth = (data.estimate / maxMonthlyHours * 100).toFixed(1);
                            const actWidth = (data.actual / maxMonthlyHours * 100).toFixed(1);
                            const diff = data.actual - data.estimate;

                            html += '<div style="margin-bottom: 12px;">';
                            html += `<div style="font-weight: 600; margin-bottom: 5px;">${year}年${parseInt(monthNum)}月</div>`;
                            html += '<div style="display: flex; gap: 5px; align-items: center;">';
                            html += `<div style="flex: 1; background: rgba(255,255,255,0.3); border-radius: 4px; height: 24px; position: relative;">`;
                            html += `<div style="background: #4dabf7; height: 100%; width: ${estWidth}%; border-radius: 4px;"></div>`;
                            html += '</div>';
                            html += `<div style="flex: 1; background: rgba(255,255,255,0.3); border-radius: 4px; height: 24px;">`;
                            html += `<div style="background: ${data.actual > data.estimate ? '#ff6b6b' : '#51cf66'}; height: 100%; width: ${actWidth}%; border-radius: 4px;"></div>`;
                            html += '</div>';
                            html += `<div style="min-width: 80px; text-align: right; font-size: 13px;">${diff > 0 ? '+' : ''}${diff.toFixed(1)}h</div>`;
                            html += '</div></div>';
                        });

                        html += '</div>';
                    }
                }

                html += '</div>';
            }

            // Phase 3: 担当者別分析とインサイト
            if (reportSettings.memberAnalysisEnabled || reportSettings.insightsEnabled) {
                html += '<div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); padding: 20px; border-radius: 12px; margin: 20px 0; color: white;">';
                html += '<h3 style="margin: 0 0 15px 0; color: white;">👥 Phase 3: 担当者分析とインサイト</h3>';

                // 担当者別パフォーマンス
                if (reportSettings.memberAnalysisEnabled) {
                    const memberSummary = {};

                    filteredEstimates.forEach(e => {
                        if (!memberSummary[e.member]) {
                            memberSummary[e.member] = { estimate: 0, actual: 0, tasks: new Set() };
                        }
                        memberSummary[e.member].estimate += e.hours;
                        memberSummary[e.member].tasks.add(`${e.version}-${e.task}`);
                    });

                    filteredActuals.forEach(a => {
                        if (!memberSummary[a.member]) {
                            memberSummary[a.member] = { estimate: 0, actual: 0, tasks: new Set() };
                        }
                        memberSummary[a.member].actual += a.hours;
                        memberSummary[a.member].tasks.add(`${a.version}-${a.task}`);
                    });

                    const members = Object.keys(memberSummary).sort((a, b) =>
                        memberSummary[b].actual - memberSummary[a].actual
                    );

                    if (members.length > 0) {
                        html += '<div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">担当者別パフォーマンス</h4>';
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">';

                        members.forEach(member => {
                            const data = memberSummary[member];
                            const accuracy = data.estimate > 0 ? (data.actual / data.estimate * 100).toFixed(1) : 0;
                            const diff = data.actual - data.estimate;
                            const manDays = (data.actual / 8).toFixed(1);

                            html += '<div style="background: rgba(255,255,255,0.2); padding: 12px; border-radius: 6px;">';
                            html += `<div style="font-weight: 600; margin-bottom: 5px;">${member}</div>`;
                            html += `<div style="font-size: 13px;">実績: ${data.actual.toFixed(1)}h (${manDays}人日)</div>`;
                            html += `<div style="font-size: 13px;">精度: <span style="font-weight: 600;">${accuracy}%</span></div>`;
                            html += `<div style="font-size: 13px;">差分: <span style="color: ${diff > 0 ? '#ff6b6b' : '#51cf66'};">${diff > 0 ? '+' : ''}${diff.toFixed(1)}h</span></div>`;
                            html += `<div style="font-size: 12px; opacity: 0.8; margin-top: 5px;">担当タスク: ${data.tasks.size}件</div>`;
                            html += '</div>';
                        });

                        html += '</div></div>';
                    }
                }

                // AIライクなインサイト
                if (reportSettings.insightsEnabled) {
                    const insights = [];

                    // 全体の精度チェック
                    const totalEst = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
                    const totalAct = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
                    const overallAccuracy = totalEst > 0 ? (totalAct / totalEst * 100) : 0;

                    if (overallAccuracy > 120) {
                        insights.push({
                            type: 'warning',
                            icon: '⚠️',
                            title: '見積精度に課題',
                            message: `全体で見積を${(overallAccuracy - 100).toFixed(0)}%超過しています。タスク分解の見直しが必要かもしれません。`
                        });
                    } else if (overallAccuracy >= 90 && overallAccuracy <= 110) {
                        insights.push({
                            type: 'success',
                            icon: '✅',
                            title: '優れた見積精度',
                            message: `見積精度${overallAccuracy.toFixed(1)}%で、非常に正確な見積ができています。`
                        });
                    }

                    // 最も効率的な工程
                    const processSummary = {};
                    filteredEstimates.forEach(e => {
                        if (!processSummary[e.process]) processSummary[e.process] = { estimate: 0, actual: 0 };
                        processSummary[e.process].estimate += e.hours;
                    });
                    filteredActuals.forEach(a => {
                        if (!processSummary[a.process]) processSummary[a.process] = { estimate: 0, actual: 0 };
                        processSummary[a.process].actual += a.hours;
                    });

                    let bestProcess = null;
                    let bestAccuracy = 1000;
                    Object.entries(processSummary).forEach(([proc, data]) => {
                        if (data.estimate > 0) {
                            const accuracy = Math.abs(100 - (data.actual / data.estimate * 100));
                            if (accuracy < bestAccuracy) {
                                bestAccuracy = accuracy;
                                bestProcess = proc;
                            }
                        }
                    });

                    if (bestProcess) {
                        insights.push({
                            type: 'info',
                            icon: '🌟',
                            title: '最適な工程',
                            message: `${bestProcess}工程の見積精度が最も高く、計画通りに進行しています。`
                        });
                    }

                    // 担当者の負荷チェック
                    const memberSummary = {};
                    filteredActuals.forEach(a => {
                        if (!memberSummary[a.member]) memberSummary[a.member] = 0;
                        memberSummary[a.member] += a.hours;
                    });

                    const maxMember = Object.entries(memberSummary).sort((a, b) => b[1] - a[1])[0];
                    if (maxMember && selectedMonth !== 'all') {
                        const manDays = (maxMember[1] / 8).toFixed(1);
                        const manMonths = (maxMember[1] / 8 / workingDaysPerMonth).toFixed(2);
                        if (manMonths > 1.2) {
                            insights.push({
                                type: 'warning',
                                icon: '🔥',
                                title: '高負荷担当者あり',
                                message: `${maxMember[0]}さんの作業量が${manMonths}人月（${manDays}人日）で、リソース配分の見直しを検討してください。`
                            });
                        }
                    }

                    // タスク完了率
                    const estimatedTasks = new Set(filteredEstimates.map(e => `${e.version}-${e.task}`));
                    const actualTasks = new Set(filteredActuals.map(a => `${a.version}-${a.task}`));
                    const completedTasks = [...estimatedTasks].filter(t => actualTasks.has(t));
                    const completionRate = estimatedTasks.size > 0 ? (completedTasks.length / estimatedTasks.size * 100).toFixed(0) : 0;

                    if (completionRate < 100 && selectedMonth !== 'all') {
                        const pendingCount = estimatedTasks.size - completedTasks.length;
                        insights.push({
                            type: 'info',
                            icon: '📋',
                            title: '未完了タスクあり',
                            message: `見積済みタスクのうち${pendingCount}件が未完了です。進捗を確認してください。`
                        });
                    }

                    if (insights.length > 0) {
                        html += '<div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: white; font-size: 16px;">💡 インサイト</h4>';

                        insights.forEach(insight => {
                            const bgColor = insight.type === 'warning' ? 'rgba(255, 107, 107, 0.3)' :
                                          insight.type === 'success' ? 'rgba(81, 207, 102, 0.3)' :
                                          'rgba(74, 144, 226, 0.3)';

                            html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 6px; margin-bottom: 8px;">`;
                            html += `<div style="font-weight: 600; margin-bottom: 3px;">${insight.icon} ${insight.title}</div>`;
                            html += `<div style="font-size: 13px;">${insight.message}</div>`;
                            html += '</div>';
                        });

                        html += '</div>';
                    }
                }

                html += '</div>';
            }

            container.innerHTML += html;
        }

        function renderReportGrouped(filteredActuals, filteredEstimates) {
            const container = document.getElementById('reportDetailView');

            // 選択月の実働日数を取得
            const selectedMonth = document.getElementById('reportMonth').value;
            let workingDaysPerMonth = 20; // デフォルト
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                workingDaysPerMonth = getWorkingDays(parseInt(year), parseInt(month));
            }

            // 版数ごとにグループ化
            const versionGroups = {};
            
            // 見積データを追加（フィルタ済み）
            filteredEstimates.forEach(e => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(e)) {
                    version = 'その他付随作業';
                    taskKey = e.task && e.task.trim() !== '' ? e.task : '未分類作業';
                } else {
                    version = e.version;
                    taskKey = e.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                if (!versionGroups[version][taskKey].estimates[e.process]) {
                    versionGroups[version][taskKey].estimates[e.process] = { members: new Set(), hours: 0 };
                }
                versionGroups[version][taskKey].estimates[e.process].members.add(e.member);
                versionGroups[version][taskKey].estimates[e.process].hours += e.hours;
            });
            
            // 実績データを追加（担当者も集計）
            filteredActuals.forEach(a => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(a)) {
                    version = 'その他付随作業';
                    taskKey = a.task && a.task.trim() !== '' ? a.task : '未分類作業';
                } else {
                    version = a.version;
                    taskKey = a.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                if (!versionGroups[version][taskKey].actuals[a.process]) {
                    versionGroups[version][taskKey].actuals[a.process] = { members: new Set(), hours: 0 };
                }
                versionGroups[version][taskKey].actuals[a.process].members.add(a.member);
                versionGroups[version][taskKey].actuals[a.process].hours += a.hours;
            });
            
            // データがない場合
            if (Object.keys(versionGroups).length === 0) {
                container.innerHTML += '<p style="color: #999; text-align: center; padding: 40px;">該当するデータがありません</p>';
                return;
            }
            
            let html = '<h3 style="margin-top: 30px;">対応別詳細（見積 vs 実績）</h3>';
            html += '<div style="margin-bottom: 30px;">';

            // 版数ごとに表示（「その他付随作業」を最後に）
            const versions = Object.keys(versionGroups).sort((a, b) => {
                if (a === 'その他付随作業') return 1;
                if (b === 'その他付随作業') return -1;
                return a.localeCompare(b);
            });

            versions.forEach(version => {
                // 先にテーブル本体を生成して、データがあるかチェック
                let tableBody = '';
                let versionTotalEst = 0;
                let versionTotalAct = 0;

                Object.values(versionGroups[version]).forEach(taskGroup => {
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];
                    const allProcesses = new Set([...Object.keys(taskGroup.estimates), ...Object.keys(taskGroup.actuals)]);

                    // processOrderに含まれる工程を先に、その後に含まれない工程を追加
                    const sortedProcesses = [
                        ...processOrder.filter(p => allProcesses.has(p)),
                        ...[...allProcesses].filter(p => !processOrder.includes(p))
                    ];

                    if (sortedProcesses.length === 0) return;
                    
                    // 先に合計を計算
                    let totalEst = 0;
                    let totalAct = 0;
                    sortedProcesses.forEach(proc => {
                        const est = taskGroup.estimates[proc] || { members: new Set(), hours: 0 };
                        const act = taskGroup.actuals[proc] || { members: new Set(), hours: 0 };
                        totalEst += est.hours;
                        totalAct += act.hours;
                    });
                    const totalDiff = totalAct - totalEst;

                    // 版数の合計に加算
                    versionTotalEst += totalEst;
                    versionTotalAct += totalAct;
                    
                    // 行を表示
                    sortedProcesses.forEach((proc, index) => {
                        const est = taskGroup.estimates[proc] || { members: new Set(), hours: 0 };
                        const act = taskGroup.actuals[proc] || { members: new Set(), hours: 0 };
                        const diff = act.hours - est.hours;

                        // 実績ベースで担当者を表示（実績がなければ見積）
                        let memberDisplay = '-';
                        if (act.members.size > 0) {
                            memberDisplay = Array.from(act.members).join(',');
                        } else if (est.members.size > 0) {
                            memberDisplay = Array.from(est.members).join(',');
                        }

                        tableBody += '<tr>';
                        if (index === 0) {
                            // 対応名を「：」（全角コロン）で分割して2行表示
                            let taskDisplayHtml = taskGroup.task;
                            if (taskGroup.task.includes('：')) {
                                const parts = taskGroup.task.split('：');
                                const restPart = parts.slice(1).join('：');
                                taskDisplayHtml = `${parts[0]}<br><span style="font-size: 13px; font-weight: normal;">${restPart}</span>`;
                            }
                            tableBody += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; font-weight: 600;">${taskDisplayHtml}</td>`;
                        }
                        tableBody += `<td><span class="badge badge-${proc.toLowerCase()}">${proc}</span></td>`;
                        tableBody += `<td style="word-break: break-word;">${memberDisplay}</td>`;
                        tableBody += `<td style="text-align: right;">${est.hours > 0 ? est.hours.toFixed(1) + 'h' : '-'}</td>`;
                        tableBody += `<td style="text-align: right;">${act.hours > 0 ? act.hours.toFixed(1) + 'h' : '-'}</td>`;
                        tableBody += `<td style="text-align: right; color: ${diff > 0 ? '#e74c3c' : diff < 0 ? '#27ae60' : '#666'}">${diff !== 0 ? (diff > 0 ? '+' : '') + diff.toFixed(1) + 'h' : '-'}</td>`;
                        if (index === 0) {
                            tableBody += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; text-align: right;">
                                <div style="font-weight: 600;">見積: ${totalEst.toFixed(1)}h</div>
                                <div style="font-weight: 600;">実績: ${totalAct.toFixed(1)}h</div>
                                <div style="font-weight: 700; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">差異: ${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}h</div>
                            </td>`;
                        }
                        tableBody += '</tr>';
                    });
                });

                // テーブル本体にデータがある場合のみ表示
                if (tableBody) {
                    const versionTotalDiff = versionTotalAct - versionTotalEst;

                    html += `<div style="margin-bottom: 30px;">`;
                    html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                    html += '<div class="table-wrapper"><table>';
                    html += '<tr><th style="min-width: 150px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">見積</th><th style="min-width: 80px;">実績</th><th style="min-width: 80px;">差異</th><th style="min-width: 100px;">対応合計</th></tr>';
                    html += tableBody;

                    // 合計行を追加
                    html += '<tr style="background: #f5f5f5; font-weight: bold; border-top: 2px solid #ddd;">';
                    html += `<td style="padding: 12px; position: sticky; left: 0; background: #f5f5f5; z-index: 1;">合計</td>`;
                    html += '<td></td>';
                    html += '<td></td>';
                    html += `<td style="text-align: right;">${versionTotalEst.toFixed(1)}h</td>`;
                    html += `<td style="text-align: right;">${versionTotalAct.toFixed(1)}h</td>`;
                    html += `<td style="text-align: right; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}h</td>`;
                    html += '<td></td>';
                    html += '</tr>';

                    html += '</table></div>';
                    html += '</div>';
                }
            });

            html += '</div>';
            container.innerHTML += html;
        }

        function renderReportMatrix(filteredActuals, filteredEstimates) {
            const container = document.getElementById('reportDetailView');
            
            // 版数ごとにグループ化
            const versionGroups = {};
            
            // 見積データを追加（フィルタ済み）
            filteredEstimates.forEach(e => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(e)) {
                    version = 'その他付随作業';
                    taskKey = e.task && e.task.trim() !== '' ? e.task : '未分類作業';
                } else {
                    version = e.version;
                    taskKey = e.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                versionGroups[version][taskKey].estimates[e.process] = { member: e.member, hours: e.hours };
            });
            
            // 実績データを追加
            filteredActuals.forEach(a => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(a)) {
                    version = 'その他付随作業';
                    taskKey = a.task && a.task.trim() !== '' ? a.task : '未分類作業';
                } else {
                    version = a.version;
                    taskKey = a.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                if (!versionGroups[version][taskKey].actuals[a.process]) {
                    versionGroups[version][taskKey].actuals[a.process] = { member: a.member, hours: 0 };
                }
                versionGroups[version][taskKey].actuals[a.process].hours += a.hours;
            });
            
            // データがない場合
            if (Object.keys(versionGroups).length === 0) {
                container.innerHTML += '<p style="color: #999; text-align: center; padding: 40px;">該当するデータがありません</p>';
                return;
            }
            
            const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];
            
            let html = '<h3 style="margin-top: 30px;">対応別マトリクス（見積 vs 実績）</h3>';
            html += '<div style="margin-bottom: 30px;">';

            // 版数ごとに表示（「その他付随作業」を最後に）
            const versions = Object.keys(versionGroups).sort((a, b) => {
                if (a === 'その他付随作業') return 1;
                if (b === 'その他付随作業') return -1;
                return a.localeCompare(b);
            });

            versions.forEach(version => {
                // この版数グループ内の全工程を収集
                const versionProcesses = new Set();
                Object.values(versionGroups[version]).forEach(taskGroup => {
                    Object.keys(taskGroup.estimates).forEach(p => versionProcesses.add(p));
                    Object.keys(taskGroup.actuals).forEach(p => versionProcesses.add(p));
                });

                // processOrderに含まれる工程を先に、その後に含まれない工程を追加
                const displayProcesses = [
                    ...processOrder.filter(p => versionProcesses.has(p)),
                    ...[...versionProcesses].filter(p => !processOrder.includes(p))
                ];

                // 先にテーブル本体を生成して、データがあるかチェック
                let tableBody = '';
                let versionTotalEst = 0;
                let versionTotalAct = 0;

                Object.values(versionGroups[version]).forEach(taskGroup => {
                    // 全工程を取得
                    const allProcesses = new Set([...Object.keys(taskGroup.estimates), ...Object.keys(taskGroup.actuals)]);

                    let totalEst = 0;
                    let totalAct = 0;

                    // 先に合計を計算してデータの有無を確認
                    displayProcesses.forEach(proc => {
                        const est = taskGroup.estimates[proc] || { member: '-', hours: 0 };
                        const act = taskGroup.actuals[proc] || { member: '-', hours: 0 };
                        totalEst += est.hours;
                        totalAct += act.hours;
                    });

                    // 見積または実績のいずれかにデータがある場合のみ行を追加
                    if (totalEst > 0 || totalAct > 0) {
                        // 版数の合計に加算
                        versionTotalEst += totalEst;
                        versionTotalAct += totalAct;

                        // 対応名を「：」（全角コロン）で分割して2行表示
                        let taskDisplayHtml = taskGroup.task;
                        if (taskGroup.task.includes('：')) {
                            const parts = taskGroup.task.split('：');
                            const restPart = parts.slice(1).join('：');
                            taskDisplayHtml = `${parts[0]}<br><span style="font-size: 13px; font-weight: normal;">${restPart}</span>`;
                        }

                        tableBody += '<tr>';
                        tableBody += `<td style="font-weight: 600;">${taskDisplayHtml}</td>`;

                        displayProcesses.forEach(proc => {
                            const est = taskGroup.estimates[proc] || { member: '-', hours: 0 };
                            const act = taskGroup.actuals[proc] || { member: '-', hours: 0 };

                            if (est.hours > 0 || act.hours > 0) {
                                const diff = act.hours - est.hours;
                                tableBody += `<td style="text-align: center;">
                                    <div style="font-weight: 600;">${est.hours > 0 ? est.hours.toFixed(1) : '-'} / ${act.hours > 0 ? act.hours.toFixed(1) : '-'}</div>
                                    <div style="font-size: 11px; color: #666;">(${est.member !== '-' ? est.member : act.member})</div>
                                    <div style="font-size: 11px; color: ${diff > 0 ? '#e74c3c' : diff < 0 ? '#27ae60' : '#666'}">${diff !== 0 ? (diff > 0 ? '+' : '') + diff.toFixed(1) : '-'}</div>
                                </td>`;
                            } else {
                                tableBody += `<td style="text-align: center; color: #ccc;">-</td>`;
                            }
                        });

                        const totalDiff = totalAct - totalEst;
                        tableBody += `<td style="text-align: center;">
                            <div style="font-weight: 700;">${totalEst.toFixed(1)} / ${totalAct.toFixed(1)}</div>
                            <div style="font-weight: 700; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}</div>
                        </td>`;
                        tableBody += '</tr>';
                    }
                });

                // テーブル本体にデータがある場合のみ表示
                if (tableBody) {
                    const versionTotalDiff = versionTotalAct - versionTotalEst;

                    html += `<div style="margin-bottom: 30px;">`;
                    html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                    html += '<div class="table-wrapper"><table>';
                    html += '<tr><th style="min-width: 200px;">対応名</th>';
                    displayProcesses.forEach(proc => {
                        html += `<th style="min-width: 120px; text-align: center;">${proc}<br><small style="font-weight: normal; opacity: 0.8;">見積/実績</small></th>`;
                    });
                    html += '<th style="min-width: 100px; text-align: center;">合計<br><small style="font-weight: normal; opacity: 0.8;">見積/実績</small></th></tr>';
                    html += tableBody;

                    // 合計行を追加
                    html += '<tr style="background: #f5f5f5; font-weight: bold; border-top: 2px solid #ddd;">';
                    html += `<td style="padding: 12px; position: sticky; left: 0; background: #f5f5f5; z-index: 1;">合計</td>`;
                    // 各工程の列を空にする
                    displayProcesses.forEach(() => {
                        html += '<td></td>';
                    });
                    // 合計列
                    html += `<td style="text-align: center;">`;
                    html += `<div style="font-weight: 700;">${versionTotalEst.toFixed(1)} / ${versionTotalAct.toFixed(1)}</div>`;
                    html += `<div style="font-weight: 700; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}</div>`;
                    html += '</td>';
                    html += '</tr>';

                    html += '</table></div>';
                    html += '</div>';
                }
            });

            html += '</div>';
            container.innerHTML += html;
        }

        function renderMemberReport(filteredActuals, filteredEstimates) {
            // 見積データと実績データから担当者を動的に抽出
            const allMembers = new Set();
            filteredEstimates.forEach(e => allMembers.add(e.member));
            filteredActuals.forEach(a => allMembers.add(a.member));
            
            // 表示順が設定されている場合はそれを使用
            let members;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                // 指定された順序で追加
                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                // 指定されていない担当者を後ろに追加
                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                members = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                members = Array.from(allMembers).sort();
            }
            
            if (members.length === 0) {
                document.getElementById('memberReport').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">データがありません</p>';
                return;
            }
            
            let html = '<div class="table-wrapper"><table><tr><th>担当者</th><th>見積工数</th><th>実績工数</th><th>差異</th><th>差異率</th></tr>';

            members.forEach(member => {
                const est = filteredEstimates.filter(e => e.member === member).reduce((sum, e) => sum + e.hours, 0);
                const act = filteredActuals.filter(a => a.member === member).reduce((sum, a) => sum + a.hours, 0);
                const diff = act - est;
                const rate = est > 0 ? ((diff / est) * 100).toFixed(1) : 0;

                html += `
                    <tr>
                        <td><strong>${member}</strong></td>
                        <td>${est.toFixed(1)}h</td>
                        <td>${act.toFixed(1)}h</td>
                        <td style="color: ${diff >= 0 ? '#e74c3c' : '#27ae60'}">${(diff >= 0 ? '+' : '')}${diff.toFixed(1)}h</td>
                        <td>${rate}%</td>
                    </tr>
                `;
            });

            html += '</table></div>';
            document.getElementById('memberReport').innerHTML = html;
        }

        function renderVersionReport(filteredActuals, filteredEstimates) {
            const versions = [...new Set(filteredEstimates.map(e => e.version))];
            
            if (versions.length === 0) {
                document.getElementById('versionReport').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">該当する見積データがありません</p>';
                return;
            }
            
            let html = '<div class="table-wrapper"><table><tr><th>版数</th><th>見積工数</th><th>実績工数</th><th>進捗率</th></tr>';

            versions.forEach(version => {
                const est = filteredEstimates.filter(e => e.version === version).reduce((sum, e) => sum + e.hours, 0);
                const act = filteredActuals.filter(a => a.version === version).reduce((sum, a) => sum + a.hours, 0);
                const progress = est > 0 ? (act / est * 100).toFixed(1) : 0;

                html += `
                    <tr>
                        <td><strong>${version}</strong></td>
                        <td>${est.toFixed(1)}h</td>
                        <td>${act.toFixed(1)}h</td>
                        <td>${progress}%</td>
                    </tr>
                `;
            });

            html += '</table></div>';
            document.getElementById('versionReport').innerHTML = html;
        }

        function deleteEstimate(id) {
            if (!confirm('この見積を削除しますか?')) return;
            estimates = estimates.filter(e => e.id !== id);
            saveData();
            renderEstimateList();
            updateQuickTaskList();
            updateReport();
            alert('見積を削除しました');
        }

        // 作業月関連の関数
        function updateWorkMonthOptions() {
            const select = document.getElementById('assignWorkMonth');
            if (!select) return;

            const filter = document.getElementById('estimateMonthFilter');

            // 見積と実績から月を抽出
            const months = new Set();
            
            // 見積から作業予定月を抽出
            estimates.forEach(e => {
                if (e.workMonth) {
                    months.add(e.workMonth);
                }
            });
            
            // 実績から月を抽出
            actuals.forEach(a => {
                if (a.date) {
                    const month = a.date.substring(0, 7); // YYYY-MM
                    months.add(month);
                }
            });
            
            // 現在月から6ヶ月分を追加
            const now = new Date();
            for (let i = -1; i <= 6; i++) {
                const date = new Date(now.getFullYear(), now.getMonth() + i, 1);
                const monthStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.add(monthStr);
            }
            
            const sortedMonths = Array.from(months).sort(); // 昇順（古い月→新しい月）
            
            // 割り当て先選択肢を更新
            select.innerHTML = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `<option value="${m}">${year}年${parseInt(month)}月</option>`;
            }).join('');

            // フィルタ選択肢を更新（存在する場合のみ）
            if (filter) {
                const currentFilterValue = filter.value;
                filter.innerHTML = '<option value="all">全て</option><option value="unassigned">未設定のみ</option>';
                sortedMonths.forEach(m => {
                    const [year, month] = m.split('-');
                    filter.innerHTML += `<option value="${m}">${year}年${parseInt(month)}月</option>`;
                });
                filter.value = currentFilterValue;
            }
        }

        function toggleWorkMonthSelectionMode() {
            const checkbox1 = document.getElementById('workMonthSelectionMode');
            const checkbox2 = document.getElementById('workMonthSelectionMode2');

            // どちらかのチェックボックスから呼ばれた場合、状態を同期
            if (checkbox1 && checkbox2) {
                if (event && event.target === checkbox1) {
                    checkbox2.checked = checkbox1.checked;
                    workMonthSelectionMode = checkbox1.checked;
                } else if (event && event.target === checkbox2) {
                    checkbox1.checked = checkbox2.checked;
                    workMonthSelectionMode = checkbox2.checked;
                } else {
                    // イベントがない場合（プログラムから呼ばれた場合）
                    workMonthSelectionMode = checkbox1.checked;
                    checkbox2.checked = checkbox1.checked;
                }
            } else if (checkbox1) {
                workMonthSelectionMode = checkbox1.checked;
            }

            const modePanel = document.getElementById('workMonthAssignmentMode');

            if (workMonthSelectionMode) {
                modePanel.style.display = 'block';
                selectedEstimateIds.clear();
                updateSelectedWorkHours();
                initDragHandle(); // ドラッグ機能を初期化
            } else {
                modePanel.style.display = 'none';
                selectedEstimateIds.clear();
            }

            renderEstimateList();
        }
        
        // ドラッグ機能の初期化
        function initDragHandle() {
            const dragHandle = document.getElementById('dragHandle');
            const panel = document.getElementById('workMonthAssignmentMode');
            
            if (!dragHandle || !panel) return;
            
            let isDragging = false;
            let startY = 0;
            let startTop = 20; // 初期位置
            
            // 保存された位置を復元
            const savedTop = localStorage.getItem('manhour_panelTop');
            if (savedTop) {
                startTop = parseInt(savedTop);
                panel.style.top = startTop + 'px';
            }
            
            // マウスイベント
            dragHandle.addEventListener('mousedown', function(e) {
                isDragging = true;
                startY = e.clientY;
                const currentTop = parseInt(panel.style.top) || 20;
                startTop = currentTop;
                dragHandle.style.background = 'rgba(0,0,0,0.2)';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaY = e.clientY - startY;
                let newTop = startTop + deltaY;
                
                // 画面内に制限（最小10px、最大は画面高さ-パネル高さ-10px）
                const panelHeight = panel.offsetHeight;
                const maxTop = window.innerHeight - panelHeight - 10;
                newTop = Math.max(10, Math.min(newTop, maxTop));
                
                panel.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    dragHandle.style.background = 'rgba(0,0,0,0.1)';
                    // 位置を保存
                    const currentTop = parseInt(panel.style.top) || 20;
                    localStorage.setItem('manhour_panelTop', currentTop);
                }
            });
            
            // タッチイベント
            dragHandle.addEventListener('touchstart', function(e) {
                isDragging = true;
                startY = e.touches[0].clientY;
                const currentTop = parseInt(panel.style.top) || 20;
                startTop = currentTop;
                dragHandle.style.background = 'rgba(0,0,0,0.2)';
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                
                const deltaY = e.touches[0].clientY - startY;
                let newTop = startTop + deltaY;
                
                // 画面内に制限
                const panelHeight = panel.offsetHeight;
                const maxTop = window.innerHeight - panelHeight - 10;
                newTop = Math.max(10, Math.min(newTop, maxTop));
                
                panel.style.top = newTop + 'px';
            });
            
            document.addEventListener('touchend', function() {
                if (isDragging) {
                    isDragging = false;
                    dragHandle.style.background = 'rgba(0,0,0,0.1)';
                    // 位置を保存
                    const currentTop = parseInt(panel.style.top) || 20;
                    localStorage.setItem('manhour_panelTop', currentTop);
                }
            });
        }

        function toggleEstimateSelection(id, event) {
            if (!workMonthSelectionMode) return;
            
            event.stopPropagation();
            
            if (selectedEstimateIds.has(id)) {
                selectedEstimateIds.delete(id);
            } else {
                selectedEstimateIds.add(id);
            }
            
            updateSelectedWorkHours();
            renderEstimateList();
        }

        function selectTaskEstimates(version, task, event) {
            if (!workMonthSelectionMode) return;
            
            event.stopPropagation();
            
            // この対応の全工程を取得
            const taskEstimates = estimates.filter(e => e.version === version && e.task === task);
            const taskIds = taskEstimates.map(e => e.id);
            
            // 全て選択されているかチェック
            const allSelected = taskIds.every(id => selectedEstimateIds.has(id));
            
            if (allSelected) {
                // 全て選択解除
                taskIds.forEach(id => selectedEstimateIds.delete(id));
            } else {
                // 全て選択
                taskIds.forEach(id => selectedEstimateIds.add(id));
            }
            
            updateSelectedWorkHours();
            renderEstimateList();
        }

        function updateSelectedWorkHours() {
            const selectedEstimates = estimates.filter(e => selectedEstimateIds.has(e.id));
            const totalHours = selectedEstimates.reduce((sum, e) => sum + e.hours, 0);
            const days = totalHours / 8;

            // 現在の月の実働日数を取得（デフォルト）
            const workingDaysPerMonth = getCurrentMonthWorkingDays();
            const months = days / workingDaysPerMonth;

            document.getElementById('selectedWorkHours').textContent =
                `選択中: ${totalHours.toFixed(1)}h (${days.toFixed(1)}人日 / ${months.toFixed(2)}人月)`;
        }

        function executeWorkMonthAssignment() {
            if (selectedEstimateIds.size === 0) {
                alert('作業を選択してください');
                return;
            }
            
            const workMonth = document.getElementById('assignWorkMonth').value;
            const [year, month] = workMonth.split('-');
            
            if (!confirm(`選択した${selectedEstimateIds.size}件の作業に「${year}年${parseInt(month)}月」を割り当てますか？`)) {
                return;
            }
            
            // 選択された見積に作業月を設定
            estimates.forEach(e => {
                if (selectedEstimateIds.has(e.id)) {
                    e.workMonth = workMonth;
                }
            });
            
            selectedEstimateIds.clear();
            saveData();
            updateWorkMonthOptions();
            updateSelectedWorkHours();
            renderEstimateList();
            updateReport();
            
            alert('作業月を割り当てました');
        }

        function cancelWorkMonthSelection() {
            selectedEstimateIds.clear();
            updateSelectedWorkHours();
            renderEstimateList();
        }

        function deleteActual(id) {
            if (!confirm('この実績を削除しますか?')) return;
            actuals = actuals.filter(a => a.id !== id);
            saveData();
            updateMonthOptions();
            renderActualList();
            renderTodayActuals();
            updateReport();
            alert('実績を削除しました');
        }

        function exportBackup() {
            autoBackup();
            alert('バックアップを作成しました');
        }

        function importBackup() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.json')) {
                // JSONファイルの処理
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (confirm('現在のデータを復元したデータで上書きしますか？')) {
                            estimates = data.estimates || [];
                            actuals = data.actuals || [];
                            
                            // 担当者表示順を復元
                            if (data.memberOrder) {
                                document.getElementById('memberOrder').value = data.memberOrder;
                                localStorage.setItem('manhour_memberOrder', data.memberOrder);
                            }
                            
                            saveData(true); // 復元時は自動バックアップをスキップ
                            
                            updateMonthOptions();
                            updateActualMonthOptions();
                            updateMemberOptions();
                            updateQuickTaskList();
                            renderEstimateList();
                            renderActualList();
                            renderTodayActuals();
                            updateReport();
                            
                            alert('データを復元しました');
                        }
                    } catch (error) {
                        alert('ファイルの読み込みに失敗しました');
                    }
                };
                reader.readAsText(file);
            } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                // Excelファイルの処理
                handleExcelImport(file);
            } else {
                alert('対応していないファイル形式です。JSON または Excel ファイルを選択してください。');
            }
            
            event.target.value = '';
        }

        async function handleExcelImport(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(arrayBuffer);
                
                const estimatesSheet = workbook.getWorksheet('見積データ');
                const actualsSheet = workbook.getWorksheet('実績データ');
                
                if (!estimatesSheet || !actualsSheet) {
                    alert('Excelファイルに「見積データ」と「実績データ」のシートが必要です');
                    return;
                }
                
                // 見積データの読み込み
                const newEstimates = [];
                estimatesSheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // ヘッダー行をスキップ
                    
                    const version = row.getCell(1).value;
                    const task = row.getCell(2).value;
                    const process = row.getCell(3).value;
                    const member = row.getCell(4).value;
                    const hours = parseFloat(row.getCell(5).value);
                    
                    if (version && task && process && member && hours) {
                        newEstimates.push({
                            id: Date.now() + Math.random(),
                            version: String(version),
                            task: String(task),
                            process: String(process),
                            member: String(member),
                            hours: hours,
                            createdAt: new Date().toISOString()
                        });
                    }
                });
                
                // 実績データの読み込み
                const newActuals = [];
                actualsSheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // ヘッダー行をスキップ
                    
                    const dateValue = row.getCell(1).value;
                    const version = row.getCell(2).value;
                    const task = row.getCell(3).value;
                    const process = row.getCell(4).value;
                    const member = row.getCell(5).value;
                    const hours = parseFloat(row.getCell(6).value);
                    
                    // 日付の処理
                    let dateStr = '';
                    if (dateValue instanceof Date) {
                        dateStr = dateValue.toISOString().split('T')[0];
                    } else if (typeof dateValue === 'string') {
                        dateStr = dateValue;
                    } else if (typeof dateValue === 'number') {
                        // Excel のシリアル値を日付に変換
                        const date = new Date((dateValue - 25569) * 86400 * 1000);
                        dateStr = date.toISOString().split('T')[0];
                    }
                    
                    if (dateStr && version && task && process && member && hours) {
                        newActuals.push({
                            id: Date.now() + Math.random(),
                            date: dateStr,
                            version: String(version),
                            task: String(task),
                            process: String(process),
                            member: String(member),
                            hours: hours,
                            createdAt: new Date().toISOString()
                        });
                    }
                });
                
                if (newEstimates.length === 0 && newActuals.length === 0) {
                    alert('データが見つかりませんでした。Excelのフォーマットを確認してください。');
                    return;
                }
                
                if (confirm(`見積: ${newEstimates.length}件、実績: ${newActuals.length}件のデータを読み込みました。\n現在のデータを上書きしますか？`)) {
                    estimates = newEstimates;
                    actuals = newActuals;
                    saveData(true); // 復元時は自動バックアップをスキップ
                    
                    updateMonthOptions();
                    updateActualMonthOptions();
                    updateMemberOptions();
                    updateQuickTaskList();
                    renderEstimateList();
                    renderActualList();
                    renderTodayActuals();
                    updateReport();
                    
                    alert('Excelデータを読み込みました');
                }
                
            } catch (error) {
                console.error('Excel読み込みエラー:', error);
                alert('Excelファイルの読み込みに失敗しました: ' + error.message);
            }
        }
        
        // Excel出力機能
        async function exportToExcel() {
            try {
                const workbook = new ExcelJS.Workbook();
                
                // 実績データの期間を取得
                let minDate = null;
                let maxDate = null;
                
                actuals.forEach(a => {
                    const date = new Date(a.date);
                    if (!minDate || date < minDate) minDate = date;
                    if (!maxDate || date > maxDate) maxDate = date;
                });
                
                // 実績データがない場合は現在月を使用
                if (!minDate || !maxDate) {
                    const now = new Date();
                    minDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    maxDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                }
                
                // 担当者一覧を取得（表示順を考慮）
                let members = [...new Set(actuals.map(a => a.member))];
                
                // 表示順が指定されている場合
                const memberOrderInput = localStorage.getItem('memberOrder');
                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = [];
                    const unorderedMembers = [];
                    
                    // 指定された順序で追加
                    orderList.forEach(name => {
                        if (members.includes(name)) {
                            orderedMembers.push(name);
                        }
                    });
                    
                    // 指定されていない担当者を後ろに追加
                    members.forEach(m => {
                        if (!orderedMembers.includes(m)) {
                            unorderedMembers.push(m);
                        }
                    });
                    
                    members = [...orderedMembers, ...unorderedMembers.sort()];
                } else {
                    members.sort();
                }
                
                // 担当者ごとに実績シートを作成
                members.forEach(member => {
                    const worksheet = workbook.addWorksheet(`実績_${member}`);
                    
                    // ヘッダー行
                    worksheet.columns = [
                        { header: '日付', key: 'date', width: 12, style: { numFmt: 'yyyy/mm/dd' } },
                        { header: '曜日', key: 'weekday', width: 8 },
                        { header: '備考', key: 'note', width: 15 },
                        { header: '作業', key: 'work', width: 50 },
                        { header: '時間(h)', key: 'hours', width: 10 }
                    ];
                    
                    // ヘッダーのスタイル
                    worksheet.getRow(1).font = { bold: true };
                    worksheet.getRow(1).fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFD3D3D3' }
                    };
                    
                    // 全日付を生成（土日祝日含む）
                    const currentDate = new Date(minDate);
                    while (currentDate <= maxDate) {
                        const dateStr = currentDate.toISOString().split('T')[0];
                        const weekday = ['日', '月', '火', '水', '木', '金', '土'][currentDate.getDay()];
                        
                        // 祝日チェック
                        const holiday = getHoliday(dateStr);
                        const note = holiday || '';
                        
                        // この日付のこの担当者の実績を取得
                        const dayActuals = actuals.filter(a => 
                            a.date === dateStr && a.member === member
                        );
                        
                        if (dayActuals.length === 0) {
                            // 実績がない日も出力
                            worksheet.addRow({
                                date: new Date(currentDate),
                                weekday: weekday,
                                note: note,
                                work: '',
                                hours: ''
                            });
                        } else {
                            // 実績がある場合、各実績を行として追加
                            dayActuals.forEach((actual, index) => {
                                // 作業名を「版数_対応名_工程」の形式に
                                const workName = `${actual.version}_${actual.task}_${actual.process}`;
                                
                                worksheet.addRow({
                                    date: new Date(currentDate),
                                    weekday: weekday,
                                    note: note,
                                    work: workName,
                                    hours: actual.hours
                                });
                            });
                        }
                        
                        // 次の日へ
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    
                    // 罫線と日付フォーマットを設定
                    worksheet.eachRow((row, rowNumber) => {
                        row.eachCell((cell, colNumber) => {
                            cell.border = {
                                top: { style: 'thin' },
                                left: { style: 'thin' },
                                bottom: { style: 'thin' },
                                right: { style: 'thin' }
                            };
                            
                            // 日付列（1列目）の表示形式を設定
                            if (colNumber === 1 && rowNumber > 1) {
                                cell.numFmt = 'yyyy/mm/dd';
                            }
                        });
                    });
                    
                    // 土日祝日に色を付ける
                    let currentRow = 2; // ヘッダーの次から
                    const checkDate = new Date(minDate);
                    while (checkDate <= maxDate) {
                        const day = checkDate.getDay();
                        const dateStr = checkDate.toISOString().split('T')[0];
                        const isHoliday = getHoliday(dateStr) !== null;
                        
                        // この日付の行数を取得
                        const dayActuals = actuals.filter(a => 
                            a.date === dateStr && a.member === member
                        );
                        const rowCount = Math.max(1, dayActuals.length);
                        
                        if (day === 0 || isHoliday) {
                            // 日曜日または祝日（赤）
                            for (let i = 0; i < rowCount; i++) {
                                worksheet.getRow(currentRow + i).fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: 'FFFFCCCC' }
                                };
                            }
                        } else if (day === 6) {
                            // 土曜日（青）
                            for (let i = 0; i < rowCount; i++) {
                                worksheet.getRow(currentRow + i).fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: 'FFCCCCFF' }
                                };
                            }
                        }
                        
                        currentRow += rowCount;
                        checkDate.setDate(checkDate.getDate() + 1);
                    }
                });
                
                // 見積シートを作成
                const estimateSheet = workbook.addWorksheet('見積');
                
                estimateSheet.columns = [
                    { header: '版数', key: 'version', width: 15 },
                    { header: '作業月', key: 'workMonth', width: 12 },
                    { header: '対応名', key: 'task', width: 40 },
                    { header: '工程', key: 'process', width: 10 },
                    { header: '担当', key: 'member', width: 12 },
                    { header: '見積工数', key: 'hours', width: 12 }
                ];
                
                // ヘッダーのスタイル
                estimateSheet.getRow(1).font = { bold: true };
                estimateSheet.getRow(1).fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFD3D3D3' }
                };
                
                // 見積データを追加
                estimates.forEach(est => {
                    const normalized = normalizeEstimate(est);
                    
                    // 作業月の表示
                    let workMonthDisplay = '';
                    if (normalized.workMonths.length === 0) {
                        workMonthDisplay = '未設定';
                    } else if (normalized.workMonths.length === 1) {
                        const [y, m] = normalized.workMonths[0].split('-');
                        workMonthDisplay = `${y}年${parseInt(m)}月`;
                    } else {
                        const [y1, m1] = normalized.workMonths[0].split('-');
                        const [y2, m2] = normalized.workMonths[normalized.workMonths.length - 1].split('-');
                        workMonthDisplay = `${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月`;
                    }
                    
                    estimateSheet.addRow({
                        version: est.version,
                        workMonth: workMonthDisplay,
                        task: est.task,
                        process: est.process,
                        member: est.member,
                        hours: est.hours
                    });
                });
                
                // 罫線を追加
                estimateSheet.eachRow((row, rowNumber) => {
                    row.eachCell((cell) => {
                        cell.border = {
                            top: { style: 'thin' },
                            left: { style: 'thin' },
                            bottom: { style: 'thin' },
                            right: { style: 'thin' }
                        };
                    });
                });
                
                // ファイル名を生成
                const now = new Date();
                const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
                const filename = `工数管理_${timestamp}.xlsx`;
                
                // ファイルをダウンロード
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                alert('Excelファイルをダウンロードしました');
                
            } catch (error) {
                console.error('Excel出力エラー:', error);
                alert('Excelファイルの出力に失敗しました: ' + error.message);
            }
        }
        
        // 打ち合わせを全員分追加
        function addMeeting() {
            console.log('addMeeting called');
            const hours = parseFloat(document.getElementById('meetingHours').value);

            // カレンダーからの日付があればそれを使用、なければ今日の日付
            const modal = document.getElementById('otherWorkModal');
            let date;
            if (modal.dataset.calendarDate) {
                date = modal.dataset.calendarDate;
            } else {
                const today = new Date();
                date = today.toISOString().split('T')[0];
            }
            
            console.log('hours:', hours, 'date:', date);
            
            if (!hours || hours <= 0) {
                alert('工数を入力してください');
                return;
            }
            
            // 全担当者を取得
            const members = new Set();
            estimates.forEach(e => members.add(e.member));
            actuals.forEach(a => members.add(a.member));
            
            console.log('members:', Array.from(members));
            
            if (members.size === 0) {
                alert('担当者が登録されていません。先に見積または実績を登録してください。');
                return;
            }
            
            // 全担当者分の実績を追加
            let count = 0;
            members.forEach(member => {
                actuals.push({
                    id: Date.now() + count,
                    date: date,
                    version: '',  // 版数なし
                    task: '打ち合わせ',
                    process: '',
                    member: member,
                    hours: hours
                });
                count++;
            });
            
            console.log('actuals added, count:', count);
            
            saveData();
            renderActualList();
            renderTodayActuals();
            updateReport();
            
            // 入力欄をクリアしてモーダルを閉じる
            document.getElementById('meetingHours').value = '';
            closeOtherWorkModal();
            
            alert(`打ち合わせを${members.size}名分登録しました（${date}）`);
        }
        
        // その他作業を追加
        function addOtherWork() {
            console.log('addOtherWork called');
            const workName = document.getElementById('otherWorkName').value.trim();
            const member = document.getElementById('otherWorkMember').value;
            const hours = parseFloat(document.getElementById('otherWorkHours').value);

            // カレンダーからの日付があればそれを使用、なければ今日の日付
            const modal = document.getElementById('otherWorkModal');
            let date;
            if (modal.dataset.calendarDate) {
                date = modal.dataset.calendarDate;
            } else {
                const today = new Date();
                date = today.toISOString().split('T')[0];
            }
            
            console.log('workName:', workName, 'member:', member, 'hours:', hours, 'date:', date);
            
            if (!workName) {
                alert('作業名を入力してください');
                return;
            }
            
            if (!member) {
                alert('担当者を選択してください');
                return;
            }
            
            if (!hours || hours <= 0) {
                alert('工数を入力してください');
                return;
            }
            
            // その他作業を追加
            actuals.push({
                id: Date.now(),
                date: date,
                version: '',  // 版数なし
                task: workName,
                process: '',
                member: member,
                hours: hours
            });
            
            console.log('other work added');
            
            saveData();
            renderActualList();
            renderTodayActuals();
            updateReport();
            
            // 入力欄をクリアしてモーダルを閉じる
            document.getElementById('otherWorkName').value = '';
            document.getElementById('otherWorkMember').value = '';
            document.getElementById('otherWorkHours').value = '';
            closeOtherWorkModal();
            
            alert(`その他作業を登録しました（${date}）`);
        }
        
        // その他作業モーダルを開く
        function openOtherWorkModal() {
            // 担当者リストを更新
            const otherWorkMemberSelect = document.getElementById('otherWorkMember');
            if (otherWorkMemberSelect) {
                // 担当者を抽出
                const members = new Set();
                estimates.forEach(e => members.add(e.member));
                actuals.forEach(a => members.add(a.member));
                
                // 表示順でソート
                let sortedMembers;
                const memberOrderInput = document.getElementById('memberOrder').value.trim();
                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = [];
                    const unorderedMembers = [];
                    
                    orderList.forEach(name => {
                        if (members.has(name)) {
                            orderedMembers.push(name);
                        }
                    });
                    
                    Array.from(members).forEach(m => {
                        if (!orderedMembers.includes(m)) {
                            unorderedMembers.push(m);
                        }
                    });
                    
                    sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
                } else {
                    sortedMembers = Array.from(members).sort();
                }
                
                otherWorkMemberSelect.innerHTML = '<option value="">選択...</option>';
                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    otherWorkMemberSelect.appendChild(option);
                });
            }
            
            document.getElementById('otherWorkModal').style.display = 'flex';
            // 打ち合わせタブをアクティブにする
            switchOtherWorkTab('meeting');
        }
        
        // その他作業モーダルを閉じる
        function closeOtherWorkModal() {
            const modal = document.getElementById('otherWorkModal');
            modal.style.display = 'none';

            // カレンダー日付データをクリア
            delete modal.dataset.calendarDate;

            // モーダルタイトルをリセット
            document.querySelector('#otherWorkModal .modal-header h3').textContent = 'その他作業を登録';
        }
        
        // その他作業モーダルのタブを切り替え
        function switchOtherWorkTab(tab) {
            const meetingTab = document.getElementById('meetingTab');
            const customTab = document.getElementById('customTab');
            const meetingForm = document.getElementById('meetingForm');
            const customForm = document.getElementById('customForm');
            
            if (tab === 'meeting') {
                meetingTab.classList.add('active');
                customTab.classList.remove('active');
                meetingForm.style.display = 'block';
                customForm.style.display = 'none';
            } else {
                meetingTab.classList.remove('active');
                customTab.classList.add('active');
                meetingForm.style.display = 'none';
                customForm.style.display = 'block';
            }
        }
    </script>
</body>
</html>
