<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>工数管理システム</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@holiday-jp/holiday_jp/holiday_jp.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Yu Gothic', 'Meiryo', sans-serif;
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: #2c3e50;
            color: white;
            padding: 15px;
        }

        h1 {
            font-size: 22px;
            margin-bottom: 8px;
        }

        .header-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .tabs {
            display: flex;
            gap: 4px;
            background: #ecf0f1;
            padding: 8px;
            overflow-x: auto;
        }

        .tab {
            padding: 10px 16px;
            background: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }

        .tab.active {
            color: white;
        }

        /* テーマが適用されていないアクティブタブのフォールバック */
        .tab.active:not([class*="tab-theme-"]) {
            background: #3498db;
        }

        .content {
            padding: 15px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .form-group {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 4px;
            font-weight: 500;
            font-size: 13px;
        }

        input:not([type="radio"]):not([type="checkbox"]), select {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        input[type="radio"], input[type="checkbox"] {
            width: auto;
            padding: 0;
            margin: 0;
            cursor: pointer;
        }

        .quick-input {
            padding: 15px;
            border-radius: 10px;
            color: white;
            margin-bottom: 15px;
        }

        .quick-form {
            display: grid;
            gap: 8px;
            margin-top: 10px;
        }

        /* 見積テーブル用スタイル */
        .estimate-table {
            border-collapse: collapse;
            margin-bottom: 15px;
        }

        .estimate-table th {
            background: #e8f5e9;
            color: #2c3e50;
            font-size: 12px;
            font-weight: 600;
            padding: 8px;
            border-bottom: 2px solid #4caf50;
        }

        .estimate-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #eee;
        }

        .estimate-table select,
        .estimate-table input {
            padding: 6px 8px;
            font-size: 13px;
        }

        .table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            min-width: 600px;
        }

        th {
            background: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
            white-space: nowrap;
        }

        td {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
        }

        /* マトリクス表示用のスタイル */
        table tr td:first-child,
        table tr th:first-child {
            position: sticky;
            left: 0;
            background: white;
            z-index: 1;
        }

        table tr th:first-child {
            z-index: 2;
        }

        /* rowspan固定列の改善 - デスクトップでは改行しない */
        table td[rowspan] {
            white-space: nowrap;
            position: sticky;
            left: 0;
            z-index: 1;
        }

        /* タブレット以下で改行を許可 */
        @media (max-width: 1024px) {
            table td[rowspan] {
                white-space: normal;
                word-wrap: break-word;
                overflow-wrap: break-word;
                max-width: 14vw; /* 画面幅の14% (16%→14%) */
            }

            table tr td:first-child {
                max-width: 14vw;
                white-space: normal;
                word-wrap: break-word;
            }
        }

        /* モバイル用の固定列の幅制限 */
        @media (max-width: 768px) {
            /* 日別合計列を非表示にしてスペースを節約 */
            .daily-total {
                display: none !important;
            }

            /* すべてのth, tdのmin-widthをリセットしてコンパクトに */
            table th,
            table td {
                min-width: auto !important;
                padding: 4px 6px;
            }

            table td[rowspan] {
                max-width: 16vw; /* 画面幅の16% (18%→16%) */
                padding: 6px 4px;
            }

            table tr td:first-child,
            table tr th:first-child {
                max-width: 16vw;
                min-width: 70px !important; /* 固定列の最小幅を70pxに制限 (80→70) */
                padding: 6px 4px;
            }
        }

        /* 小型モバイル */
        @media (max-width: 480px) {
            /* パディングをさらに縮小 */
            table th,
            table td {
                padding: 3px 4px;
            }

            table td[rowspan] {
                max-width: 20vw; /* 画面幅の20% (25%→20%) */
                padding: 4px 3px;
            }

            table tr td:first-child,
            table tr th:first-child {
                max-width: 20vw;
                min-width: 60px !important; /* 固定列の最小幅を60pxに制限 (70→60) */
                padding: 4px 3px;
            }

            /* コンテンツエリアをさらに縮小 */
            .content {
                padding: 8px !important;
            }

            /* バージョンヘッダーをさらに縮小 */
            .version-header {
                padding: 6px 10px !important;
                font-size: 14px !important;
                margin-bottom: 8px !important;
            }

            /* カード要素をさらに縮小 */
            [style*="padding: 15px"],
            [style*="padding: 20px"],
            [style*="padding: 10px"] {
                padding: 8px !important;
            }

            /* フォントサイズを全体的に縮小 */
            h3 {
                font-size: 14px !important;
                margin-bottom: 8px !important;
            }
        }

        /* 週末・祝日の行の固定列背景色 */
        table tr[style*="ffebee"] td:first-child,
        table tr[style*="ffebee"] td[rowspan] {
            background: #ffebee;
        }

        /* 小計行 */
        table tr[style*="fff3cd"] td:first-child,
        table tr[style*="fff3cd"] td[rowspan] {
            background: #fff3cd;
        }

        /* 版数合計行（グレー背景） */
        table tr[style*="f5f5f5"] td:first-child {
            background: #f5f5f5;
        }

        /* 総合計行（濃いグレー） */
        table tr[style*="2c3e50"] td:first-child,
        table tr[style*="2c3e50"] td[rowspan] {
            background: #2c3e50;
            color: white;
        }

        /* 総合計行（青） */
        table tr[style*="1565c0"] td:first-child,
        table tr[style*="1565c0"] td[rowspan],
        table tr[style*="1565c0"] th:first-child {
            background: #1565c0;
            color: white;
        }

        /* 祝日表示のレスポンシブ制御 */
        /* デスクトップ: 1行で表示 */
        .holiday-inline {
            display: inline;
        }
        .holiday-break {
            display: none;
        }

        /* タブレット以下: 2行で表示 */
        @media (max-width: 1024px) {
            .holiday-inline {
                display: none;
            }
            .holiday-break {
                display: inline;
            }
        }

        /* 対応名の表示制御（祝日と同じ方式） */
        /* デスクトップ: 1行で表示 */
        .task-separator-inline {
            display: inline;
        }
        .task-separator-break {
            display: none;
        }

        /* タブレット以下: 「:」「：」で改行 */
        @media (max-width: 1024px) {
            .task-separator-inline {
                display: none;
            }
            .task-separator-break {
                display: inline;
            }
        }

        /* モーダル */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.2s;
            align-items: flex-start;
            justify-content: center;
            padding-top: 3%;
            box-sizing: border-box;
        }

        .custom-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 6px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            margin-top: 4px;
        }

        .custom-dropdown-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background-color 0.2s;
            font-size: 14px;
            color: #333;
        }

        .custom-dropdown-item:last-child {
            border-bottom: none;
        }

        .custom-dropdown-item:hover {
            background-color: #e3f2fd;
            color: #000;
        }

        .custom-dropdown-item.selected {
            background-color: #e3f2fd;
            color: #000;
        }

        .custom-dropdown-empty {
            padding: 20px;
            text-align: center;
            color: #999;
            font-size: 14px;
        }

        #quickTaskSearch {
            cursor: text;
        }

        #quickTaskSearch:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .modal-content {
            background-color: white;
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s;
        }

        /* カスタムアラート */
        .custom-alert-content {
            background-color: white;
            padding: 0;
            border-radius: 4px;
            width: 90%;
            max-width: 360px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            border: 1px solid #ccc;
        }

        .custom-alert-body {
            padding: 20px;
            text-align: center;
            font-size: 14px;
            color: #333;
            line-height: 1.5;
        }

        .custom-alert-footer {
            padding: 0 20px 20px;
            text-align: center;
        }

        .custom-alert-footer .btn {
            min-width: 80px;
            padding: 6px 20px;
            font-size: 14px;
        }

        .modal-header {
            color: white;
            padding: 12px 20px;
            border-radius: 12px 12px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* モーダルヘッダーのデフォルト色（テーマ適用前） */
        .modal-header:not([class*="modal-theme-"]) {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* モーダル用テーマ色 */
        .modal-theme-purple { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .modal-theme-deep-blue { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .modal-theme-teal { background: linear-gradient(135deg, #0f766e 0%, #14b8a6 100%); }
        .modal-theme-cyan { background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); }
        .modal-theme-ocean { background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%); }
        .modal-theme-sky { background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); }
        .modal-theme-indigo { background: linear-gradient(135deg, #4338ca 0%, #6366f1 100%); }
        .modal-theme-navy { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); }
        .modal-theme-slate { background: linear-gradient(135deg, #334155 0%, #475569 100%); }
        .modal-theme-green { background: linear-gradient(135deg, #047857 0%, #10b981 100%); }
        .modal-theme-emerald { background: linear-gradient(135deg, #059669 0%, #34d399 100%); }

        .modal-header h3 {
            margin: 0;
            font-size: 18px;
        }

        .modal-close {
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: 30px;
            height: 30px;
            line-height: 30px;
            text-align: center;
        }

        .modal-close:hover {
            opacity: 0.8;
        }

        .modal-body {
            padding: 15px 20px;
            overflow-y: auto;
            max-height: 75vh;
        }

        .work-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }

        .work-item:last-child {
            margin-bottom: 0;
        }

        .work-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .work-item-title {
            font-weight: 600;
            font-size: 15px;
            color: #2c3e50;
        }

        .work-item-hours {
            font-size: 18px;
            font-weight: 700;
            color: #3498db;
        }

        .work-item-details {
            font-size: 13px;
            color: #666;
            line-height: 1.6;
        }

        .work-item-details span {
            display: inline-block;
            margin-right: 12px;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .badge {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .badge-ui { background: #e3f2fd; color: #1976d2; }
        .badge-pg { background: #f3e5f5; color: #7b1fa2; }
        .badge-pt { background: #fff3e0; color: #f57c00; }
        .badge-it { background: #e8f5e9; color: #388e3c; }
        .badge-st { background: #fce4ec; color: #c2185b; }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            padding: 20px;
            border-radius: 10px;
            color: white;
        }

        .stat-card h3 {
            font-size: 14px;
            margin-bottom: 10px;
        }

        .stat-card .value {
            font-size: 32px;
            font-weight: 700;
        }

        /* モバイル用レポート集計カードの最適化 */
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
                gap: 10px;
                margin-bottom: 15px;
            }

            .stat-card {
                padding: 12px;
                border-radius: 8px;
            }

            .stat-card h3 {
                font-size: 11px;
                margin-bottom: 6px;
            }

            .stat-card .value {
                font-size: 22px;
            }

            .stat-card > div:last-child {
                font-size: 10px !important;
            }

            /* レポート分析パネルのモバイル最適化 */
            #reportDetailView > div {
                margin: 15px 0 !important;
                padding: 15px !important;
            }

            #reportDetailView h3 {
                font-size: 15px !important;
            }

            #reportDetailView h4 {
                font-size: 14px !important;
            }

            /* 担当者パフォーマンスグリッドの最小幅を調整 */
            #reportDetailView [style*="grid-template-columns"] {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)) !important;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
            }

            h1 {
                font-size: 18px;
            }

            .header-buttons {
                flex-direction: column;
            }

            .header-buttons .btn {
                width: 100%;
            }

            .quick-form {
                grid-template-columns: 1fr;
            }

            /* モバイルでのモーダル余白を縮小 */
            .modal-content {
                margin: 2% auto;
                width: 95%;
            }

            /* 見積テーブルのモバイル対応 */
            .estimate-table-wrapper {
                /* overflow-x削除で全列表示 */
            }

            .estimate-table {
                display: table;
                table-layout: fixed;
                width: 100%;
                min-width: 100%;
            }

            .estimate-table th,
            .estimate-table td {
                padding: 4px 6px;
            }

            /* 見積登録の各列幅をモバイル用に調整 */
            .estimate-table th:nth-child(1),
            .estimate-table td:nth-child(1) {
                width: 20%;
            }

            .estimate-table th:nth-child(2),
            .estimate-table td:nth-child(2) {
                width: 42%;
            }

            .estimate-table th:nth-child(3),
            .estimate-table td:nth-child(3) {
                width: 38%;
            }

            .estimate-table td:nth-child(2) select {
                font-size: 12px;
                padding: 4px 6px;
                width: 100%;
                box-sizing: border-box;
            }

            .estimate-table td:nth-child(3) input {
                font-size: 12px;
                padding: 4px 6px;
                width: 100%;
                box-sizing: border-box;
            }

            table {
                font-size: 13px;
            }

            /* 見積一覧グループ・マトリクス表示専用のモバイル最適化 */
            table.estimate-grouped,
            table.estimate-matrix {
                min-width: 100% !important;
            }

            table.estimate-grouped th,
            table.estimate-grouped td,
            table.estimate-matrix th,
            table.estimate-matrix td {
                padding: 4px 3px !important;
            }

            /* 実績一覧カレンダー表示専用のモバイル最適化 */
            table.actual-matrix {
                min-width: 100% !important;
            }

            table.actual-matrix th,
            table.actual-matrix td {
                padding: 4px 3px !important;
            }

            /* 日付列（固定幅） */
            table.actual-matrix th:first-child,
            table.actual-matrix td:first-child {
                width: 70px !important;
                min-width: 70px !important;
                max-width: 70px !important;
                padding: 4px 3px !important;
            }

            /* 担当者列・合計列 */
            table.actual-matrix th:not(:first-child),
            table.actual-matrix td:not(:first-child) {
                width: 55px !important;
                min-width: 55px !important;
                max-width: 55px !important;
                text-align: center !important;
            }

            /* 対応名列（rowspan） - グループ表示専用 */
            table.estimate-grouped td[rowspan]:first-child,
            table.estimate-grouped td[rowspan]:nth-child(2) {
                width: 85px !important;
                min-width: 85px !important;
                max-width: 85px !important;
                padding: 6px 4px !important;
            }

            /* 工程列 - グループ表示専用 */
            table.estimate-grouped td:not([rowspan]):nth-child(2),
            table.estimate-grouped td:not([rowspan]):nth-child(3) {
                width: 50px !important;
                min-width: 50px !important;
                max-width: 50px !important;
            }

            /* 担当列 - グループ表示専用 */
            table.estimate-grouped td:not([rowspan]):nth-child(3),
            table.estimate-grouped td:not([rowspan]):nth-child(4) {
                width: 50px !important;
                min-width: 50px !important;
                max-width: 50px !important;
            }

            /* 工数列 - グループ表示専用 */
            table.estimate-grouped td:not([rowspan]):nth-child(4),
            table.estimate-grouped td:not([rowspan]):nth-child(5) {
                width: 45px !important;
                min-width: 45px !important;
                max-width: 45px !important;
            }

            /* 対応合計列（rowspan、編集モードOFF時は最後の列） - グループ表示専用 */
            table.estimate-grouped td[rowspan]:nth-last-child(1) {
                width: 75px !important;
                padding: 6px 4px !important;
                min-width: 75px !important;
                max-width: 75px !important;
            }

            /* 対応合計列（rowspan、編集モードON時は最後から2番目の列） - グループ表示専用 */
            table.estimate-grouped td[rowspan]:nth-last-child(2) {
                width: 75px !important;
                padding: 6px 4px !important;
                min-width: 75px !important;
                max-width: 75px !important;
            }

            /* 対応合計のフォントサイズを縮小 - グループ表示専用 */
            table.estimate-grouped td[rowspan] > div:first-child {
                font-size: 14px !important;
            }

            table.estimate-grouped td[rowspan] > div:last-child {
                font-size: 10px !important;
            }

            /* 対応合計の人日/人月を縦並びにする */
            #estimateList .manpower-display {
                display: flex !important;
                flex-direction: column !important;
                line-height: 1.4 !important;
            }

            /* 操作列（編集モードON時のみ表示） - グループ表示専用 */
            table.estimate-grouped td:last-child {
                width: 65px !important;
                min-width: 65px !important;
                max-width: 65px !important;
            }

            /* コンテンツエリアのパディングを縮小 */
            .content {
                padding: 10px;
            }

            /* バージョンヘッダーのパディングを縮小 */
            .version-header {
                padding: 8px 12px !important;
                font-size: 16px !important;
                margin-bottom: 10px !important;
            }

            /* カード要素のパディング・マージンを縮小 */
            [style*="padding: 15px"],
            [style*="padding: 20px"] {
                padding: 10px !important;
            }

            /* h3のマージンを縮小 */
            h3 {
                margin-bottom: 10px !important;
            }

            /* 作業月割り当てモードのモバイル対応 */
            #workMonthAssignmentMode > div {
                flex-direction: column;
                align-items: stretch !important;
            }

            #workMonthAssignmentMode > div > div,
            #workMonthAssignmentMode > div > button {
                width: 100%;
            }

            #selectedWorkHours {
                margin-left: 0 !important;
                margin-top: 10px;
                text-align: center;
            }
        }
        
        /* テーマカラー用CSS */
        .theme-bg {
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        /* 色の定義 */
        .theme-purple { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .theme-deep-blue { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .theme-teal { background: linear-gradient(135deg, #0f766e 0%, #14b8a6 100%); }
        .theme-cyan { background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); }
        .theme-ocean { background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%); }
        .theme-sky { background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); }
        .theme-indigo { background: linear-gradient(135deg, #4338ca 0%, #6366f1 100%); }
        .theme-navy { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); }
        .theme-slate { background: linear-gradient(135deg, #334155 0%, #475569 100%); }
        .theme-green { background: linear-gradient(135deg, #047857 0%, #10b981 100%); }
        .theme-emerald { background: linear-gradient(135deg, #059669 0%, #34d399 100%); }
        
        /* タブ用の色クラス（模様なし、position/overflowなし） */
        .tab-theme-purple { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .tab-theme-deep-blue { background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); }
        .tab-theme-teal { background: linear-gradient(135deg, #0f766e 0%, #14b8a6 100%); }
        .tab-theme-cyan { background: linear-gradient(135deg, #0891b2 0%, #06b6d4 100%); }
        .tab-theme-ocean { background: linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%); }
        .tab-theme-sky { background: linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%); }
        .tab-theme-indigo { background: linear-gradient(135deg, #4338ca 0%, #6366f1 100%); }
        .tab-theme-navy { background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); }
        .tab-theme-slate { background: linear-gradient(135deg, #334155 0%, #475569 100%); }
        .tab-theme-green { background: linear-gradient(135deg, #047857 0%, #10b981 100%); }
        .tab-theme-emerald { background: linear-gradient(135deg, #059669 0%, #34d399 100%); }
        
        /* グロー効果 */
        .theme-cyan.pattern-glow { box-shadow: 0 4px 20px rgba(8, 145, 178, 0.3); }
        
        /* 模様の定義 */
        .theme-bg.pattern-wave::before {
            content: '';
            position: absolute;
            top: -30%;
            right: -5%;
            width: 150px;
            height: 150px;
            background: rgba(255,255,255,0.08);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-wave::after {
            content: '';
            position: absolute;
            bottom: -20%;
            left: -5%;
            width: 100px;
            height: 100px;
            background: rgba(255,255,255,0.05);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-stripe::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            width: 3px;
            background: rgba(255,255,255,0.25);
            pointer-events: none;
        }
        
        .theme-bg.pattern-corner::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.12);
            border-radius: 0 10px 0 100%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-dot::before {
            content: '';
            position: absolute;
            top: 20px;
            right: 20px;
            width: 10px;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
        }
        
        .theme-bg.pattern-dots::before {
            content: '';
            position: absolute;
            top: 20px;
            right: 20px;
            width: 8px;
            height: 8px;
            background: rgba(255,255,255,0.25);
            border-radius: 50%;
            box-shadow: 18px 0 0 rgba(255,255,255,0.25), 36px 0 0 rgba(255,255,255,0.25);
            pointer-events: none;
        }
        
        .theme-bg.pattern-diagonal::before {
            content: '';
            position: absolute;
            top: -20px;
            right: 40px;
            width: 80px;
            height: 150%;
            background: rgba(255,255,255,0.06);
            transform: skewX(-15deg);
            pointer-events: none;
        }
        
        .theme-bg.pattern-circle::before {
            content: '';
            position: absolute;
            top: 50%;
            right: -30px;
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.05);
            border-radius: 50%;
            transform: translateY(-50%);
            pointer-events: none;
        }
        
        .theme-bg.pattern-layer::before {
            content: '';
            position: absolute;
            top: 0;
            right: -60px;
            width: 180px;
            height: 100%;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.04) 100%);
            transform: skewX(-20deg);
            pointer-events: none;
        }
        
        .theme-bg.pattern-line::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.4) 50%, transparent 100%);
            pointer-events: none;
        }
        
        .theme-bg.pattern-bar {
            border-left: 3px solid rgba(255,255,255,0.35);
        }
        
        .theme-bg.pattern-border {
            border-top: 2px solid rgba(255,255,255,0.25);
        }
        
        .theme-bg.pattern-glow::after {
            content: '';
            position: absolute;
            top: -20%;
            right: -10%;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
            pointer-events: none;
        }
        
        /* 作業月表示 */
        /* PC・モバイル共通: 次の行に表示 */
        .work-month-inline {
            display: none;
        }
        .work-month-block {
            display: block;
        }
        
        /* その他作業モーダル用スタイル */
        .other-work-tab {
            padding: 10px 20px;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 14px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .other-work-tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
            font-weight: 600;
        }
        
        .other-work-tab:hover {
            color: #3498db;
        }
        
        .other-work-form {
            animation: fadeIn 0.3s;
        }

        /* セグメントボタンコンテナのスクロールバースタイル */
        #estimateMonthButtons2,
        #actualMemberButtons2,
        #actualMonthButtons2,
        #reportMonthButtons2 {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 #f1f5f9;
            -webkit-overflow-scrolling: touch;
        }

        #estimateMonthButtons2::-webkit-scrollbar,
        #actualMemberButtons2::-webkit-scrollbar,
        #actualMonthButtons2::-webkit-scrollbar,
        #reportMonthButtons2::-webkit-scrollbar {
            height: 6px;
        }

        #estimateMonthButtons2::-webkit-scrollbar-track,
        #actualMemberButtons2::-webkit-scrollbar-track,
        #actualMonthButtons2::-webkit-scrollbar-track,
        #reportMonthButtons2::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        #estimateMonthButtons2::-webkit-scrollbar-thumb,
        #actualMemberButtons2::-webkit-scrollbar-thumb,
        #actualMonthButtons2::-webkit-scrollbar-thumb,
        #reportMonthButtons2::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }

        #estimateMonthButtons2::-webkit-scrollbar-thumb:hover,
        #actualMemberButtons2::-webkit-scrollbar-thumb:hover,
        #actualMonthButtons2::-webkit-scrollbar-thumb:hover,
        #reportMonthButtons2::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* ドーナツグラフのcanvasサイズ設定 */
        .donut-chart-canvas {
            max-width: 100%;
            height: 200px;
        }

        /* PC表示時のドーナツグラフを大きく */
        @media (min-width: 768px) {
            .donut-chart-canvas {
                height: 280px;
            }
        }

        /* フィルタ部分のSticky表示（スクロール監視で動的に適用） */
        .sticky-filter-container {
            background: white;
            padding-bottom: 10px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .sticky-filter-container.is-sticky {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 10px 15px;
            margin: 0;
        }

        /* Sticky時のプレースホルダー（レイアウト崩れ防止） */
        .sticky-placeholder {
            display: none;
        }

        .sticky-placeholder.active {
            display: block;
        }

        /* フローティングフィルタパネル */
        .floating-filter-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--theme-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: pointer;
            display: none; /* レポートタブでのみ表示 */
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 1100;
            opacity: 0;
            transition: transform 0.2s, box-shadow 0.2s, opacity 0.3s;
        }

        .floating-filter-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
            opacity: 1;
        }

        .floating-filter-toggle:active {
            transform: translateY(0);
        }

        .floating-filter-panel {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 340px;
            max-height: 70vh;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            z-index: 1099;
            display: none;
            overflow: hidden;
            animation: slideUp 0.3s ease-out;
        }

        .floating-filter-panel.show {
            display: block;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .floating-filter-panel-header {
            background: var(--theme-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
            color: white;
            padding: 12px 16px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .floating-filter-panel-close {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .floating-filter-panel-close:hover {
            opacity: 1;
        }

        .floating-filter-panel-body {
            padding: 16px;
            overflow-y: auto;
            max-height: calc(70vh - 48px);
        }

        .floating-filter-group {
            margin-bottom: 16px;
        }

        .floating-filter-group:last-child {
            margin-bottom: 0;
        }

        .floating-filter-label {
            font-size: 12px;
            font-weight: 600;
            color: #666;
            margin-bottom: 6px;
            display: block;
        }

        .floating-filter-select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 13px;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .floating-filter-select:hover {
            border-color: #667eea;
        }

        .floating-filter-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .floating-filter-buttons {
            display: flex;
            gap: 8px;
        }

        .floating-filter-buttons button {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            background: white;
            transition: all 0.2s;
        }

        .floating-filter-buttons button.active {
            background: var(--theme-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
            color: white;
            border-color: transparent;
        }

        .floating-filter-buttons button:hover:not(.active) {
            border-color: var(--theme-color, #667eea);
            background: #f8f9ff;
        }

        /* 動的ボタン用コンテナ */
        .floating-segment-buttons {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding: 2px 0;
            flex-wrap: nowrap;
        }

        .floating-segment-buttons::-webkit-scrollbar {
            height: 4px;
        }

        .floating-segment-buttons::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .floating-segment-buttons::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        .floating-segment-buttons button {
            flex-shrink: 0;
            padding: 6px 12px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
        }

        .floating-segment-buttons button.active {
            background: var(--theme-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
            color: white;
            border-color: transparent;
        }

        .floating-segment-buttons button:hover:not(.active) {
            border-color: var(--theme-color, #667eea);
            background: #f8f9ff;
        }

        /* 各タブのセグメントボタン共通スタイル */
        .segment-buttons {
            display: inline-flex;
            gap: 6px;
            overflow-x: auto;
            padding: 0;
            flex-wrap: nowrap;
        }

        .segment-buttons::-webkit-scrollbar {
            height: 4px;
        }

        .segment-buttons::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .segment-buttons::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }

        .segment-buttons button {
            flex-shrink: 0;
            padding: 6px 12px;
            font-size: 11px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            color: #333;
            cursor: pointer;
            transition: all 0.2s;
        }

        .segment-buttons button.active {
            background: var(--theme-gradient, linear-gradient(135deg, #667eea 0%, #764ba2 100%));
            color: white;
            border-color: transparent;
        }

        .segment-buttons button:hover:not(.active) {
            border-color: var(--theme-color, #667eea);
            background: #f8f9ff;
        }

        /* モバイル対応 */
        @media (max-width: 768px) {
            .floating-filter-panel {
                width: calc(100vw - 40px);
                right: 20px;
                left: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>工数管理システム</h1>
            <div class="header-buttons">
                <button class="btn btn-success" onclick="exportBackup()">バックアップ</button>
                <button class="btn btn-primary" onclick="importBackup()">復元</button>
            </div>
        </header>

        <div class="tabs">
            <button class="tab active tab-theme-purple" onclick="showTab('quick')">クイック入力</button>
            <button class="tab" onclick="showTab('estimate')">見積一覧</button>
            <button class="tab" onclick="showTab('actual')">実績一覧</button>
            <button class="tab" onclick="showTab('report')">レポート</button>
            <button class="tab" onclick="showTab('settings')">⚙️ 設定</button>
        </div>

        <div class="content">
            <div id="quick" class="tab-content active">
                <div class="quick-input theme-bg theme-purple">
                    <h2 id="quickModeTitle">今日の実績を入力</h2>

                    <!-- セグメントボタンを右側に配置 -->
                    <div style="display: flex; justify-content: flex-end; margin-bottom: 20px;">
                        <div class="segment-buttons">
                            <button id="quickActualModeBtn" class="active" onclick="switchQuickInputMode('actual')">実績入力</button>
                            <button id="quickEstimateModeBtn" onclick="switchQuickInputMode('estimate')">見積登録</button>
                            <button id="quickVacationModeBtn" onclick="switchQuickInputMode('vacation')">休暇登録</button>
                        </div>
                    </div>

                    <!-- 実績入力フォーム -->
                    <div id="quickActualForm" class="quick-form">
                        <div class="form-group">
                            <label>対応検索・選択</label>
                            <div style="position: relative;">
                                <input 
                                    type="text" 
                                    id="quickTaskSearch" 
                                    placeholder="クリックして対応を選択..." 
                                    autocomplete="off"
                                    oninput="filterQuickTaskList()"
                                    onclick="showQuickTaskDropdown()"
                                    style="padding-right: 35px;">
                                <button 
                                    id="quickTaskClearBtn"
                                    onclick="clearQuickTaskSelection()"
                                    style="display: none; position: absolute; right: 8px; top: 50%; transform: translateY(-50%); background: none; border: none; color: #999; cursor: pointer; font-size: 18px; padding: 4px 8px; line-height: 1;"
                                    title="クリア">×</button>
                                <div id="quickTaskDropdown" class="custom-dropdown" style="display: none;">
                                    <!-- JavaScriptで動的に生成 -->
                                </div>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div class="form-group">
                                <label>担当</label>
                                <select id="quickMemberSelect" onchange="handleMemberChange()">
                                    <option value="">（自動）</option>
                                </select>
                                <small style="color: #999; font-size: 11px;">通常は自動、必要時のみ変更</small>
                            </div>
                            <div class="form-group">
                                <label>実績工数 (h)</label>
                                <input type="number" id="quickHours" step="0.5" min="0" value="8">
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-success" onclick="quickAddActual()" style="flex: 2;">追加</button>
                            <button class="btn" onclick="openOtherWorkModal()" style="flex: 1; background: rgba(255,255,255,0.2); color: white;">その他</button>
                        </div>
                    </div>

                    <!-- 見積登録フォーム -->
                    <div id="quickEstimateForm" class="quick-form" style="display: none;">
                        <div class="form-group">
                            <label>版数</label>
                            <select id="quickEstVersion" onchange="handleVersionChange('quickEstVersion')">
                                <option value="">-- 版数を選択 --</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>帳票名</label>
                            <select id="quickEstFormNameSelect" onchange="handleQuickFormNameChange()" style="background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white;">
                                <option value="">-- 帳票名を選択 --</option>
                                <option value="__new__">新規入力</option>
                            </select>
                            <input type="text" id="quickEstFormName" placeholder="帳票A" style="background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white; display: none;">
                            <small style="color: rgba(255,255,255,0.7); display: block; margin-top: 5px; font-size: 11px;">既存の帳票名を選択、または新規入力できます</small>
                        </div>
                        <div class="form-group">
                            <label>対応名</label>
                            <input type="text" id="quickEstTask" placeholder="X対応" style="background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white;">
                        </div>
                        <div class="form-group">
                            <label>作業月</label>
                            <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="quickEstMonthType" value="single" checked onchange="switchQuickEstMonthType()" style="width: auto; margin-right: 4px;">
                                    <span style="color: rgba(255,255,255,0.75); font-size: 11px;">単一月</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="quickEstMonthType" value="multi" onchange="switchQuickEstMonthType()" style="width: auto; margin-right: 4px;">
                                    <span style="color: rgba(255,255,255,0.75); font-size: 11px;">複数月</span>
                                </label>
                            </div>
                            <div id="quickEstMonthInputs">
                                <div id="quickEstSingleMonthInput" style="display: block;">
                                    <select id="quickEstStartMonth" onchange="updateQuickEstWorkMonthUI()"></select>
                                </div>
                                <div id="quickEstMultiMonthInput" style="display: none;">
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <select id="quickEstStartMonthMulti" onchange="updateQuickEstWorkMonthUI()"></select>
                                        <span>〜</span>
                                        <select id="quickEstEndMonth" onchange="updateQuickEstWorkMonthUI()"></select>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <h4 style="margin-bottom: 10px; color: rgba(255,255,255,0.9);">各工程の見積</h4>
                        <div class="estimate-table-wrapper">
                            <table class="estimate-table" id="quickEstimateTable" style="width: 100%; margin: 0;">
                                <thead>
                                    <tr>
                                        <th style="width: 60px; padding: 8px; text-align: center;">工程</th>
                                        <th style="width: 120px; padding: 8px;">担当</th>
                                        <th style="width: 100px; padding: 8px;">時間</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-ui">UI</span></td>
                                        <td><select id="quickEstUI_member" style="margin: 0;"></select></td>
                                        <td><input type="number" id="quickEstUI" placeholder="h" step="0.5" style="margin: 0;" oninput="updateQuickEstimateTotals()"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-pg">PG</span></td>
                                        <td><select id="quickEstPG_member" style="margin: 0;" onchange="autoFillMember('quickEstPG_member')"></select></td>
                                        <td><input type="number" id="quickEstPG" placeholder="h" step="0.5" style="margin: 0;" oninput="updateQuickEstimateTotals()"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-pt">PT</span></td>
                                        <td><select id="quickEstPT_member" style="margin: 0;" onchange="autoFillMember('quickEstPT_member')"></select></td>
                                        <td><input type="number" id="quickEstPT" placeholder="h" step="0.5" style="margin: 0;" oninput="updateQuickEstimateTotals()"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-it">IT</span></td>
                                        <td><select id="quickEstIT_member" style="margin: 0;" onchange="autoFillMember('quickEstIT_member')"></select></td>
                                        <td><input type="number" id="quickEstIT" placeholder="h" step="0.5" style="margin: 0;" oninput="updateQuickEstimateTotals()"></td>
                                    </tr>
                                    <tr>
                                        <td style="text-align: center; font-weight: 600;"><span class="badge badge-st">ST</span></td>
                                        <td><select id="quickEstST_member" style="margin: 0;" onchange="autoFillMember('quickEstST_member')"></select></td>
                                        <td><input type="number" id="quickEstST" placeholder="h" step="0.5" style="margin: 0;" oninput="updateQuickEstimateTotals()"></td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- 合計表示エリア -->
                        <div id="quickEstimateTotals" style="background: rgba(25, 118, 210, 0.15); padding: 12px 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #1976d2;">
                            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                                <span style="font-weight: 600; color: rgba(255,255,255,0.9);">対応合計:</span>
                                <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                                    <span style="color: rgba(255,255,255,0.95);"><strong id="quickEstTotalHours">0.0</strong> h</span>
                                    <span style="color: rgba(255,255,255,0.8);">(<span id="quickEstTotalDays">0.0</span> 人日)</span>
                                    <span style="color: rgba(255,255,255,0.8);">(<span id="quickEstTotalMonths">0.00</span> 人月)</span>
                                </div>
                            </div>
                        </div>

                        <!-- 月分割アシスタント -->
                        <div style="background: rgba(251, 146, 60, 0.15); padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #fb923c;">
                            <div class="form-group" style="margin-bottom: 10px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="quickEnableMonthSplit" onchange="toggleQuickMonthSplit()" style="width: auto; margin-right: 10px;">
                                    <span style="font-weight: 600; color: #ea580c;">📅 複数月に分割して登録</span>
                                </label>
                                <small style="color: rgba(255,255,255,0.8); display: block; margin-top: 5px;">
                                    一つの工程を複数月で作業する場合に、月別の工数を設定できます
                                </small>
                            </div>

                            <div id="quickMonthSplitPanel" style="display: none; margin-top: 15px;">
                                <div class="form-group">
                                    <label>分割する工程を選択</label>
                                    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitUI" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>UI</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitPG" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>PG</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitPT" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>PT</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitIT" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>IT</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="checkbox" id="quickSplitST" class="quick-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                            <span>ST</span>
                                        </label>
                                    </div>
                                    <small style="color: rgba(255,255,255,0.7); display: block; margin-top: 5px;">
                                        チェックした工程のみが月分割されます。チェックしていない工程は通常通り登録されます。
                                    </small>
                                </div>

                                <div class="form-group">
                                    <label>総工数</label>
                                    <input type="number" id="quickTotalHours" step="0.1" min="0" placeholder="例: 80" oninput="updateQuickMonthPreview()">
                                    <span style="margin-left: 5px;">時間</span>
                                </div>

                                <div class="form-group">
                                    <label>作業期間</label>
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <select id="quickStartMonth" onchange="updateQuickMonthPreview()"></select>
                                        <span>〜</span>
                                        <select id="quickEndMonth" onchange="updateQuickMonthPreview()"></select>
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label>分割方法</label>
                                    <div style="display: flex; gap: 20px;">
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="radio" name="quickSplitMethod" value="equal" checked onchange="updateQuickMonthPreview()" style="width: auto; margin-right: 5px;">
                                            <span>均等分割</span>
                                        </label>
                                        <label style="display: flex; align-items: center; cursor: pointer;">
                                            <input type="radio" name="quickSplitMethod" value="manual" onchange="updateQuickMonthPreview()" style="width: auto; margin-right: 5px;">
                                            <span>手動設定</span>
                                        </label>
                                    </div>
                                </div>

                                <div id="quickMonthPreview" style="margin-top: 15px;"></div>
                            </div>
                        </div>

                        <button class="btn" onclick="addQuickEstimate()" style="margin-top: 15px; background: rgba(255,255,255,0.9); color: #7b3ff2; font-weight: 600;">登録</button>
                    </div>

                    <!-- 休暇登録フォーム -->
                    <div id="quickVacationForm" class="quick-form" style="display: none;">
                        <div class="form-group">
                            <label>担当者</label>
                            <select id="quickVacationMember">
                            </select>
                        </div>
                        <div class="form-group">
                            <label>日付</label>
                            <input type="date" id="quickVacationDate" style="max-width: 200px;">
                        </div>
                        <div class="form-group">
                            <label>休暇タイプ</label>
                            <select id="quickVacationType" onchange="handleVacationTypeChange()">
                                <option value="有休">有給休暇（有休）</option>
                                <option value="特休">特別休暇（特休）</option>
                                <option value="代休">代休（代休）</option>
                                <option value="振休">振替休日（振休）</option>
                                <option value="時間休">時間休</option>
                            </select>
                        </div>
                        <div class="form-group" id="quickVacationHoursGroup">
                            <label>時間数 (h)</label>
                            <input type="number" id="quickVacationHours" step="1" min="1" placeholder="1" value="8">
                            <small style="color: rgba(255,255,255,0.8); display: block; margin-top: 5px;">
                                時間休は1h単位で入力してください。全日休暇は8hです。
                            </small>
                        </div>
                        <button class="btn" onclick="addQuickVacation()" style="background: rgba(255,255,255,0.9); color: #7b3ff2; font-weight: 600;">登録</button>
                    </div>
                </div>

                <h3 id="quickBottomTitle">今日の入力済み実績</h3>
                <div id="todayActuals"></div>
            </div>

            <div id="estimate" class="tab-content">
                <h2>見積一覧</h2>

                <!-- 合計工数表示 -->
                <div id="estimateTotalCard" style="color: white; padding: 15px 20px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">合計工数</div>
                            <div style="font-size: 28px; font-weight: bold;" id="estimateTotalHours">0h</div>
                        </div>
                        <div>
                            <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">人日 / 人月</div>
                            <div style="font-size: 18px; font-weight: 600;" id="estimateTotalManpower">0人日 / 0人月</div>
                        </div>
                    </div>
                </div>

                <!-- 担当者別合計表示 -->
                <div id="estimateMemberSummary" style="background: #f8f9fa; padding: 15px 20px; border-radius: 8px; margin-bottom: 20px; display: none;">
                    <div style="font-size: 14px; font-weight: 600; color: #495057; margin-bottom: 10px;">担当者別合計</div>
                    <div id="estimateMemberSummaryContent" style="display: flex; flex-wrap: wrap; gap: 12px;">
                    </div>
                </div>

                <!-- 新規登録ボタン -->
                <button class="btn btn-primary" onclick="openAddEstimateModal()" style="margin-bottom: 15px; font-weight: 600; display: inline-flex; align-items: center; gap: 6px;">
                    <span style="font-size: 16px;">+</span> 新規登録
                </button>

                <!-- バージョン1: 横並びコンパクトレイアウト -->
                <div id="estimateFiltersCompact" class="sticky-filter-container" style="margin-bottom: 20px;">
                    <div style="display: flex; flex-wrap: nowrap; gap: 10px; align-items: center; background: #f8f9fa; padding: 10px; border-radius: 6px; overflow-x: auto;">
                        <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                            <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">フィルタ:</label>
                            <select id="estimateFilterType" onchange="handleEstimateFilterTypeChange()" style="padding: 3px 6px; font-size: 12px;">
                                <option value="month">月別</option>
                                <option value="version">版数別</option>
                            </select>
                        </div>
                        <div id="estimateMonthFilterCompact" style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                            <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示月:</label>
                            <select id="estimateMonthFilter" onchange="handleEstimateMonthFilterChange()" style="padding: 3px 6px; font-size: 12px;">
                                <option value="all">全期間</option>
                            </select>
                        </div>
                        <div id="estimateVersionFilterCompact" style="display: none; align-items: center; gap: 5px; flex-shrink: 0;">
                            <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">版数:</label>
                            <select id="estimateVersionFilter" onchange="handleEstimateVersionFilterChange()" style="padding: 3px 6px; font-size: 12px;">
                                <option value="all">全版数</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                            <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <select id="estimateViewType" onchange="renderEstimateList()" style="padding: 3px 6px; font-size: 12px;">
                                <option value="grouped">グループ</option>
                                <option value="matrix">マトリクス</option>
                                <option value="list">リスト</option>
                            </select>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 15px; margin-top: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer; user-select: none; font-size: 12px; font-weight: 500; white-space: nowrap;">
                            <input type="checkbox" id="workMonthSelectionMode" onchange="toggleWorkMonthSelectionMode()" style="width: auto; margin-right: 5px;">
                            <span>作業月割り当て</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; user-select: none; font-size: 12px; font-weight: 500; white-space: nowrap;">
                            <input type="checkbox" id="estimateEditMode" onchange="toggleEstimateEditMode()" style="width: auto; margin-right: 5px;">
                            <span>編集モード</span>
                        </label>
                    </div>
                </div>

                <!-- バージョン2: セグメントボタンレイアウト（切り替え用） -->
                <div id="estimateFiltersSegmented" class="sticky-filter-container" style="display: none; margin-bottom: 20px; background: #f8f9fa; padding: 12px; border-radius: 6px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">フィルタ:</label>
                            <div class="segment-buttons">
                                <button onclick="setEstimateFilterType('month')" id="btnEstimateFilterMonth" class="active">月別</button>
                                <button onclick="setEstimateFilterType('version')" id="btnEstimateFilterVersion">版数別</button>
                            </div>
                        </div>

                        <div id="estimateMonthFilterSegmented" style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示月:</label>
                            <!-- セグメントボタン版 -->
                            <div id="estimateMonthButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: min(800px, calc(100vw - 130px));">
                            </div>
                            <!-- Select版（セグメントボタン生成用に必要） -->
                            <select id="estimateMonthFilter2" onchange="document.getElementById('estimateMonthFilter').value = this.value; handleEstimateMonthFilterChange()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全期間</option>
                            </select>
                        </div>

                        <div id="estimateVersionFilterSegmented" style="display: none; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">版数:</label>
                            <!-- セグメントボタン版 -->
                            <div id="estimateVersionButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: min(800px, calc(100vw - 110px));">
                            </div>
                            <!-- Select版（セグメントボタン生成用に必要） -->
                            <select id="estimateVersionFilter2" onchange="document.getElementById('estimateVersionFilter').value = this.value; handleEstimateVersionFilterChange()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全版数</option>
                            </select>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <div class="segment-buttons">
                                <button id="btnEstimateGrouped" onclick="setEstimateViewType('grouped')" class="active">グループ</button>
                                <button id="btnEstimateMatrix" onclick="setEstimateViewType('matrix')">マトリクス</button>
                                <button id="btnEstimateList" onclick="setEstimateViewType('list')">リスト</button>
                            </div>
                        </div>
                    </div>
                    <div style="display: flex; justify-content: flex-end; gap: 15px; margin-top: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer; user-select: none; font-size: 13px; font-weight: 500; white-space: nowrap;">
                            <input type="checkbox" id="workMonthSelectionMode2" onchange="toggleWorkMonthSelectionMode()" style="width: auto; margin-right: 5px;">
                            <span>作業月割り当て</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; user-select: none; font-size: 13px; font-weight: 500; white-space: nowrap;">
                            <input type="checkbox" id="estimateEditMode2" onchange="toggleEstimateEditMode()" style="width: auto; margin-right: 5px;">
                            <span>編集モード</span>
                        </label>
                    </div>
                </div>
                
                <!-- 作業月割り当てモード（フロート表示） -->
                <div id="workMonthAssignmentMode" style="display: none; background: linear-gradient(135deg, #fff3cd 0%, #ffe5a0 100%); padding: 18px; border-radius: 8px; position: fixed; top: 20px; left: 50%; transform: translateX(-50%); z-index: 1000; box-shadow: 0 4px 20px rgba(0,0,0,0.2); border-left: 4px solid #ffc107; max-width: 90vw;">
                    <!-- ドラッグハンドル -->
                    <div id="dragHandle" style="position: absolute; top: 0; left: 0; right: 0; height: 8px; background: rgba(0,0,0,0.1); border-radius: 8px 8px 0 0; cursor: ns-resize; display: flex; align-items: center; justify-content: center; z-index: 1;">
                        <div style="width: 40px; height: 4px; background: rgba(0,0,0,0.3); border-radius: 2px;"></div>
                    </div>

                    <!-- 閉じるボタン -->
                    <button onclick="closeWorkMonthAssignmentMode()" style="position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); border: 2px solid #856404; font-size: 20px; font-weight: bold; color: #856404; cursor: pointer; padding: 0; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; z-index: 10; box-shadow: 0 2px 4px rgba(0,0,0,0.2); line-height: 1;" onmouseover="this.style.background='#856404'; this.style.color='white';" onmouseout="this.style.background='rgba(255,255,255,0.9)'; this.style.color='#856404';">&times;</button>

                    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap; margin-top: 8px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="font-weight: 600; color: #856404;">割り当て先:</label>
                            <select id="assignWorkMonth" style="padding: 8px 12px; border: 2px solid #ffc107; border-radius: 6px; font-weight: 500; font-size: 14px; background: white;">
                            </select>
                        </div>
                        <button class="btn btn-success" onclick="executeWorkMonthAssignment()" style="margin: 0; font-weight: 600; padding: 8px 20px;">
                            ✓ 割り当て実行
                        </button>
                        <button class="btn" onclick="cancelWorkMonthSelection()" style="margin: 0; background: #6c757d; color: white; padding: 8px 16px;">
                            選択解除
                        </button>
                        <div id="selectedWorkHours" style="margin-left: auto; font-weight: 700; font-size: 18px; color: #1976d2; white-space: nowrap;">
                            選択中: 0h (0人日 / 0人月)
                        </div>
                    </div>
                </div>
                
                <div id="estimateList"></div>
            </div>

            <div id="actual" class="tab-content">
                <h2>実績データ一覧</h2>

                <!-- バージョン1: 横並びコンパクトレイアウト -->
                <div id="actualFiltersCompact" style="display: flex; flex-wrap: nowrap; gap: 10px; align-items: center; margin-bottom: 20px; background: #f8f9fa; padding: 10px; border-radius: 6px; overflow-x: auto;">
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示モード:</label>
                        <select id="actualViewMode" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全担当者</option>
                            <option value="member">担当者別</option>
                        </select>
                    </div>

                    <div id="memberSelectGroup" style="display: none; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">担当者:</label>
                        <select id="actualMemberSelect" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                        </select>
                    </div>

                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                        <select id="actualViewType" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="matrix">カレンダー</option>
                            <option value="list">リスト</option>
                        </select>
                    </div>

                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示期間:</label>
                        <select id="actualMonthFilter" onchange="renderActualList()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全期間</option>
                        </select>
                    </div>
                </div>

                <!-- バージョン2: セグメントボタンレイアウト（切り替え用） -->
                <div id="actualFiltersSegmented" style="display: none; margin-bottom: 20px; background: #f8f9fa; padding: 12px; border-radius: 6px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示モード:</label>
                            <select id="actualViewMode2" onchange="document.getElementById('actualViewMode').value = this.value; renderActualList()" style="padding: 4px 8px; font-size: 13px;">
                                <option value="all">全担当者</option>
                                <option value="member">担当者別</option>
                            </select>
                        </div>

                        <div id="memberSelectGroup2" style="display: none; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">担当者:</label>
                            <!-- セグメントボタン版 -->
                            <div id="actualMemberButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: min(600px, calc(100vw - 120px));">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="actualMemberSelect2" onchange="document.getElementById('actualMemberSelect').value = this.value; renderActualList()" style="padding: 4px 8px; font-size: 13px; display: none;">
                            </select>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <div class="segment-buttons">
                                <button onclick="setActualViewType('matrix')" id="btnActualMatrix" class="active">カレンダー</button>
                                <button onclick="setActualViewType('list')" id="btnActualList">リスト</button>
                            </div>
                        </div>

                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示期間:</label>
                            <!-- セグメントボタン版 -->
                            <div id="actualMonthButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: min(800px, calc(100vw - 140px));">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="actualMonthFilter2" onchange="document.getElementById('actualMonthFilter').value = this.value; renderActualList()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全期間</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="actualList"></div>
            </div>

            <div id="report" class="tab-content">
                <h2>工数レポート</h2>

                <!-- バージョン1: 横並びコンパクトレイアウト -->
                <div id="reportFiltersCompact" class="sticky-filter-container" style="display: flex; flex-wrap: nowrap; gap: 10px; align-items: center; margin-bottom: 20px; background: #f8f9fa; padding: 10px; border-radius: 6px; overflow-x: auto;">
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">フィルタ:</label>
                        <select id="reportFilterType" onchange="handleReportFilterTypeChange()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="month">月別</option>
                            <option value="version">版数別</option>
                        </select>
                    </div>
                    <div id="reportMonthFilterCompact" style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示月:</label>
                        <select id="reportMonth" onchange="handleReportMonthFilterChange()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全期間</option>
                        </select>
                    </div>
                    <div id="reportVersionFilterCompact" style="display: none; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">版数:</label>
                        <select id="reportVersion" onchange="handleReportVersionFilterChange()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="all">全版数</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px; flex-shrink: 0;">
                        <label style="font-size: 12px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                        <select id="reportViewType" onchange="updateReport()" style="padding: 3px 6px; font-size: 12px;">
                            <option value="summary">サマリー</option>
                            <option value="grouped" selected>グループ</option>
                            <option value="matrix">マトリクス</option>
                        </select>
                    </div>
                </div>

                <!-- バージョン2: セグメントボタンレイアウト（切り替え用） -->
                <div id="reportFiltersSegmented" class="sticky-filter-container" style="display: none; margin-bottom: 20px; background: #f8f9fa; padding: 12px; border-radius: 6px;">
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">フィルタ:</label>
                            <div style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow: hidden; background: white;">
                                <button onclick="setReportFilterType('month')" id="btnFilterMonth" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; transition: all 0.2s;">月別</button>
                                <button onclick="setReportFilterType('version')" id="btnFilterVersion" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; border-left: 1px solid #dee2e6; transition: all 0.2s;">版数別</button>
                            </div>
                        </div>
                        <div id="reportMonthFilterSegmented" style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示月:</label>
                            <!-- セグメントボタン版 -->
                            <div id="reportMonthButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: min(800px, calc(100vw - 130px));">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="reportMonth2" onchange="document.getElementById('reportMonth').value = this.value; handleReportMonthFilterChange()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全期間</option>
                            </select>
                        </div>
                        <div id="reportVersionFilterSegmented" style="display: none; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">版数:</label>
                            <!-- セグメントボタン版 -->
                            <div id="reportVersionButtons2" style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow-x: auto; background: white; max-width: min(800px, calc(100vw - 110px));">
                            </div>
                            <!-- Select版（要素数が多い場合） -->
                            <select id="reportVersion2" onchange="document.getElementById('reportVersion').value = this.value; handleReportVersionFilterChange()" style="padding: 4px 8px; font-size: 13px; display: none;">
                                <option value="all">全版数</option>
                            </select>
                        </div>
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <label style="font-size: 13px; font-weight: 500; white-space: nowrap;">表示形式:</label>
                            <div style="display: inline-flex; border: 1px solid #dee2e6; border-radius: 4px; overflow: hidden; background: white;">
                                <button onclick="setReportViewType('summary')" id="btnReportSummary" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; transition: all 0.2s;">サマリー</button>
                                <button onclick="setReportViewType('grouped')" id="btnReportGrouped" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; border-left: 1px solid #dee2e6; transition: all 0.2s;">グループ</button>
                                <button onclick="setReportViewType('matrix')" id="btnReportMatrix" style="padding: 4px 10px; font-size: 12px; border: none; background: white; color: #333; cursor: pointer; border-left: 1px solid #dee2e6; transition: all 0.2s;">マトリクス</button>
                            </div>
                        </div>
                    </div>
                </div>

                <h3 id="reportPeriodTitle">全期間の集計</h3>

                <div class="stats-grid">
                    <div class="stat-card theme-bg theme-purple">
                        <h3>総見積工数</h3>
                        <div class="value" id="totalEstimate">0h</div>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.8); margin-top: 5px;" id="totalEstimateManpower"></div>
                    </div>
                    <div class="stat-card theme-bg theme-purple">
                        <h3>総実績工数</h3>
                        <div class="value" id="totalActual">0h</div>
                        <div style="font-size: 12px; color: rgba(255,255,255,0.8); margin-top: 5px;" id="totalActualManpower"></div>
                    </div>
                    <div class="stat-card theme-bg theme-purple">
                        <h3>差異</h3>
                        <div class="value" id="totalDiff">0h</div>
                    </div>
                    <div class="stat-card theme-bg theme-purple">
                        <h3>実績率</h3>
                        <div class="value" id="actualRate">0%</div>
                    </div>
                </div>

                <div id="reportDetailView"></div>

                <h3>担当者別工数</h3>
                <div id="memberReport"></div>

                <h3 style="margin-top: 20px;">版数別進捗</h3>
                <div id="versionReport"></div>

                <!-- 進捗管理セクション -->
                <div style="margin-top: 30px; background: #f8f9fa; padding: 20px; border-radius: 8px;">
                    <h3>進捗管理（見込残存時間ベース）</h3>
                    <p style="color: #666; margin-bottom: 15px; font-size: 13px;">
                        見込残存時間を入力すると、より正確な進捗率と予測総工数が表示されます。
                    </p>

                    <!-- フィルタ -->
                    <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; align-items: center;">
                        <select id="progressVersionFilter" onchange="updateProgressReport()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="all">全版数</option>
                        </select>
                        <select id="progressStatusFilter" onchange="updateProgressReport()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;">
                            <option value="all">全ステータス</option>
                            <option value="completed">完了</option>
                            <option value="ontrack">順調</option>
                            <option value="warning">注意</option>
                            <option value="exceeded">超過</option>
                        </select>
                        <button class="btn btn-primary" onclick="openBulkRemainingModal()" style="padding: 8px 16px; font-size: 13px;">
                            一括編集
                        </button>
                    </div>

                    <!-- 進捗サマリーカード -->
                    <div class="stats-grid" id="progressSummaryCards">
                        <!-- 動的に生成 -->
                    </div>

                    <!-- 詳細テーブル -->
                    <div id="progressDetailTable" style="margin-top: 20px;">
                        <!-- 動的に生成 -->
                    </div>
                </div>

                <!-- Excel出力セクション -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 30px 0;">
                    <h3>📊 Excel出力</h3>
                    <p style="color: #666; margin-bottom: 15px;">実績データと見積データをExcel形式で出力します。</p>
                    
                    <div style="margin-bottom: 15px;">
                        <h4 style="margin-bottom: 8px; font-size: 14px;">出力内容:</h4>
                        <ul style="color: #666; font-size: 13px; margin-left: 20px;">
                            <li><strong>実績シート（担当者別）:</strong> 日付、曜日、備考、作業、時間</li>
                            <li><strong>見積シート:</strong> 版数、作業月、対応名、工程、担当、見積工数</li>
                        </ul>
                    </div>
                    
                    <button class="btn btn-success" onclick="exportToExcel()" style="font-weight: 600;">
                        📥 Excelファイルをダウンロード
                    </button>
                </div>
            </div>

            <div id="settings" class="tab-content">
                <h2>⚙️ 設定</h2>
                
                <!-- テーマカラー設定 -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>🎨 テーマカラー</h3>
                    <p style="color: #666; margin-bottom: 15px;">アプリの配色を変更できます。クイック入力エリア、レポート集計、アクティブタブに適用されます。</p>
                    
                    <div class="form-group">
                        <label>色</label>
                        <select id="themeColor" onchange="applyTheme()">
                            <option value="purple">紫（現在）</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="indigo">インディゴ</option>
                            <option value="navy">ネイビー</option>
                            <option value="slate">スレート</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>デザイン</label>
                        <select id="themePattern" onchange="applyTheme()">
                            <option value="none">シンプル（模様なし）</option>
                            <option value="wave">波模様</option>
                            <option value="stripe">右ストライプ</option>
                            <option value="glow">グロー効果</option>
                            <option value="corner">コーナーアクセント</option>
                            <option value="dot">ドット</option>
                            <option value="dots">複数ドット</option>
                            <option value="diagonal">斜線パターン</option>
                            <option value="circle">サークル</option>
                            <option value="layer">レイヤー</option>
                            <option value="line">グラデーションライン</option>
                            <option value="bar">左バー</option>
                            <option value="border">上部ボーダー</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>タブの色</label>
                        <select id="themeTabColor" onchange="applyTheme()">
                            <option value="same">メインカラーと同じ</option>
                            <option value="default">デフォルト（青）</option>
                            <option value="purple">紫</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="indigo">インディゴ</option>
                            <option value="navy">ネイビー</option>
                            <option value="slate">スレート</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            タブの色を個別に設定できます
                        </small>
                    </div>
                    
                    <div class="form-group">
                        <label>背景色</label>
                        <select id="themeBackgroundColor" onchange="applyTheme()">
                            <option value="same">メインカラーと同じ</option>
                            <option value="purple">紫</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="indigo">インディゴ</option>
                            <option value="navy">ネイビー</option>
                            <option value="slate">スレート</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ページ全体の背景色を個別に設定できます
                        </small>
                    </div>
                    
                    <!-- プレビュー -->
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600;">プレビュー</label>
                        <div id="themePreview" style="padding: 20px; border-radius: 8px; color: white; position: relative; overflow: hidden;">
                            <div style="font-size: 16px; font-weight: 600; margin-bottom: 10px;">クイック実績入力</div>
                            <div style="font-size: 14px;">レポート集計カード・アクティブタブにも適用されます</div>
                        </div>
                    </div>
                    
                    <small style="color: #666; display: block; margin-top: 10px;">
                        ・設定は自動的に保存されます<br>
                        ・ページをリロードしても設定は保持されます
                    </small>
                </div>

                <!-- マトリクス表示の月色分け設定 -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>📊 マトリクス表示</h3>
                    <p style="color: #666; margin-bottom: 15px;">見積一覧・レポートのマトリクス表示に関する設定です。</p>

                    <div class="form-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="showMonthColorsCheckbox" onchange="toggleMonthColorsSetting()" style="width: auto; margin-right: 10px;" checked>
                            <span>見積一覧で月ごとに色分けする</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オン: 見積一覧（全期間表示・月別表示）で工程の割当月に応じてセルを色分けします<br>
                            ・オフ: 色分けを無効にします
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="showDeviationColorsCheckbox" onchange="toggleDeviationColorsSetting()" style="width: auto; margin-right: 10px; flex-shrink: 0;" checked>
                            <span>レポートで乖離率に応じた背景色を表示する</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オン: レポートのマトリクス表示で見積と実績の乖離率に応じて背景色をグラデーション表示します<br>
                            ・オフ: 背景色を無効にします（白背景）
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="showProgressBarsCheckbox" onchange="toggleProgressBarsSetting()" style="width: auto; margin-right: 10px; flex-shrink: 0;" checked>
                            <span>レポートで進捗バーを表示する</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オン: レポートのマトリクス表示で見込残存時間ベースの進捗バーを表示します<br>
                            ・オフ: 進捗バーを非表示にします
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">進捗バーのスタイル</label>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="progressBarStyle" value="inline" onchange="saveProgressBarStyle()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;" checked>
                                <span style="flex: 1;">
                                    <strong>セル内に表示</strong><br>
                                    <small style="color: #666;">進捗バーをセルのコンテンツとして表示（パーセンテージ表示可能）</small>
                                </span>
                            </label>
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="progressBarStyle" value="bottom" onchange="saveProgressBarStyle()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;">
                                <span style="flex: 1;">
                                    <strong>セル下部に表示</strong><br>
                                    <small style="color: #666;">進捗バーをセルの下部枠線として表示（パーセンテージは非表示）</small>
                                </span>
                            </label>
                        </div>
                        <small style="color: #666; display: block; margin-top: 10px;">
                            進捗バーの表示位置を選択できます
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="showProgressPercentageCheckbox" onchange="toggleProgressPercentageSetting()" style="width: auto; margin-right: 10px; flex-shrink: 0;" checked>
                            <span>進捗バーにパーセンテージを表示する</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オン: 進捗バーの下にパーセンテージ（例: 75%）を表示します<br>
                            ・オフ: パーセンテージを非表示にします（ツールチップで確認可能）<br>
                            ・注意: 「セル下部に表示」スタイルではパーセンテージは表示されません
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">見積と実績の表示形式（レポートのマトリクス）</label>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="matrixEstActFormat" value="twoRows" onchange="saveMatrixEstActFormat()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;" checked>
                                <span style="flex: 1;">
                                    <strong>2行表示</strong><br>
                                    <small style="color: #666;">見積と実績を2行で表示（見積は細字、実績は太字）</small>
                                </span>
                            </label>
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="matrixEstActFormat" value="slash" onchange="saveMatrixEstActFormat()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;">
                                <span style="flex: 1;">
                                    <strong>スラッシュ横並び</strong><br>
                                    <small style="color: #666;">例: 10.0 / 15.5</small>
                                </span>
                            </label>
                        </div>
                        <small style="color: #666; display: block; margin-top: 10px;">
                            レポートタブのマトリクス表示で、見積と実績をどのように表示するか選択できます
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">人日/人月の表示形式（レポートの合計列）</label>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="matrixDayMonthFormat" value="inline" onchange="saveMatrixDayMonthFormat()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;" checked>
                                <span style="flex: 1;">
                                    <strong>横に括弧で表示</strong><br>
                                    <small style="color: #666;">例: 10.0 (2.0人日/0.10人月)</small>
                                </span>
                            </label>
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="matrixDayMonthFormat" value="separate" onchange="saveMatrixDayMonthFormat()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;">
                                <span style="flex: 1;">
                                    <strong>別行で表示</strong><br>
                                    <small style="color: #666;">見積: 10.0 / 実績: 15.5<br>見積: 2.0人日/0.10人月 / 実績: 3.1人日/0.16人月</small>
                                </span>
                            </label>
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="matrixDayMonthFormat" value="side" onchange="saveMatrixDayMonthFormat()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;">
                                <span style="flex: 1;">
                                    <strong>右側に表示</strong><br>
                                    <small style="color: #666;">見積 10.0　　　　2.0人日/0.10人月</small>
                                </span>
                            </label>
                            <label style="display: flex; align-items: flex-start; cursor: pointer;">
                                <input type="radio" name="matrixDayMonthFormat" value="arrow" onchange="saveMatrixDayMonthFormat()" style="margin-top: 3px; margin-right: 8px; flex-shrink: 0;">
                                <span style="flex: 1;">
                                    <strong>矢印で表示</strong><br>
                                    <small style="color: #666;">見積 10.0 → 2.0人日/0.10人月</small>
                                </span>
                            </label>
                        </div>
                        <small style="color: #666; display: block; margin-top: 10px;">
                            レポートタブのマトリクス表示で、合計列に表示される人日/人月の表示形式を選択できます
                        </small>
                    </div>
                </div>

                <!-- デフォルト表示形式設定 -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>📋 デフォルト表示形式</h3>
                    <p style="color: #666; margin-bottom: 15px;">見積一覧とレポートを開いたときに表示される初期表示形式を設定できます。</p>

                    <div class="form-group">
                        <label>見積一覧のデフォルト表示</label>
                        <select id="defaultEstimateViewType" onchange="saveDefaultViewTypeSetting()">
                            <option value="grouped">グループ</option>
                            <option value="matrix">マトリクス</option>
                            <option value="list">リスト</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            見積一覧タブを開いたとき、または画面を読み込んだときの初期表示形式です。
                        </small>
                    </div>

                    <div class="form-group">
                        <label>レポートのデフォルト表示</label>
                        <select id="defaultReportViewType" onchange="saveDefaultViewTypeSetting()">
                            <option value="summary">サマリー</option>
                            <option value="grouped">グループ</option>
                            <option value="matrix">マトリクス</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            レポートタブを開いたとき、または画面を読み込んだときの初期表示形式です。
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>自動バックアップ</h3>
                    <p style="color: #666; margin-bottom: 15px;">データ保存時に自動的にJSONファイルをダウンロードします。</p>
                    
                    <div class="form-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="autoBackupEnabled" onchange="saveAutoBackupSetting()" style="width: auto; margin-right: 10px;">
                            <span>自動バックアップを有効にする</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オンにすると、実績や見積の登録・編集時に自動でバックアップファイルがダウンロードされます<br>
                            ・オフにしても、手動バックアップボタンは使用できます
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>クイック入力モード</h3>
                    <p style="color: #666; margin-bottom: 15px;">クイック入力タブの実績入力/見積登録モードの動作を設定できます。</p>

                    <div class="form-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="rememberQuickInputMode" onchange="saveQuickInputModeSetting()" style="width: auto; margin-right: 10px;">
                            <span>前回のモード（実績/見積）を記憶する</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・オフ（デフォルト）: 常に実績入力モードで開始します<br>
                            ・オン: 前回使用したモード（実績入力 or 見積登録）を記憶し、次回も同じモードで開始します
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>担当者表示順</h3>
                    <p style="color: #666; margin-bottom: 15px;">担当者の表示順序を指定できます。この順序は実績一覧、レポート、入力フォームなど全ての画面に適用されます。</p>

                    <div class="form-group">
                        <label>表示順序 <button onclick="showMemberOrderHelp()" style="border: none; background: none; cursor: pointer; color: #3498db; font-size: 18px;">ℹ️</button></label>
                        <input type="text" id="memberOrder" placeholder="例: A,B,C,D または 山田,佐藤,田中" onchange="updateAllDisplays()">
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・カンマ区切りで入力してください<br>
                            ・指定した順番で表示されます<br>
                            ・指定していない担当者は後ろにアルファベット順で表示されます<br>
                            ・設定は自動的に保存されます
                        </small>
                    </div>

                    <button class="btn btn-primary" onclick="updateAllDisplays()" style="margin-top: 10px;">設定を適用</button>
                </div>

                <!-- UI/UX設定 -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>🖥️ UI/UX設定</h3>
                    <p style="color: #666; margin-bottom: 15px;">画面表示や操作性に関する設定です。</p>

                    <div class="form-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="stickyFilterEnabled" onchange="saveStickyFilterSetting()" style="width: auto; margin-right: 10px;" checked>
                            <span>フィルタ固定表示（Sticky）を有効にする</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px; margin-left: 30px;">
                            見積一覧・レポートのフィルタ設定部分をスクロール時に画面上部に固定表示します。
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 15px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="floatingFilterEnabled" onchange="saveFloatingFilterSetting()" style="width: auto; margin-right: 10px;" checked>
                            <span>フローティングフィルタパネルを有効にする</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px; margin-left: 30px;">
                            レポートタブで画面右下にフィルタ設定ボタンを表示します。スクロール位置に関係なくフィルタを変更できます。
                        </small>
                    </div>

                    <div class="form-group" style="margin-top: 15px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="debugModeEnabled" onchange="saveDebugModeSetting()" style="width: auto; margin-right: 10px;">
                            <span>デバッグモードを有効にする</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px; margin-left: 30px;">
                            エラー発生時に詳細なエラーメッセージを表示します。通常はオフで問題ありません。
                        </small>
                    </div>
                </div>

                <!-- グラフカラーパターン設定 -->
                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>🎨 グラフカラーパターン</h3>
                    <p style="color: #666; margin-bottom: 15px;">レポートの担当者分析グラフ（見積・実績の棒グラフと工数内訳ドーナツグラフ）の配色を変更できます。</p>

                    <div class="form-group">
                        <label>カラーパターン</label>
                        <select id="chartColorScheme" onchange="saveChartColorScheme()">
                            <option value="auto">テーマカラーに合わせる（自動）</option>
                            <option value="classic">クラシック</option>
                            <option value="purple">紫</option>
                            <option value="indigo">インディゴ</option>
                            <option value="deep-blue">ディープブルー</option>
                            <option value="ocean">オーシャン</option>
                            <option value="sky">スカイブルー</option>
                            <option value="navy">ネイビー</option>
                            <option value="teal">ティール</option>
                            <option value="cyan">シアン</option>
                            <option value="green">グリーン</option>
                            <option value="emerald">エメラルド</option>
                            <option value="slate">スレート</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            ・「テーマカラーに合わせる（自動）」を選択すると、テーマカラー変更時にグラフの色も自動で変わります<br>
                            ・特定の色を固定したい場合は、個別のカラーパターンを選択してください<br>
                            ・設定は自動的に保存され、レポートの担当者分析グラフに適用されます
                        </small>
                    </div>

                    <!-- プレビュー -->
                    <div style="margin: 20px 0;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600;">プレビュー</label>

                        <!-- 棒グラフプレビュー -->
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #495057;">見積 vs 実績の棒グラフ</div>
                            <div style="display: flex; gap: 15px; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div id="chartPreviewEstimateBar" style="width: 40px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">見積</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div id="chartPreviewActualBar" style="width: 40px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">実績</span>
                                </div>
                            </div>
                        </div>

                        <!-- ドーナツグラフプレビュー -->
                        <div style="background: white; padding: 15px; border-radius: 8px;">
                            <div style="font-size: 13px; font-weight: 600; margin-bottom: 10px; color: #495057;">工数内訳ドーナツグラフ</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 12px;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div id="chartPreviewUI" style="width: 20px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">UI</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div id="chartPreviewPG" style="width: 20px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">PG</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div id="chartPreviewPT" style="width: 20px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">PT</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div id="chartPreviewIT" style="width: 20px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">IT</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div id="chartPreviewST" style="width: 20px; height: 20px; border-radius: 3px;"></div>
                                    <span style="font-size: 12px; color: #495057;">ST</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>📐 表示形式レイアウト</h3>
                    <p style="color: #666; margin-bottom: 15px;">見積一覧、実績一覧、レポートの表示形式選択UIのレイアウトを変更できます。</p>

                    <div class="form-group">
                        <label>見積一覧のレイアウト</label>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="toggleFilterLayout('estimate', 'compact')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">横並び</button>
                            <button onclick="toggleFilterLayout('estimate', 'segmented')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">セグメント</button>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            横並び: コンパクトな横並びレイアウト<br>
                            セグメント: セグメントボタンを使った見やすいレイアウト
                        </small>
                    </div>

                    <div class="form-group">
                        <label>実績一覧のレイアウト</label>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="toggleFilterLayout('actual', 'compact')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">横並び</button>
                            <button onclick="toggleFilterLayout('actual', 'segmented')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">セグメント</button>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            横並び: コンパクトな横並びレイアウト<br>
                            セグメント: セグメントボタンを使った見やすいレイアウト
                        </small>
                    </div>

                    <div class="form-group">
                        <label>レポートのレイアウト</label>
                        <div style="display: flex; gap: 6px; align-items: center;">
                            <button onclick="toggleFilterLayout('report', 'compact')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">横並び</button>
                            <button onclick="toggleFilterLayout('report', 'segmented')" class="layout-toggle-btn" style="padding: 6px 14px; font-size: 13px; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">セグメント</button>
                        </div>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            横並び: コンパクトな横並びレイアウト<br>
                            セグメント: セグメントボタンを使った見やすいレイアウト
                        </small>
                    </div>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>📊 レポート分析機能</h3>
                    <p style="color: #666; margin-bottom: 15px;">レポートに表示する分析機能を選択できます。</p>

                    <div class="form-group">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">Phase 1: 即効性の高い改善</label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportAccuracyEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>見積精度の%表示（工程別、版数別）</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportAnomalyEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>異常値のハイライト表示（50%超過を強調）</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportWarningTasksEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>要注意タスクのリスト表示</span>
                        </label>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">Phase 2: 視覚化の強化</label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportChartEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>棒グラフ表示（版数別、工程別）</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportTrendEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>月別推移の表示</span>
                        </label>
                    </div>

                    <div class="form-group" style="margin-top: 20px;">
                        <label style="font-weight: 600; margin-bottom: 10px; display: block;">Phase 3: 高度な分析</label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportMemberAnalysisEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>担当者別の詳細分析</span>
                        </label>

                        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
                            <input type="checkbox" id="reportInsightsEnabled" onchange="saveReportSettings(); updateReport();" style="width: auto; margin-right: 10px;" checked>
                            <span>インサイト・推奨アクションの表示</span>
                        </label>
                    </div>

                    <small style="color: #666; display: block; margin-top: 10px;">
                        ・設定は自動的に保存されます<br>
                        ・不要な機能をオフにすることで、シンプルなレポート表示にできます
                    </small>
                </div>

                <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3>🏢 会社休日設定</h3>
                    <p style="color: #666; margin-bottom: 15px;">会社の夏季休暇、年末年始休暇などを登録できます。実働日数の計算に反映されます。</p>

                    <div class="form-group">
                        <label>休日名</label>
                        <input type="text" id="companyHolidayName" placeholder="例: 夏季休暇">
                    </div>

                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <div class="form-group" style="flex: 1; margin: 0;">
                            <label>開始日</label>
                            <input type="date" id="companyHolidayStartDate">
                        </div>
                        <div class="form-group" style="flex: 1; margin: 0;">
                            <label>終了日</label>
                            <input type="date" id="companyHolidayEndDate">
                        </div>
                    </div>

                    <button class="btn btn-primary" onclick="addCompanyHoliday()" style="margin-bottom: 20px;">休日を追加</button>

                    <div id="companyHolidayList"></div>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json,.xlsx,.xls" style="display: none;" onchange="handleFileImport(event)">

    <!-- 作業詳細モーダル -->
    <div id="workModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="modalTitle">作業詳細</h3>
                <button class="modal-close" onclick="closeWorkModal()">&times;</button>
            </div>
            <div class="modal-body" id="modalBody">
            </div>
        </div>
    </div>

    <!-- 実績編集モーダル -->
    <div id="editActualModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>実績データを編集</h3>
                <button class="modal-close" onclick="closeEditActualModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editActualId">
                <div class="form-group">
                    <label>日付</label>
                    <input type="date" id="editActualDate" style="max-width: 200px;">
                </div>
                <div class="form-group">
                    <label>版数</label>
                    <select id="editActualVersion" onchange="handleVersionChange('editActualVersion')">
                        <option value="">-- 版数を選択 --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>対応名</label>
                    <select id="editActualTaskSelect" onchange="handleActualTaskSelect()" style="margin-bottom: 10px;">
                        <option value="">-- 対応を選択 --</option>
                    </select>
                    <input type="text" id="editActualTaskSearch" placeholder="対応名を入力" style="display: none;">
                    <small style="color: #666; display: block; margin-top: 5px;">
                        ↑ 未完了の対応を選択、または「新規入力」で新しい対応を追加
                    </small>
                </div>
                <div class="form-group">
                    <label>工程</label>
                    <select id="editActualProcess">
                        <option value="UI">UI</option>
                        <option value="PG">PG</option>
                        <option value="PT">PT</option>
                        <option value="IT">IT</option>
                        <option value="ST">ST</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>担当</label>
                    <select id="editActualMember" onchange="handleEditActualMemberChange()">
                    </select>
                    <span id="editActualMemberDisplay" style="display: none; padding: 10px; background: #f5f5f5; border-radius: 6px; font-weight: 600;"></span>
                </div>
                <div class="form-group">
                    <label>実績工数</label>
                    <input type="number" id="editActualHours" step="0.5" min="0" placeholder="8">
                </div>
                <div class="form-group" id="remainingHoursGroup">
                    <label>見込残存時間</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" id="editActualRemainingHours" step="0.5" min="0" placeholder="0" style="flex: 1; max-width: 120px;">
                        <span style="color: #666; font-size: 13px;">時間</span>
                    </div>
                    <small style="color: #666; display: block; margin-top: 5px;">この対応にあと何時間で完了予定か入力（0=完了）</small>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="saveActualEdit()">保存</button>
                    <button class="btn" id="editActualOtherBtn" onclick="openOtherWorkFromCalendar()" style="background: #9b59b6; color: white; display: none;">その他作業</button>
                    <button class="btn" id="editActualVacationBtn" onclick="openVacationFromCalendar()" style="background: #27ae60; color: white; display: none;">休暇登録</button>
                    <button class="btn" onclick="closeEditActualModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 見込残存時間一括編集モーダル -->
    <div id="bulkRemainingModal" class="modal">
        <div class="modal-content" style="max-width: 1000px; max-height: 85vh;">
            <div class="modal-header">
                <h3>見込残存時間の一括編集</h3>
                <button class="modal-close" onclick="closeBulkRemainingModal()">&times;</button>
            </div>
            <div class="modal-body" style="overflow-y: auto; max-height: calc(85vh - 120px);">
                <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                    <label>版数フィルタ:</label>
                    <select id="bulkRemainingVersionFilter" onchange="renderBulkRemainingTable()" style="padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;">
                        <option value="all">全版数</option>
                    </select>
                </div>
                <div class="table-wrapper" style="overflow-x: auto;">
                    <table id="bulkRemainingTable" style="width: 100%; border-collapse: collapse; min-width: 800px;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">版数</th>
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">対応名</th>
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">工程</th>
                                <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">担当</th>
                                <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">見積</th>
                                <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">実績</th>
                                <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">残存</th>
                                <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">予測総工数</th>
                                <th style="padding: 10px; text-align: center; border-bottom: 2px solid #ddd;">状態</th>
                            </tr>
                        </thead>
                        <tbody id="bulkRemainingTableBody">
                            <!-- 動的に生成 -->
                        </tbody>
                    </table>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px; justify-content: flex-end;">
                    <button class="btn btn-primary" onclick="saveBulkRemaining()">保存</button>
                    <button class="btn" onclick="closeBulkRemainingModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 休暇登録モーダル -->
    <div id="vacationModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #f57c00 0%, #ff9800 100%);">
                <h3 style="color: white;">休暇を登録</h3>
                <button class="modal-close" onclick="closeVacationModal()" style="color: white;">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="vacationModalMember">
                <input type="hidden" id="vacationModalDate">
                <div class="form-group">
                    <label>担当者</label>
                    <div id="vacationModalMemberDisplay" style="padding: 10px; background: #f5f5f5; border-radius: 6px; font-weight: 600;"></div>
                </div>
                <div class="form-group">
                    <label>日付</label>
                    <div id="vacationModalDateDisplay" style="padding: 10px; background: #f5f5f5; border-radius: 6px; font-weight: 600;"></div>
                </div>
                <div class="form-group">
                    <label>休暇タイプ</label>
                    <select id="vacationModalType" onchange="handleVacationModalTypeChange()">
                        <option value="有休">有給休暇（有休）</option>
                        <option value="特休">特別休暇（特休）</option>
                        <option value="代休">代休（代休）</option>
                        <option value="振休">振替休日（振休）</option>
                        <option value="時間休">時間休</option>
                    </select>
                </div>
                <div class="form-group" id="vacationModalHoursGroup">
                    <label>時間数 (h)</label>
                    <input type="number" id="vacationModalHours" step="1" min="1" max="8" value="8">
                    <small style="color: #666; display: block; margin-top: 5px;">時間休は1h単位で入力。全日休暇は8h。</small>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveVacationFromModal()" style="background: #f57c00;">登録</button>
                    <button class="btn" onclick="closeVacationModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 見積編集モーダル -->
    <div id="editEstimateModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>見積データを編集</h3>
                <button class="modal-close" onclick="closeEditEstimateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editEstimateId">
                <div class="form-group">
                    <label>版数</label>
                    <select id="editEstimateVersion" onchange="handleVersionChange('editEstimateVersion')">
                        <option value="">-- 版数を選択 --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>対応名</label>
                    <input type="text" id="editEstimateTaskSearch" placeholder="検索または新規入力" list="editEstimateTaskList" oninput="handleEstimateTaskInput()">
                    <datalist id="editEstimateTaskList">
                    </datalist>
                </div>
                <div class="form-group">
                    <label>工程</label>
                    <select id="editEstimateProcess">
                        <option value="UI">UI</option>
                        <option value="PG">PG</option>
                        <option value="PT">PT</option>
                        <option value="IT">IT</option>
                        <option value="ST">ST</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>担当</label>
                    <select id="editEstimateMember">
                    </select>
                </div>
                <div class="form-group">
                    <label>見積工数</label>
                    <input type="number" id="editEstimateHours" step="0.5" min="0" placeholder="8" oninput="syncEditTotalHours()">
                    <small style="color: #666; display: block; margin-top: 5px;">
                        複数月に分割している場合、総工数が表示されます
                    </small>
                </div>
                <div class="form-group">
                    <label>作業月設定</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="editWorkMonthMode" value="single" checked onchange="toggleEditWorkMonthMode()" style="width: auto; margin-right: 5px;">
                            <span>単一月</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="editWorkMonthMode" value="multi" onchange="toggleEditWorkMonthMode()" style="width: auto; margin-right: 5px;">
                            <span>複数月分割</span>
                        </label>
                    </div>

                    <!-- 単一月モード -->
                    <div id="editSingleMonthSection">
                        <select id="editEstimateWorkMonth">
                            <option value="">-- 作業月を選択 --</option>
                        </select>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            この工程が実際に作業される月を指定します
                        </small>
                    </div>

                    <!-- 複数月分割モード -->
                    <div id="editMultiMonthSection" style="display: none;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; border: 1px solid #dee2e6;">
                            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                                <label style="flex: 1;">作業期間:</label>
                                <select id="editStartMonth" onchange="updateEditMonthPreview()"></select>
                                <span>〜</span>
                                <select id="editEndMonth" onchange="updateEditMonthPreview()"></select>
                            </div>

                            <div style="display: flex; gap: 20px; margin-bottom: 10px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="editSplitMethod" value="equal" checked onchange="updateEditMonthPreview()" style="width: auto; margin-right: 5px;">
                                    <span>均等分割</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="editSplitMethod" value="manual" onchange="updateEditMonthPreview()" style="width: auto; margin-right: 5px;">
                                    <span>手動設定</span>
                                </label>
                            </div>

                            <div id="editMonthPreview"></div>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveEstimateEdit()">保存</button>
                    <button class="btn" onclick="closeEditEstimateModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 対応編集モーダル -->
    <div id="editTaskModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>対応名を編集</h3>
                <button class="modal-close" onclick="closeEditTaskModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editTaskOldVersion">
                <input type="hidden" id="editTaskOldName">
                <div class="form-group">
                    <label>版数</label>
                    <select id="editTaskVersion" onchange="handleVersionChange('editTaskVersion')">
                        <option value="">-- 版数を選択 --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>帳票名</label>
                    <select id="editTaskFormNameSelect" onchange="handleEditFormNameChange()">
                        <option value="">-- 帳票名を選択 --</option>
                        <option value="__new__">新規入力</option>
                    </select>
                    <input type="text" id="editTaskFormName" placeholder="帳票A" style="display: none;">
                </div>
                <div class="form-group">
                    <label>対応名</label>
                    <input type="text" id="editTaskName" placeholder="X対応">
                </div>
                <div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-radius: 6px;">
                    <div style="font-weight: 600; margin-bottom: 5px; color: #856404;">📝 変更内容</div>
                    <div style="font-size: 13px; color: #856404;">この対応のすべての工程（UI、PG、PT、IT、ST）の版数と対応名が変更されます。関連する実績データも自動的に更新されます。</div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveTaskEdit()">保存</button>
                    <button class="btn" onclick="closeEditTaskModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 工程内訳表示モーダル -->
    <div id="processBreakdownModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="breakdownModalTitle">工程内訳</h3>
                <button class="modal-close" onclick="closeProcessBreakdownModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="breakdownModalContent"></div>
            </div>
        </div>
    </div>

    <!-- 見込残存時間入力モーダル -->
    <div id="remainingHoursModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h3>工程の詳細</h3>
                <button class="modal-close" onclick="closeRemainingHoursModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div id="remainingHoursInfo" style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 20px; font-size: 14px;">
                    <!-- 版数、対応名、工程情報を表示 -->
                </div>

                <div id="remainingHoursMemberSelect" style="display: none; margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">担当者</label>
                    <select id="remainingHoursMember" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    </select>
                </div>

                <div class="form-group">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">⏱️ 見込残存時間 (h)</label>
                    <input type="number" id="remainingHoursInput" step="0.1" min="0" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                    <small style="color: #666; display: block; margin-top: 5px;">
                        0を入力すると完了（100%）として扱われます
                    </small>
                </div>

                <!-- 登録実績リスト -->
                <div id="remainingHoursActualsList" style="margin-top: 24px; display: none;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; font-size: 14px; color: #333;">📄 実績一覧（表示期間内）</label>
                    <div id="remainingHoursActualsContent" style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; padding: 12px; max-height: 200px; overflow-y: auto;">
                        <!-- 実績リストをここに表示 -->
                    </div>
                </div>

                <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeRemainingHoursModal()" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">キャンセル</button>
                    <button onclick="saveRemainingHoursFromModal()" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer;">保存</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 見積登録モーダル -->
    <div id="addEstimateModal" class="modal">
        <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h3>📝 見積登録</h3>
                <button class="modal-close" onclick="closeAddEstimateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>版数</label>
                    <select id="addEstVersion" onchange="handleVersionChange('addEstVersion')">
                        <option value="">-- 版数を選択 --</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>帳票名</label>
                    <select id="addEstFormNameSelect" onchange="handleAddFormNameChange()">
                        <option value="">-- 帳票名を選択 --</option>
                        <option value="__new__">新規入力</option>
                    </select>
                    <input type="text" id="addEstFormName" placeholder="帳票A" style="display: none;">
                    <small style="color: #666; display: block; margin-top: 5px;">既存の帳票名を選択、または新規入力できます</small>
                </div>
                <div class="form-group">
                    <label>対応名</label>
                    <input type="text" id="addEstTask" placeholder="X対応">
                </div>
                <div class="form-group">
                    <label>作業月</label>
                    <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="addEstMonthType" value="single" checked onchange="switchAddEstMonthType()" style="width: auto; margin-right: 4px;">
                            <span style="font-size: 14px;">単一月</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="addEstMonthType" value="multi" onchange="switchAddEstMonthType()" style="width: auto; margin-right: 4px;">
                            <span style="font-size: 14px;">複数月</span>
                        </label>
                    </div>
                    <div id="addEstMonthInputs">
                        <div id="addEstSingleMonthInput" style="display: block;">
                            <select id="addEstStartMonth"></select>
                        </div>
                        <div id="addEstMultiMonthInput" style="display: none;">
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="addEstStartMonthMulti"></select>
                                <span>〜</span>
                                <select id="addEstEndMonth"></select>
                            </div>
                        </div>
                    </div>
                </div>
                <h4 style="margin-bottom: 10px; margin-top: 20px;">各工程の見積</h4>
                <div class="estimate-table-wrapper">
                    <table class="estimate-table" id="addEstimateTable" style="width: 100%; margin: 0;">
                        <thead>
                            <tr>
                                <th style="width: 60px; padding: 8px; text-align: center;">工程</th>
                                <th style="width: 120px; padding: 8px;">担当</th>
                                <th style="width: 100px; padding: 8px;">時間</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="text-align: center; font-weight: 600;"><span class="badge badge-ui">UI</span></td>
                                <td><select id="addEstUI_member" style="margin: 0;"></select></td>
                                <td><input type="number" id="addEstUI" placeholder="h" step="0.5" style="margin: 0;" oninput="updateAddEstimateTotals()"></td>
                            </tr>
                            <tr>
                                <td style="text-align: center; font-weight: 600;"><span class="badge badge-pg">PG</span></td>
                                <td><select id="addEstPG_member" style="margin: 0;" onchange="autoFillMember('addEstPG_member')"></select></td>
                                <td><input type="number" id="addEstPG" placeholder="h" step="0.5" style="margin: 0;" oninput="updateAddEstimateTotals()"></td>
                            </tr>
                            <tr>
                                <td style="text-align: center; font-weight: 600;"><span class="badge badge-pt">PT</span></td>
                                <td><select id="addEstPT_member" style="margin: 0;" onchange="autoFillMember('addEstPT_member')"></select></td>
                                <td><input type="number" id="addEstPT" placeholder="h" step="0.5" style="margin: 0;" oninput="updateAddEstimateTotals()"></td>
                            </tr>
                            <tr>
                                <td style="text-align: center; font-weight: 600;"><span class="badge badge-it">IT</span></td>
                                <td><select id="addEstIT_member" style="margin: 0;" onchange="autoFillMember('addEstIT_member')"></select></td>
                                <td><input type="number" id="addEstIT" placeholder="h" step="0.5" style="margin: 0;" oninput="updateAddEstimateTotals()"></td>
                            </tr>
                            <tr>
                                <td style="text-align: center; font-weight: 600;"><span class="badge badge-st">ST</span></td>
                                <td><select id="addEstST_member" style="margin: 0;" onchange="autoFillMember('addEstST_member')"></select></td>
                                <td><input type="number" id="addEstST" placeholder="h" step="0.5" style="margin: 0;" oninput="updateAddEstimateTotals()"></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- 合計表示エリア -->
                <div id="addEstimateTotals" style="background: #e3f2fd; padding: 12px 15px; border-radius: 8px; margin-top: 15px; border-left: 4px solid #1976d2;">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                        <span style="font-weight: 600; color: #1565c0;">対応合計:</span>
                        <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                            <span style="color: #1565c0;"><strong id="addEstTotalHours">0.0</strong> h</span>
                            <span style="color: #1976d2;">(<span id="addEstTotalDays">0.0</span> 人日)</span>
                            <span style="color: #1976d2;">(<span id="addEstTotalMonths">0.00</span> 人月)</span>
                        </div>
                    </div>
                </div>

                <!-- 月分割アシスタント -->
                <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin: 20px 0; border-left: 4px solid #fb8c00;">
                    <div class="form-group" style="margin-bottom: 10px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="addEnableMonthSplit" onchange="toggleAddMonthSplit()" style="width: auto; margin-right: 10px;">
                            <span style="font-weight: 600; color: #e65100;">📅 複数月に分割して登録</span>
                        </label>
                        <small style="color: #666; display: block; margin-top: 5px;">
                            一つの工程を複数月で作業する場合に、月別の工数を設定できます
                        </small>
                    </div>

                    <div id="addMonthSplitPanel" style="display: none; margin-top: 15px;">
                        <div class="form-group">
                            <label>分割する工程を選択</label>
                            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="addSplitUI" class="add-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                    <span>UI</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="addSplitPG" class="add-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                    <span>PG</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="addSplitPT" class="add-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                    <span>PT</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="addSplitIT" class="add-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                    <span>IT</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="addSplitST" class="add-split-process-checkbox" style="width: auto; margin-right: 5px;">
                                    <span>ST</span>
                                </label>
                            </div>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                チェックした工程のみが月分割されます。チェックしていない工程は通常通り登録されます。
                            </small>
                        </div>

                        <div class="form-group">
                            <label>総工数</label>
                            <input type="number" id="addTotalHours" step="0.1" min="0" placeholder="例: 80" oninput="updateAddMonthPreview()">
                            <span style="margin-left: 5px;">時間</span>
                        </div>

                        <div class="form-group">
                            <label>作業期間</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="addStartMonth" onchange="updateAddMonthPreview()"></select>
                                <span>〜</span>
                                <select id="addEndMonth" onchange="updateAddMonthPreview()"></select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>分割方法</label>
                            <div style="display: flex; gap: 20px;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="addSplitMethod" value="equal" checked onchange="updateAddMonthPreview()" style="width: auto; margin-right: 5px;">
                                    <span>均等分割</span>
                                </label>
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="radio" name="addSplitMethod" value="manual" onchange="updateAddMonthPreview()" style="width: auto; margin-right: 5px;">
                                    <span>手動設定</span>
                                </label>
                            </div>
                        </div>

                        <div id="addMonthPreview" style="margin-top: 15px;"></div>
                    </div>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="addEstimateFromModal()">登録</button>
                    <button class="btn" onclick="closeAddEstimateModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 既存見積の月分割モーダル -->
    <div id="splitEstimateModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>📅 見積を複数月に分割</h3>
                <button class="modal-close" onclick="closeSplitEstimateModal()">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="splitEstimateId">
                
                <div style="background: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <strong>対象見積:</strong><br>
                    <div id="splitEstimateInfo" style="margin-top: 5px; color: #666;"></div>
                </div>
                
                <div class="form-group">
                    <label>総工数</label>
                    <input type="number" id="splitTotalHours" step="0.1" min="0" readonly style="background: #f0f0f0;">
                    <span style="margin-left: 5px;">時間</span>
                </div>
                
                <div class="form-group">
                    <label>作業期間</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <select id="splitStartMonth" onchange="updateSplitPreview()"></select>
                        <span>〜</span>
                        <select id="splitEndMonth" onchange="updateSplitPreview()"></select>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>分割方法</label>
                    <div style="display: flex; gap: 20px;">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="splitMethodModal" value="equal" checked onchange="updateSplitPreview()" style="width: auto; margin-right: 5px;">
                            <span>均等分割</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="radio" name="splitMethodModal" value="manual" onchange="updateSplitPreview()" style="width: auto; margin-right: 5px;">
                            <span>手動設定</span>
                        </label>
                    </div>
                </div>
                
                <div id="splitPreview" style="margin-top: 15px;"></div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="executeSplitEstimate()">分割を適用</button>
                    <button class="btn" onclick="closeSplitEstimateModal()" style="background: #95a5a6; color: white;">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- その他作業モーダル -->
    <div id="otherWorkModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>その他作業の登録</h3>
                <button class="modal-close" onclick="closeOtherWorkModal()">&times;</button>
            </div>
            <div class="modal-body">
                <!-- タブ切り替え -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0;">
                    <button id="meetingTab" class="other-work-tab active" onclick="switchOtherWorkTab('meeting')">打ち合わせ</button>
                    <button id="customTab" class="other-work-tab" onclick="switchOtherWorkTab('custom')">任意作業</button>
                </div>
                
                <!-- 打ち合わせタブ -->
                <div id="meetingForm" class="other-work-form">
                    <p style="color: #666; margin-bottom: 15px;">全担当者に同じ工数で登録されます。</p>
                    <div class="form-group">
                        <label>工数 (h)</label>
                        <input type="number" id="meetingHours" step="0.5" min="0" placeholder="例: 2">
                    </div>
                    <button class="btn btn-success" onclick="addMeeting()">全員分追加</button>
                </div>
                
                <!-- 任意作業タブ -->
                <div id="customForm" class="other-work-form" style="display: none;">
                    <div class="form-group">
                        <label>作業名</label>
                        <input type="text" id="otherWorkName" placeholder="例: 環境構築、ドキュメント作成">
                    </div>
                    <div class="form-group">
                        <label>担当</label>
                        <select id="otherWorkMember">
                            <option value="">選択...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>工数 (h)</label>
                        <input type="number" id="otherWorkHours" step="0.5" min="0" placeholder="例: 4">
                    </div>
                    <button class="btn btn-success" onclick="addOtherWork()">追加</button>
                </div>
            </div>
        </div>
    </div>

    <!-- カスタムアラート -->
    <div id="customAlert" class="modal">
        <div class="custom-alert-content">
            <div class="custom-alert-body" id="customAlertMessage">
            </div>
            <div class="custom-alert-footer">
                <button class="btn btn-primary" onclick="closeCustomAlert()">OK</button>
            </div>
        </div>
    </div>

    <!-- フローティングフィルタパネル -->
    <button class="floating-filter-toggle" id="floatingFilterToggle" onclick="toggleFloatingFilterPanel(event)">
        🔍
    </button>

    <div class="floating-filter-panel" id="floatingFilterPanel">
        <div class="floating-filter-panel-header">
            <span>フィルタ設定</span>
            <button class="floating-filter-panel-close" onclick="toggleFloatingFilterPanel(event)">×</button>
        </div>
        <div class="floating-filter-panel-body">
            <!-- フィルタタイプ選択 -->
            <div class="floating-filter-group">
                <label class="floating-filter-label">フィルタタイプ</label>
                <div class="floating-filter-buttons">
                    <button id="floatingFilterMonth" onclick="setFloatingFilterType('month')">月別</button>
                    <button id="floatingFilterVersion" onclick="setFloatingFilterType('version')">版数別</button>
                </div>
            </div>

            <!-- 月別フィルタ -->
            <div class="floating-filter-group" id="floatingMonthGroup">
                <label class="floating-filter-label">表示月</label>
                <div class="floating-segment-buttons" id="floatingMonthButtons"></div>
            </div>

            <!-- 版数別フィルタ -->
            <div class="floating-filter-group" id="floatingVersionGroup" style="display: none;">
                <label class="floating-filter-label">版数</label>
                <div class="floating-segment-buttons" id="floatingVersionButtons"></div>
            </div>

            <!-- 表示形式 -->
            <div class="floating-filter-group">
                <label class="floating-filter-label">表示形式</label>
                <div class="floating-filter-buttons">
                    <button id="floatingViewSummary" onclick="setFloatingViewType('summary')">サマリー</button>
                    <button id="floatingViewGrouped" onclick="setFloatingViewType('grouped')">グループ</button>
                    <button id="floatingViewMatrix" onclick="setFloatingViewType('matrix')">マトリクス</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let estimates = [];
        let filteredEstimates = []; // フィルタリングされた見積データ（renderEstimateList関数で設定）
        let actuals = [];
        let companyHolidays = []; // 会社休日データ
        let vacations = []; // 個人休暇データ
        let remainingEstimates = []; // 見込残存時間データ
        let nextCompanyHolidayId = 1;
        let nextVacationId = 1;

        // レポート分析機能の設定
        let reportSettings = {
            accuracyEnabled: true,
            anomalyEnabled: true,
            warningTasksEnabled: true,
            chartEnabled: true,
            trendEnabled: true,
            memberAnalysisEnabled: true,
            insightsEnabled: true
        };

        // グラフカラースキーム定義（テーマカラーに対応）
        const chartColorSchemes = {
            'classic': {
                name: 'クラシック',
                barColors: {
                    estimate: '#667eea',  // クラシック紫青
                    actual: '#43e97b'     // クラシック緑
                },
                processColors: {
                    'UI': '#667eea',  // クラシック紫青
                    'PG': '#f093fb',  // クラシックピンク紫
                    'PT': '#4facfe',  // クラシック青
                    'IT': '#43e97b',  // クラシック緑
                    'ST': '#fa709a'   // クラシックピンク
                }
            },
            'purple': {
                name: '紫',
                barColors: {
                    estimate: '#ba68c8',  // 薄い紫
                    actual: '#80cbc4'     // 薄いティール
                },
                processColors: {
                    'UI': '#64b5f6',  // 薄い青
                    'PG': '#81c784',  // 薄い緑
                    'PT': '#ffb74d',  // 薄いオレンジ
                    'IT': '#e57373',  // 薄い赤
                    'ST': '#ba68c8'   // 薄い紫
                }
            },
            'indigo': {
                name: 'インディゴ',
                barColors: {
                    estimate: '#9fa8da',  // 薄いインディゴ
                    actual: '#ffb74d'     // 薄いオレンジ
                },
                processColors: {
                    'UI': '#90caf9',  // 薄い青
                    'PG': '#a5d6a7',  // 薄い緑
                    'PT': '#ffcc80',  // 薄いオレンジ
                    'IT': '#ef9a9a',  // 薄い赤
                    'ST': '#ce93d8'   // 薄い紫
                }
            },
            'deep-blue': {
                name: 'ディープブルー',
                barColors: {
                    estimate: '#64b5f6',  // 薄いディープブルー
                    actual: '#ffb74d'     // 薄いオレンジ
                },
                processColors: {
                    'UI': '#64b5f6',  // 薄い青
                    'PG': '#81c784',  // 薄い緑
                    'PT': '#ffb74d',  // 薄いオレンジ
                    'IT': '#e57373',  // 薄い赤
                    'ST': '#ba68c8'   // 薄い紫
                }
            },
            'ocean': {
                name: 'オーシャン',
                barColors: {
                    estimate: '#81d4fa',  // 薄いオーシャンブルー
                    actual: '#a5d6a7'     // 薄い緑
                },
                processColors: {
                    'UI': '#81d4fa',  // 薄い水色
                    'PG': '#80cbc4',  // 薄いティール
                    'PT': '#ffcc80',  // 薄いオレンジ
                    'IT': '#f48fb1',  // 薄いピンク
                    'ST': '#ce93d8'   // 薄い紫
                }
            },
            'sky': {
                name: 'スカイブルー',
                barColors: {
                    estimate: '#81d4fa',  // 薄いスカイブルー
                    actual: '#f48fb1'     // 薄いピンク
                },
                processColors: {
                    'UI': '#90caf9',  // 薄いブルー
                    'PG': '#a5d6a7',  // 薄いグリーン
                    'PT': '#ffcc80',  // 薄いオレンジ
                    'IT': '#ef9a9a',  // 薄いレッド
                    'ST': '#ce93d8'   // 薄いパープル
                }
            },
            'navy': {
                name: 'ネイビー',
                barColors: {
                    estimate: '#7986cb',  // 薄いネイビー
                    actual: '#ffb74d'     // 薄いオレンジ
                },
                processColors: {
                    'UI': '#64b5f6',  // 薄いブルー
                    'PG': '#81c784',  // 薄いグリーン
                    'PT': '#ffb74d',  // 薄いオレンジ
                    'IT': '#e57373',  // 薄いレッド
                    'ST': '#ba68c8'   // 薄いパープル
                }
            },
            'teal': {
                name: 'ティール',
                barColors: {
                    estimate: '#80cbc4',  // 薄いティール
                    actual: '#ce93d8'     // 薄い紫
                },
                processColors: {
                    'UI': '#81d4fa',  // 薄いシアン系ブルー
                    'PG': '#80cbc4',  // 薄いティール
                    'PT': '#ffb74d',  // 薄いオレンジ
                    'IT': '#f48fb1',  // 薄いピンク
                    'ST': '#ce93d8'   // 薄い紫
                }
            },
            'cyan': {
                name: 'シアン',
                barColors: {
                    estimate: '#80deea',  // 薄いシアン
                    actual: '#f48fb1'     // 薄いピンク
                },
                processColors: {
                    'UI': '#80deea',  // 薄いシアン
                    'PG': '#80cbc4',  // 薄いティール
                    'PT': '#ffcc80',  // 薄いアンバー
                    'IT': '#f48fb1',  // 薄いピンク
                    'ST': '#ce93d8'   // 薄い紫
                }
            },
            'green': {
                name: 'グリーン',
                barColors: {
                    estimate: '#81c784',  // 薄い緑
                    actual: '#64b5f6'     // 薄い青
                },
                processColors: {
                    'UI': '#64b5f6',  // 薄い青
                    'PG': '#81c784',  // 薄い緑
                    'PT': '#ffb74d',  // 薄いオレンジ
                    'IT': '#e57373',  // 薄い赤
                    'ST': '#ba68c8'   // 薄い紫
                }
            },
            'emerald': {
                name: 'エメラルド',
                barColors: {
                    estimate: '#80cbc4',  // 薄いエメラルド
                    actual: '#ce93d8'     // 薄いパープル
                },
                processColors: {
                    'UI': '#81d4fa',  // 薄いスカイブルー
                    'PG': '#80cbc4',  // 薄いティール
                    'PT': '#ffcc80',  // 薄いアンバー
                    'IT': '#f48fb1',  // 薄いピンク
                    'ST': '#ce93d8'   // 薄いパープル
                }
            },
            'slate': {
                name: 'スレート',
                barColors: {
                    estimate: '#90a4ae',  // 薄いスレート
                    actual: '#81c784'     // 薄い緑
                },
                processColors: {
                    'UI': '#64b5f6',  // 薄いブルー
                    'PG': '#81c784',  // 薄いグリーン
                    'PT': '#ffb74d',  // 薄いオレンジ
                    'IT': '#e57373',  // 薄いレッド
                    'ST': '#ba68c8'   // 薄いパープル
                }
            }
        };

        // Phaseセクションの折り畳み状態
        let phaseCollapsed = {
            phase1: false,
            phase2: false,
            phase3: false
        };

        // 選択されているグラフカラースキーム（'auto'の場合はテーマカラーに追従）
        let selectedChartColorScheme = 'auto';

        // カスタムアラート表示
        function showAlert(message, dismissible = false) {
            const modal = document.getElementById('customAlert');
            const messageEl = document.getElementById('customAlertMessage');
            messageEl.textContent = message;
            modal.style.display = 'flex';

            // dismissibleがtrueの場合、外クリックで閉じる
            if (dismissible) {
                modal.onclick = function(event) {
                    if (event.target === modal) {
                        closeCustomAlert();
                    }
                };
            } else {
                modal.onclick = null;
            }
        }

        // カスタムアラートを閉じる
        function closeCustomAlert() {
            document.getElementById('customAlert').style.display = 'none';
        }

        // グラフカラースキームを取得する関数（'auto'の場合はテーマカラーに対応）
        function getActiveChartColorScheme() {
            if (selectedChartColorScheme === 'auto') {
                // テーマカラーに対応するスキームを返す
                // currentThemeColorとグラフカラースキームのキーが一致している
                if (chartColorSchemes[currentThemeColor]) {
                    return chartColorSchemes[currentThemeColor];
                }
                // デフォルトとして紫を返す
                return chartColorSchemes['purple'];
            } else {
                return chartColorSchemes[selectedChartColorScheme] || chartColorSchemes['purple'];
            }
        }

        function togglePhaseCollapse(phaseId) {
            phaseCollapsed[phaseId] = !phaseCollapsed[phaseId];
            const content = document.getElementById(phaseId + '-content');
            const arrow = document.getElementById(phaseId + '-arrow');
            if (content) {
                content.style.display = phaseCollapsed[phaseId] ? 'none' : 'block';
            }
            if (arrow) {
                arrow.textContent = phaseCollapsed[phaseId] ? '▶' : '▼';
            }
        }

        let autoBackupEnabled = false; // 自動バックアップの設定

        // テーマ設定
        let currentThemeColor = 'purple';
        let currentThemePattern = 'none';
        let currentTabColor = 'same'; // タブの色（'same'=メインカラーと同じ、'default'=青、または色名）

        // レイアウト設定
        let estimateLayout = 'compact'; // 見積一覧のレイアウト（'compact' or 'segmented'）
        let actualLayout = 'compact'; // 実績一覧のレイアウト（'compact' or 'segmented'）
        let reportLayout = 'compact'; // レポートのレイアウト（'compact' or 'segmented'）

        // タブの初回表示フラグ
        let isEstimateTabFirstView = true;
        let isReportTabFirstView = true;

        // 会社休日管理関数
        function addCompanyHoliday() {
            const name = document.getElementById('companyHolidayName').value.trim();
            const startDate = document.getElementById('companyHolidayStartDate').value;
            const endDate = document.getElementById('companyHolidayEndDate').value;

            if (!name || !startDate || !endDate) {
                alert('全ての項目を入力してください');
                return;
            }

            if (startDate > endDate) {
                alert('終了日は開始日以降の日付を指定してください');
                return;
            }

            const holiday = {
                id: nextCompanyHolidayId++,
                name: name,
                startDate: startDate,
                endDate: endDate
            };

            companyHolidays.push(holiday);
            saveData();
            renderCompanyHolidayList();

            // フォームをクリア
            document.getElementById('companyHolidayName').value = '';
            document.getElementById('companyHolidayStartDate').value = '';
            document.getElementById('companyHolidayEndDate').value = '';
        }

        function deleteCompanyHoliday(id) {
            if (!confirm('この会社休日を削除しますか？')) return;
            companyHolidays = companyHolidays.filter(h => h.id !== id);
            saveData();
            renderCompanyHolidayList();
            updateAllDisplays();
        }

        function renderCompanyHolidayList() {
            const container = document.getElementById('companyHolidayList');
            if (companyHolidays.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">会社休日が登録されていません</p>';
                return;
            }

            let html = '<div class="table-wrapper"><table style="min-width: 0;">';
            html += '<tr><th>休日名</th><th>期間</th><th>操作</th></tr>';

            companyHolidays.forEach(h => {
                html += `
                    <tr>
                        <td>${h.name}</td>
                        <td>${h.startDate} ～ ${h.endDate}</td>
                        <td>
                            <button class="btn btn-danger btn-small" onclick="deleteCompanyHoliday(${h.id})">削除</button>
                        </td>
                    </tr>
                `;
            });

            html += '</table></div>';
            container.innerHTML = html;
        }

        // 休暇タイプ変更時のハンドラ
        function handleVacationTypeChange() {
            const vacationType = document.getElementById('quickVacationType').value;
            const hoursInput = document.getElementById('quickVacationHours');

            if (vacationType === '時間休') {
                hoursInput.value = 1;
                hoursInput.max = 8;
            } else {
                hoursInput.value = 8;
                hoursInput.removeAttribute('max');
            }
        }

        // 個人休暇管理関数
        function addQuickVacation() {
            const member = document.getElementById('quickVacationMember').value;
            const date = document.getElementById('quickVacationDate').value;
            const vacationType = document.getElementById('quickVacationType').value;
            const hours = parseFloat(document.getElementById('quickVacationHours').value);

            if (!member || !date || !vacationType || !hours) {
                alert('全ての項目を入力してください');
                return;
            }

            if (hours <= 0 || hours > 8) {
                alert('時間数は1～8の範囲で入力してください');
                return;
            }

            const vacation = {
                id: nextVacationId++,
                member: member,
                date: date,
                vacationType: vacationType,
                hours: hours
            };

            vacations.push(vacation);
            saveData();
            renderActualList();
            showAlert('休暇を登録しました', true);

            // フォームをリセット
            document.getElementById('quickVacationHours').value = 8;
        }

        function deleteVacation(id) {
            if (!confirm('この休暇を削除しますか？')) return;
            vacations = vacations.filter(v => v.id !== id);
            saveData();
            renderActualList();
        }

        function deleteVacationFromModal(id, member, date) {
            if (!confirm('この休暇を削除しますか？')) return;
            vacations = vacations.filter(v => v.id !== id);
            saveData();
            renderActualList();
            // モーダルを再表示
            showWorkDetail(member, date);
        }

        // カレンダーから休暇登録モーダルを開く
        function addVacationFromCalendar(member, date) {
            document.getElementById('vacationModalMember').value = member;
            document.getElementById('vacationModalDate').value = date;
            document.getElementById('vacationModalMemberDisplay').textContent = member;

            const [year, month, day] = date.split('-');
            const dateObj = new Date(date);
            const dayOfWeek = ['日', '月', '火', '水', '木', '金', '土'][dateObj.getDay()];
            document.getElementById('vacationModalDateDisplay').textContent = `${year}年${parseInt(month)}月${parseInt(day)}日(${dayOfWeek})`;

            document.getElementById('vacationModalType').value = '有休';
            document.getElementById('vacationModalHours').value = 8;
            handleVacationModalTypeChange();

            document.getElementById('vacationModal').style.display = 'flex';
        }

        function closeVacationModal() {
            document.getElementById('vacationModal').style.display = 'none';
        }

        function handleVacationModalTypeChange() {
            const type = document.getElementById('vacationModalType').value;
            const hoursInput = document.getElementById('vacationModalHours');
            if (type === '時間休') {
                hoursInput.value = 1;
            } else {
                hoursInput.value = 8;
            }
        }

        function saveVacationFromModal() {
            const member = document.getElementById('vacationModalMember').value;
            const date = document.getElementById('vacationModalDate').value;
            const vacationType = document.getElementById('vacationModalType').value;
            const hours = parseFloat(document.getElementById('vacationModalHours').value);

            if (!member || !date || !vacationType || !hours) {
                alert('全ての項目を入力してください');
                return;
            }

            if (hours <= 0 || hours > 8) {
                alert('時間数は1～8の範囲で入力してください');
                return;
            }

            const vacation = {
                id: nextVacationId++,
                member: member,
                date: date,
                vacationType: vacationType,
                hours: hours
            };

            vacations.push(vacation);
            saveData();
            closeVacationModal();
            renderActualList();
            showAlert('休暇を登録しました', true);
        }

        // 指定日が会社休日かどうかをチェック
        function isCompanyHoliday(dateStr) {
            return companyHolidays.some(h => dateStr >= h.startDate && dateStr <= h.endDate);
        }

        // 指定日の会社休日名を取得
        function getCompanyHolidayName(dateStr) {
            const holiday = companyHolidays.find(h => dateStr >= h.startDate && dateStr <= h.endDate);
            return holiday ? holiday.name : null;
        }

        // 指定日の休暇情報を取得
        function getVacation(member, dateStr) {
            return vacations.filter(v => v.member === member && v.date === dateStr);
        }

        document.addEventListener('DOMContentLoaded', function() {
            loadData();
            loadAutoBackupSetting(); // 自動バックアップ設定を読み込み
            loadThemeSettings(); // テーマ設定を読み込み
            loadReportSettings(); // レポート分析設定を読み込み
            loadChartColorScheme(); // グラフカラースキームを読み込み
            loadDebugModeSetting(); // デバッグモード設定を読み込み
            updateMonthOptions();
            updateEstimateMonthOptions(); // 見積一覧の月選択肢を更新
            updateEstimateVersionOptions(); // 見積一覧の版数選択肢を更新
            updateActualMonthOptions();
            updateMemberOptions();
            updateVersionOptions(); // 版数選択肢を更新
            updateFormNameOptions(); // 帳票名リストを更新
            updateQuickTaskList();
            updateWorkMonthOptions(); // 作業月選択肢を更新

            // 見込残存時間入力モーダル: 外クリックで閉じる
            const remainingHoursModal = document.getElementById('remainingHoursModal');
            if (remainingHoursModal) {
                remainingHoursModal.addEventListener('click', function(event) {
                    if (event.target === remainingHoursModal) {
                        closeRemainingHoursModal();
                    }
                });
            }

            // 見積一覧のデフォルトを版数別の最新版数に設定
            const filterTypeElement = document.getElementById('estimateFilterType');
            if (filterTypeElement) {
                filterTypeElement.value = 'version';
                setEstimateFilterType('version');

                // レポートのフィルタタイプも同期
                const reportFilterType = document.getElementById('reportFilterType');
                if (reportFilterType) {
                    reportFilterType.value = 'version';
                    // フィルタタイプ変更ハンドラーを呼び出してUIを更新
                    handleReportFilterTypeChange();
                }
            }

            // クイック入力の見積登録フォームを初期化
            initQuickEstimateForm();

            // 各タブのデフォルト月を設定
            setDefaultEstimateMonth(); // 見積タブ
            setDefaultActualMonth(); // 実績タブ
            setDefaultReportMonth(); // レポートタブ

            renderEstimateList();
            renderActualList();
            renderTodayActuals();
            updateReport();
            renderCompanyHolidayList();

            // セグメントボタンの初期色をテーマカラーに設定
            initSegmentButtonColors();

            // モバイルでタブのスワイプ切り替え機能を追加
            initTabSwipe();

            // モーダルのクリックハンドラーをセットアップ
            setupModalHandlers();
        });

        // モーダルのクリック・ドラッグハンドラーをセットアップ
        function setupModalHandlers() {
            // モーダルIDと閉じる関数のマッピング
            const modals = [
                { id: 'workModal', closeFunc: closeWorkModal },
                { id: 'editActualModal', closeFunc: closeEditActualModal },
                { id: 'bulkRemainingModal', closeFunc: closeBulkRemainingModal },
                { id: 'vacationModal', closeFunc: closeVacationModal },
                { id: 'editEstimateModal', closeFunc: closeEditEstimateModal },
                { id: 'editTaskModal', closeFunc: closeEditTaskModal },
                { id: 'processBreakdownModal', closeFunc: closeProcessBreakdownModal },
                { id: 'addEstimateModal', closeFunc: closeAddEstimateModal },
                { id: 'splitEstimateModal', closeFunc: closeSplitEstimateModal },
                { id: 'otherWorkModal', closeFunc: closeOtherWorkModal }
            ];

            modals.forEach(modal => {
                const modalElement = document.getElementById(modal.id);
                if (!modalElement) return;

                let mouseDownTarget = null;

                // mousedownイベントで開始位置を記録
                modalElement.addEventListener('mousedown', (e) => {
                    mouseDownTarget = e.target;
                });

                // mouseupイベントで終了位置を確認
                modalElement.addEventListener('mouseup', (e) => {
                    // mousedownとmouseupの両方がモーダル背景（.modal）だった場合のみ閉じる
                    if (mouseDownTarget === modalElement && e.target === modalElement) {
                        modal.closeFunc();
                    }
                    mouseDownTarget = null;
                });

                // マウスがモーダル外に出た場合、リセット
                modalElement.addEventListener('mouseleave', () => {
                    mouseDownTarget = null;
                });
            });
        }

        // セグメントボタンの初期色をテーマカラーに設定
        function initSegmentButtonColors() {
            try {
                const themeColor = getThemeColor();

                // レポートフィルタタイプボタン（版数別がデフォルト選択）
                const reportFilterType = document.getElementById('reportFilterType');
                const btnFilterMonth = document.getElementById('btnFilterMonth');
                const btnFilterVersion = document.getElementById('btnFilterVersion');
                if (reportFilterType && btnFilterMonth && btnFilterVersion) {
                    const type = reportFilterType.value;
                    btnFilterMonth.style.background = type === 'month' ? themeColor : 'white';
                    btnFilterMonth.style.color = type === 'month' ? 'white' : '#333';
                    btnFilterVersion.style.background = type === 'version' ? themeColor : 'white';
                    btnFilterVersion.style.color = type === 'version' ? 'white' : '#333';
                }

                // 見積一覧フィルタタイプボタン（版数別がデフォルト選択）
                const estimateFilterType = document.getElementById('estimateFilterType');
                const btnEstimateFilterMonth = document.getElementById('btnEstimateFilterMonth');
                const btnEstimateFilterVersion = document.getElementById('btnEstimateFilterVersion');
                if (estimateFilterType && btnEstimateFilterMonth && btnEstimateFilterVersion) {
                    const type = estimateFilterType.value;
                    btnEstimateFilterMonth.style.background = type === 'month' ? themeColor : 'white';
                    btnEstimateFilterMonth.style.color = type === 'month' ? 'white' : '#333';
                    btnEstimateFilterVersion.style.background = type === 'version' ? themeColor : 'white';
                    btnEstimateFilterVersion.style.color = type === 'version' ? 'white' : '#333';
                }

                // レポート表示形式ボタン（現在の選択に応じて）
                const reportViewType = document.getElementById('reportViewType');
                const btnReportSummary = document.getElementById('btnReportSummary');
                const btnReportGrouped = document.getElementById('btnReportGrouped');
                const btnReportMatrix = document.getElementById('btnReportMatrix');
                if (reportViewType && btnReportSummary && btnReportGrouped && btnReportMatrix) {
                    const type = reportViewType.value;
                    btnReportSummary.style.background = type === 'summary' ? themeColor : 'white';
                    btnReportSummary.style.color = type === 'summary' ? 'white' : '#333';
                    btnReportGrouped.style.background = type === 'grouped' ? themeColor : 'white';
                    btnReportGrouped.style.color = type === 'grouped' ? 'white' : '#333';
                    btnReportMatrix.style.background = type === 'matrix' ? themeColor : 'white';
                    btnReportMatrix.style.color = type === 'matrix' ? 'white' : '#333';
                }

                // 実績一覧表示形式ボタン（現在の選択に応じて）
                const actualViewType = document.getElementById('actualViewType');
                const btnActualMatrix = document.getElementById('btnActualMatrix');
                const btnActualList = document.getElementById('btnActualList');
                if (actualViewType && btnActualMatrix && btnActualList) {
                    const type = actualViewType.value;
                    btnActualMatrix.style.background = type === 'matrix' ? themeColor : 'white';
                    btnActualMatrix.style.color = type === 'matrix' ? 'white' : '#333';
                    btnActualList.style.background = type === 'list' ? themeColor : 'white';
                    btnActualList.style.color = type === 'list' ? 'white' : '#333';
                }

                // 見積一覧表示形式ボタン（現在の選択に応じて）
                const estimateViewType = document.getElementById('estimateViewType');
                const btnEstimateGrouped = document.getElementById('btnEstimateGrouped');
                const btnEstimateMatrix = document.getElementById('btnEstimateMatrix');
                const btnEstimateList = document.getElementById('btnEstimateList');
                if (estimateViewType && btnEstimateGrouped && btnEstimateMatrix && btnEstimateList) {
                    const type = estimateViewType.value;
                    btnEstimateGrouped.style.background = type === 'grouped' ? themeColor : 'white';
                    btnEstimateGrouped.style.color = type === 'grouped' ? 'white' : '#333';
                    btnEstimateMatrix.style.background = type === 'matrix' ? themeColor : 'white';
                    btnEstimateMatrix.style.color = type === 'matrix' ? 'white' : '#333';
                    btnEstimateList.style.background = type === 'list' ? themeColor : 'white';
                    btnEstimateList.style.color = type === 'list' ? 'white' : '#333';
                }
            } catch (e) {
                console.error('initSegmentButtonColors error:', e);
            }
        }

        // タブのスワイプ切り替え機能を初期化
        function initTabSwipe() {
            const content = document.querySelector('.content');
            if (!content) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;
            let touchStartTarget = null;

            const minSwipeDistance = 100; // 最小スワイプ距離（ピクセル）
            const maxVerticalDistance = 50; // 縦方向の最大移動距離（これ以上動くとスワイプと判定しない）

            // スワイプを無効にすべき要素かどうかを判定
            function shouldDisableSwipe(target) {
                if (!target) return false;

                // 入力要素系でのスワイプは無効
                const tagName = target.tagName;
                if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') {
                    return true;
                }

                // セグメントボタンコンテナ内でのスワイプは無効
                const segmentButton = target.closest('[id$="Buttons2"]');
                if (segmentButton) return true;

                // 特定のクラスやその親要素でのスワイプは無効
                const element = target.closest('.table-wrapper, .estimate-table-wrapper, .modal.active, .custom-dropdown, #dragHandle, #workMonthAssignmentMode');
                return element !== null;
            }

            content.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
                touchStartTarget = e.target;
            }, { passive: true });

            content.addEventListener('touchend', function(e) {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            function handleSwipe() {
                // スワイプを無効にすべき要素でタッチが開始された場合は処理しない
                if (shouldDisableSwipe(touchStartTarget)) {
                    return;
                }

                const diffX = touchEndX - touchStartX;
                const diffY = Math.abs(touchEndY - touchStartY);
                const absDiffX = Math.abs(diffX);

                // 縦方向の移動が大きい場合はスワイプと判定しない（スクロールと判断）
                if (diffY > maxVerticalDistance) {
                    return;
                }

                // 縦方向の移動が横方向の移動より大きい場合はスワイプと判定しない
                if (diffY > absDiffX) {
                    return;
                }

                // 左スワイプ（次のタブへ）
                if (diffX < -minSwipeDistance) {
                    nextTab();
                }
                // 右スワイプ（前のタブへ）
                else if (diffX > minSwipeDistance) {
                    prevTab();
                }
            }
        }

        function loadAutoBackupSetting() {
            const saved = localStorage.getItem('autoBackupEnabled');
            autoBackupEnabled = saved === 'true';
            document.getElementById('autoBackupEnabled').checked = autoBackupEnabled;
        }

        function saveAutoBackupSetting() {
            autoBackupEnabled = document.getElementById('autoBackupEnabled').checked;
            localStorage.setItem('autoBackupEnabled', autoBackupEnabled);
        }

        function saveQuickInputModeSetting() {
            rememberQuickInputMode = document.getElementById('rememberQuickInputMode').checked;
            localStorage.setItem('rememberQuickInputMode', rememberQuickInputMode);
        }

        function loadReportSettings() {
            const saved = localStorage.getItem('reportSettings');
            if (saved) {
                reportSettings = JSON.parse(saved);
            }
            // UIに反映
            document.getElementById('reportAccuracyEnabled').checked = reportSettings.accuracyEnabled;
            document.getElementById('reportAnomalyEnabled').checked = reportSettings.anomalyEnabled;
            document.getElementById('reportWarningTasksEnabled').checked = reportSettings.warningTasksEnabled;
            document.getElementById('reportChartEnabled').checked = reportSettings.chartEnabled;
            document.getElementById('reportTrendEnabled').checked = reportSettings.trendEnabled;
            document.getElementById('reportMemberAnalysisEnabled').checked = reportSettings.memberAnalysisEnabled;
            document.getElementById('reportInsightsEnabled').checked = reportSettings.insightsEnabled;
        }

        function saveReportSettings() {
            reportSettings.accuracyEnabled = document.getElementById('reportAccuracyEnabled').checked;
            reportSettings.anomalyEnabled = document.getElementById('reportAnomalyEnabled').checked;
            reportSettings.warningTasksEnabled = document.getElementById('reportWarningTasksEnabled').checked;
            reportSettings.chartEnabled = document.getElementById('reportChartEnabled').checked;
            reportSettings.trendEnabled = document.getElementById('reportTrendEnabled').checked;
            reportSettings.memberAnalysisEnabled = document.getElementById('reportMemberAnalysisEnabled').checked;
            reportSettings.insightsEnabled = document.getElementById('reportInsightsEnabled').checked;
            localStorage.setItem('reportSettings', JSON.stringify(reportSettings));
        }

        function saveData(skipAutoBackup = false) {
            const data = {
                estimates: estimates,
                actuals: actuals,
                companyHolidays: companyHolidays,
                vacations: vacations,
                settings: {
                    memberOrder: document.getElementById('memberOrder').value.trim(),
                    themeColor: currentThemeColor,
                    themePattern: currentThemePattern,
                    themeTabColor: currentTabColor,
                    autoBackup: autoBackupEnabled,
                    estimateLayout: estimateLayout,
                    actualLayout: actualLayout,
                    reportLayout: reportLayout,
                    showMonthColors: showMonthColorsSetting,
                    showDeviationColors: showDeviationColorsSetting,
                    showProgressBars: showProgressBarsSetting,
                    showProgressPercentage: showProgressPercentageSetting,
                    progressBarStyle: progressBarStyle,
                    matrixEstActFormat: matrixEstActFormat,
                    matrixDayMonthFormat: matrixDayMonthFormat,
                    defaultEstimateViewType: document.getElementById('defaultEstimateViewType') ? document.getElementById('defaultEstimateViewType').value : 'grouped',
                    defaultReportViewType: document.getElementById('defaultReportViewType') ? document.getElementById('defaultReportViewType').value : 'grouped',
                    chartColorScheme: selectedChartColorScheme
                }
            };

            localStorage.setItem('manhour_estimates', JSON.stringify(estimates));
            localStorage.setItem('manhour_actuals', JSON.stringify(actuals));
            localStorage.setItem('manhour_companyHolidays', JSON.stringify(companyHolidays));
            localStorage.setItem('manhour_vacations', JSON.stringify(vacations));
            localStorage.setItem('manhour_remainingEstimates', JSON.stringify(remainingEstimates));
            localStorage.setItem('manhour_settings', JSON.stringify(data.settings));

            // 作業月選択肢を更新
            updateWorkMonthOptions();

            // 版数選択肢を更新
            updateVersionOptions();

            // 帳票名リストを更新
            updateFormNameOptions();

            // 自動バックアップが有効な場合のみ実行
            if (!skipAutoBackup && autoBackupEnabled) {
                autoBackup();
            }
        }

        function updateMemberOptions() {
            // 見積と実績データから担当者を抽出
            const members = new Set();
            estimates.forEach(e => members.add(e.member));
            actuals.forEach(a => members.add(a.member));
            
            // 表示順が設定されている場合はそれを使用
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                orderList.forEach(name => {
                    if (members.has(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                Array.from(members).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(members).sort();
            }
            
            // 各工程の担当者選択肢を更新（見積管理タブとクイック入力タブ）
            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            processes.forEach(process => {
                // 見積管理タブ（削除済み）の estXX_member は不要だが、念のため残す
                const select = document.getElementById(`est${process}_member`);
                if (select) {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">-</option>';

                    sortedMembers.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member;
                        option.textContent = member;
                        select.appendChild(option);
                    });

                    // 以前の選択を復元
                    if (currentValue && sortedMembers.includes(currentValue)) {
                        select.value = currentValue;
                    }
                }

                // クイック入力の見積登録フォーム
                const quickEstSelect = document.getElementById(`quickEst${process}_member`);
                if (quickEstSelect) {
                    const currentValue = quickEstSelect.value;
                    quickEstSelect.innerHTML = '<option value="">-</option>';

                    sortedMembers.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member;
                        option.textContent = member;
                        quickEstSelect.appendChild(option);
                    });

                    // 以前の選択を復元
                    if (currentValue && sortedMembers.includes(currentValue)) {
                        quickEstSelect.value = currentValue;
                    }
                }

                // 見積登録モーダルの担当者選択肢も更新
                const addEstSelect = document.getElementById(`addEst${process}_member`);
                if (addEstSelect) {
                    const currentValue = addEstSelect.value;
                    addEstSelect.innerHTML = '<option value="">-</option>';

                    sortedMembers.forEach(member => {
                        const option = document.createElement('option');
                        option.value = member;
                        option.textContent = member;
                        addEstSelect.appendChild(option);
                    });

                    // 以前の選択を復元
                    if (currentValue && sortedMembers.includes(currentValue)) {
                        addEstSelect.value = currentValue;
                    }
                }
            });
            
            // クイック入力の担当者選択肢も更新
            const quickMemberSelect = document.getElementById('quickMember');
            if (quickMemberSelect) {
                const currentValue = quickMemberSelect.value;
                quickMemberSelect.innerHTML = '';
                
                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    quickMemberSelect.appendChild(option);
                });
                
                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    quickMemberSelect.value = currentValue;
                } else if (sortedMembers.length > 0) {
                    quickMemberSelect.value = sortedMembers[0];
                }
            }
            
            // その他作業の担当者選択肢も更新
            const otherWorkMemberSelect = document.getElementById('otherWorkMember');
            if (otherWorkMemberSelect) {
                const currentValue = otherWorkMemberSelect.value;
                otherWorkMemberSelect.innerHTML = '<option value="">選択...</option>';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    otherWorkMemberSelect.appendChild(option);
                });

                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    otherWorkMemberSelect.value = currentValue;
                }
            }

            // 実績編集モーダルの担当者選択肢を更新
            const editActualMemberSelect = document.getElementById('editActualMember');
            if (editActualMemberSelect) {
                const currentValue = editActualMemberSelect.value;
                editActualMemberSelect.innerHTML = '';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    editActualMemberSelect.appendChild(option);
                });

                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    editActualMemberSelect.value = currentValue;
                }
            }

            // 休暇登録フォームの担当者選択肢を更新
            const quickVacationMemberSelect = document.getElementById('quickVacationMember');
            if (quickVacationMemberSelect) {
                const currentValue = quickVacationMemberSelect.value;
                quickVacationMemberSelect.innerHTML = '';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    quickVacationMemberSelect.appendChild(option);
                });

                // 以前の選択を復元、または最初の担当者を選択
                if (currentValue && sortedMembers.includes(currentValue)) {
                    quickVacationMemberSelect.value = currentValue;
                } else if (sortedMembers.length > 0) {
                    quickVacationMemberSelect.value = sortedMembers[0];
                }
            }

            // 見積編集モーダルの担当者選択肢を更新
            const editEstimateMemberSelect = document.getElementById('editEstimateMember');
            if (editEstimateMemberSelect) {
                const currentValue = editEstimateMemberSelect.value;
                editEstimateMemberSelect.innerHTML = '';

                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    editEstimateMemberSelect.appendChild(option);
                });

                // 以前の選択を復元
                if (currentValue && sortedMembers.includes(currentValue)) {
                    editEstimateMemberSelect.value = currentValue;
                }
            }
        }

        // 版数選択肢を更新する関数
        function updateVersionOptions() {
            try {
                // 見積と実績データから版数を抽出
                const versions = new Set();
                estimates.forEach(e => {
                    if (e.version) versions.add(e.version);
                });
                actuals.forEach(a => {
                    if (a.version) versions.add(a.version);
                });

                // 版数をソート（昇順：版数名順、最新が最後）
                const sortedVersions = Array.from(versions).sort();

                // 各版数セレクトボックスを更新
                const versionSelects = [
                    'estVersion',           // 新規見積登録（削除済みだが念のため残す）
                    'quickEstVersion',      // クイック入力の見積登録
                    'editActualVersion',    // 実績編集/新規モーダル
                    'editEstimateVersion',  // 見積編集モーダル
                    'addEstVersion'         // 見積登録モーダル
                ];

                versionSelects.forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        const currentValue = select.value;
                        select.innerHTML = '<option value="">-- 版数を選択 --</option>';

                        // 「新規追加」オプション
                        const newOption = document.createElement('option');
                        newOption.value = '__new__';
                        newOption.textContent = '+ 新しい版数を追加...';
                        select.appendChild(newOption);

                        // 既存の版数
                        sortedVersions.forEach(version => {
                            const option = document.createElement('option');
                            option.value = version;
                            option.textContent = version;
                            select.appendChild(option);
                        });

                        // 以前の選択を復元、なければ最新版数をデフォルトに
                        if (currentValue && currentValue !== '__new__') {
                            select.value = currentValue;
                        } else if (sortedVersions.length > 0 && selectId === 'addEstVersion') {
                            // 見積登録モーダルは最新版数をデフォルトに
                            select.value = sortedVersions[sortedVersions.length - 1];
                        }
                    }
                });

                // レポート用の版数フィルター更新
                updateReportVersionOptions(sortedVersions);
            } catch (e) {
                console.error('updateVersionOptions error:', e);
            }
        }

        // 帳票名リストを更新（見積データから抽出）
        function updateFormNameOptions() {
            try {
                // 見積データから帳票名を抽出（アンダーバーまたは全角コロンの左側）
                const formNames = new Set();
                estimates.forEach(e => {
                    if (e.task) {
                        if (e.task.includes('_')) {
                            const formName = e.task.split('_')[0];
                            if (formName.trim()) {
                                formNames.add(formName.trim());
                            }
                        } else if (e.task.includes('：')) {
                            const formName = e.task.split('：')[0];
                            if (formName.trim()) {
                                formNames.add(formName.trim());
                            }
                        }
                    }
                });

                // アルファベット順にソート
                const sortedFormNames = Array.from(formNames).sort();

                // selectを更新
                const selectIds = ['quickEstFormNameSelect', 'addEstFormNameSelect', 'editTaskFormNameSelect'];
                selectIds.forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        // 現在の選択値を保存
                        const currentValue = select.value;

                        // 基本オプションのみ残す
                        select.innerHTML = '<option value="">-- 帳票名を選択 --</option>';

                        // 帳票名オプションを追加
                        sortedFormNames.forEach(formName => {
                            const option = document.createElement('option');
                            option.value = formName;
                            option.textContent = formName;
                            select.appendChild(option);
                        });

                        // 新規入力オプションを追加
                        const newOption = document.createElement('option');
                        newOption.value = '__new__';
                        newOption.textContent = '新規入力';
                        select.appendChild(newOption);

                        // 選択値を復元（存在する場合）
                        if (currentValue && (currentValue === '__new__' || sortedFormNames.includes(currentValue))) {
                            select.value = currentValue;
                        }
                    }
                });
            } catch (e) {
                console.error('updateFormNameOptions error:', e);
            }
        }

        // レポート用の版数フィルターオプションを更新する関数
        function updateReportVersionOptions(sortedVersions) {
            try {
                // sortedVersionsが渡されない場合は再計算
                if (!sortedVersions) {
                    const versions = new Set();
                    estimates.forEach(e => {
                        if (e.version && e.version.trim() !== '') {
                            versions.add(e.version);
                        }
                    });
                    actuals.forEach(a => {
                        if (a.version && a.version.trim() !== '') {
                            versions.add(a.version);
                        }
                    });
                    // 昇順でソート（版数名順）
                    sortedVersions = Array.from(versions).sort();
                } else {
                    // 渡された配列を昇順にソートし直す
                    sortedVersions = sortedVersions.slice().sort();
                }

                const select = document.getElementById('reportVersion');
                const select2 = document.getElementById('reportVersion2');

                if (!select) return;

                // 初回表示時は最後の版数をデフォルト選択、それ以外は以前の選択を復元
                const isFirstLoad = !select.dataset.initialized;
                const lastVersion = sortedVersions.length > 0 ? sortedVersions[sortedVersions.length - 1] : 'all';
                const currentValue = isFirstLoad ? lastVersion : (select.value || 'all');

                // 選択肢を生成
                select.innerHTML = '<option value="all">全版数</option>';
                if (select2) select2.innerHTML = '<option value="all">全版数</option>';

                sortedVersions.forEach(version => {
                    const option = document.createElement('option');
                    option.value = version;
                    option.textContent = version;
                    select.appendChild(option);

                    if (select2) {
                        const option2 = document.createElement('option');
                        option2.value = version;
                        option2.textContent = version;
                        select2.appendChild(option2);
                    }
                });

                // 選択を設定
                select.value = currentValue;
                if (select2) select2.value = currentValue;
                select.dataset.initialized = 'true';

                // セグメントボタン版を生成
                const items = [
                    { value: 'all', label: '全版数' },
                    ...sortedVersions.map(version => ({
                        value: version,
                        label: version
                    }))
                ];
                createSegmentButtons(
                    'reportVersionButtons2',
                    'reportVersion2',
                    items,
                    currentValue,
                    8,
                    handleReportVersionChange
                );
            } catch (e) {
                console.error('updateReportVersionOptions error:', e);
            }
        }

        // 帳票名選択時の処理（クイック入力用）
        function handleQuickFormNameChange() {
            const select = document.getElementById('quickEstFormNameSelect');
            const input = document.getElementById('quickEstFormName');

            if (select.value === '__new__') {
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            } else {
                input.value = select.value;
            }
        }

        // 帳票名選択時の処理（見積登録モーダル用）
        function handleAddFormNameChange() {
            const select = document.getElementById('addEstFormNameSelect');
            const input = document.getElementById('addEstFormName');

            if (select.value === '__new__') {
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            } else {
                input.value = select.value;
            }
        }

        // 帳票名選択時の処理（対応編集モーダル用）
        function handleEditFormNameChange() {
            const select = document.getElementById('editTaskFormNameSelect');
            const input = document.getElementById('editTaskFormName');

            if (select.value === '__new__') {
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            } else {
                input.value = select.value;
            }
        }

        // 版数選択時の処理（新規追加対応）
        function handleVersionChange(selectId) {
            const select = document.getElementById(selectId);
            if (select.value === '__new__') {
                const newVersion = prompt('新しい版数を入力してください（例: 第2025.12版）');
                if (newVersion && newVersion.trim()) {
                    // 新しい版数をオプションに追加
                    const option = document.createElement('option');
                    option.value = newVersion.trim();
                    option.textContent = newVersion.trim();
                    select.insertBefore(option, select.options[2]); // 「新規追加」の次に挿入
                    select.value = newVersion.trim();
                } else {
                    select.value = '';
                }
            }

            // 実績編集モーダルの版数が変更された場合、対応名リストを更新
            if (selectId === 'editActualVersion') {
                const modal = document.getElementById('editActualModal');
                const memberSelect = document.getElementById('editActualMember');
                let member = memberSelect ? memberSelect.value : null;

                // 担当者が取得できない場合は、datasetから取得（新規登録時）
                if (!member && modal && modal.dataset.calendarMember) {
                    member = modal.dataset.calendarMember;
                }

                if (member) {
                    // 編集モードかどうかを判定（editActualIdに値があれば編集モード）
                    const editIdInput = document.getElementById('editActualId');
                    const isEditMode = editIdInput && editIdInput.value !== '';
                    updateEditActualTaskList(member, isEditMode, select.value);
                }
            }
        }

        // 実績編集モーダルの担当者選択時の処理
        function handleEditActualMemberChange() {
            const memberSelect = document.getElementById('editActualMember');
            const versionSelect = document.getElementById('editActualVersion');
            const member = memberSelect ? memberSelect.value : null;
            const version = versionSelect ? versionSelect.value : null;

            if (member) {
                // 編集モードかどうかを判定（editActualIdに値があれば編集モード）
                const editIdInput = document.getElementById('editActualId');
                const isEditMode = editIdInput && editIdInput.value !== '';
                updateEditActualTaskList(member, isEditMode, version);
            }
        }

        function loadData() {
            const savedEstimates = localStorage.getItem('manhour_estimates');
            const savedActuals = localStorage.getItem('manhour_actuals');
            const savedCompanyHolidays = localStorage.getItem('manhour_companyHolidays');
            const savedVacations = localStorage.getItem('manhour_vacations');
            const savedRemainingEstimates = localStorage.getItem('manhour_remainingEstimates');
            const savedSettings = localStorage.getItem('manhour_settings');

            if (savedEstimates) estimates = JSON.parse(savedEstimates);
            if (savedActuals) actuals = JSON.parse(savedActuals);
            if (savedCompanyHolidays) companyHolidays = JSON.parse(savedCompanyHolidays);
            if (savedVacations) vacations = JSON.parse(savedVacations);
            if (savedRemainingEstimates) remainingEstimates = JSON.parse(savedRemainingEstimates);

            // 次のIDを設定
            if (companyHolidays.length > 0) {
                nextCompanyHolidayId = Math.max(...companyHolidays.map(h => h.id)) + 1;
            }
            if (vacations.length > 0) {
                nextVacationId = Math.max(...vacations.map(v => v.id)) + 1;
            }

            // 設定を読み込み
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.memberOrder) {
                    document.getElementById('memberOrder').value = settings.memberOrder;
                }
                if (settings.themeColor) currentThemeColor = settings.themeColor;
                if (settings.themePattern) currentThemePattern = settings.themePattern;
                if (settings.themeTabColor) currentTabColor = settings.themeTabColor;
                if (settings.autoBackup !== undefined) autoBackupEnabled = settings.autoBackup;
                if (settings.estimateLayout) estimateLayout = settings.estimateLayout;
                if (settings.actualLayout) actualLayout = settings.actualLayout;
                if (settings.reportLayout) reportLayout = settings.reportLayout;
                if (settings.showMonthColors !== undefined) {
                    showMonthColorsSetting = settings.showMonthColors;
                    const checkbox = document.getElementById('showMonthColorsCheckbox');
                    if (checkbox) checkbox.checked = showMonthColorsSetting;
                }
                // 乖離率背景色の設定を読み込み
                if (settings.showDeviationColors !== undefined) {
                    showDeviationColorsSetting = settings.showDeviationColors;
                    const checkbox = document.getElementById('showDeviationColorsCheckbox');
                    if (checkbox) checkbox.checked = showDeviationColorsSetting;
                }
                // 進捗バー表示の設定を読み込み
                if (settings.showProgressBars !== undefined) {
                    showProgressBarsSetting = settings.showProgressBars;
                    const checkbox = document.getElementById('showProgressBarsCheckbox');
                    if (checkbox) checkbox.checked = showProgressBarsSetting;
                }
                // 進捗バーのパーセンテージ表示の設定を読み込み
                if (settings.showProgressPercentage !== undefined) {
                    showProgressPercentageSetting = settings.showProgressPercentage;
                    const checkbox = document.getElementById('showProgressPercentageCheckbox');
                    if (checkbox) checkbox.checked = showProgressPercentageSetting;
                }
                // 進捗バーのスタイル設定を読み込み
                if (settings.progressBarStyle) {
                    progressBarStyle = settings.progressBarStyle;
                    const radioButton = document.querySelector(`input[name="progressBarStyle"][value="${settings.progressBarStyle}"]`);
                    if (radioButton) radioButton.checked = true;
                }
                // 見積と実績の表示形式の設定を読み込み
                if (settings.matrixEstActFormat) {
                    matrixEstActFormat = settings.matrixEstActFormat;
                    const radioButton = document.querySelector(`input[name="matrixEstActFormat"][value="${settings.matrixEstActFormat}"]`);
                    if (radioButton) radioButton.checked = true;
                }
                // 人日/人月表示形式の設定を読み込み
                if (settings.matrixDayMonthFormat) {
                    matrixDayMonthFormat = settings.matrixDayMonthFormat;
                    const radioButton = document.querySelector(`input[name="matrixDayMonthFormat"][value="${settings.matrixDayMonthFormat}"]`);
                    if (radioButton) radioButton.checked = true;
                }
                // デフォルト表示形式の設定を読み込み
                if (settings.defaultEstimateViewType) {
                    const estimateViewTypeSelect = document.getElementById('defaultEstimateViewType');
                    if (estimateViewTypeSelect) {
                        estimateViewTypeSelect.value = settings.defaultEstimateViewType;
                    }
                }
                if (settings.defaultReportViewType) {
                    const reportViewTypeSelect = document.getElementById('defaultReportViewType');
                    if (reportViewTypeSelect) {
                        reportViewTypeSelect.value = settings.defaultReportViewType;
                    }
                }
            } else {
                // 旧形式の設定を読み込み（後方互換性）
                const savedMemberOrder = localStorage.getItem('manhour_memberOrder');
                if (savedMemberOrder) {
                    document.getElementById('memberOrder').value = savedMemberOrder;
                }
            }

            // レイアウト設定を適用
            applyLayoutSettings();
        }

        function updateMonthOptions() {
            const select = document.getElementById('reportMonth');
            const select2 = document.getElementById('reportMonth2');
            const months = new Set();

            // 実績データから月を抽出
            actuals.forEach(a => {
                if (a.date) {
                    const month = a.date.substring(0, 7); // YYYY-MM形式
                    months.add(month);
                }
            });

            // 月を昇順でソート（古い月→新しい月）
            const sortedMonths = Array.from(months).sort();

            // 選択肢を生成（両方のセレクトボックス）
            select.innerHTML = '<option value="all">全期間</option>';
            if (select2) select2.innerHTML = '<option value="all">全期間</option>';

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const option = document.createElement('option');
                option.value = month;
                option.textContent = `${year}年${parseInt(monthNum)}月`;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = month;
                    option2.textContent = `${year}年${parseInt(monthNum)}月`;
                    select2.appendChild(option2);
                }
            });

            // セグメントボタン版を生成（レポートセグメントレイアウト用）
            const items = [
                { value: 'all', label: '全期間' },
                ...sortedMonths.slice().map(month => {
                    const [year, monthNum] = month.split('-');
                    return {
                        value: month,
                        label: `${year}/${parseInt(monthNum)}`
                    };
                })
            ];
            const currentValue = select.value || 'all';
            createSegmentButtons(
                'reportMonthButtons2',
                'reportMonth2',
                items,
                currentValue,
                8, // 最大8個までセグメントボタン表示
                handleReportMonthChange
            );
        }

        function updateEstimateMonthOptions() {
            const select = document.getElementById('estimateMonthFilter');
            const select2 = document.getElementById('estimateMonthFilter2');
            if (!select) return;

            const months = new Set();

            // 見積データから作業予定月を抽出
            estimates.forEach(e => {
                const est = normalizeEstimate(e);
                est.workMonths.forEach(month => {
                    if (month && month !== 'unassigned') {
                        months.add(month);
                    }
                });
            });

            // 月を降順でソート（最新が上）
            const sortedMonths = Array.from(months).sort().reverse();

            // 選択肢を生成（両方のセレクトボックス）
            select.innerHTML = '<option value="all">全期間</option>';
            if (select2) select2.innerHTML = '<option value="all">全期間</option>';

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const option = document.createElement('option');
                option.value = month;
                option.textContent = `${year}年${parseInt(monthNum)}月`;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = month;
                    option2.textContent = `${year}年${parseInt(monthNum)}月`;
                    select2.appendChild(option2);
                }
            });

            // セグメントボタン版を生成
            const items = [
                { value: 'all', label: '全期間' },
                ...sortedMonths.slice().reverse().map(month => {
                    const [year, monthNum] = month.split('-');
                    return {
                        value: month,
                        label: `${year}/${parseInt(monthNum)}`
                    };
                })
            ];
            const currentValue = select.value || 'all';
            createSegmentButtons(
                'estimateMonthButtons2',
                'estimateMonthFilter2',
                items,
                currentValue,
                8, // 最大8個までセグメントボタン表示
                handleEstimateMonthChange
            );
        }

        function updateEstimateVersionOptions() {
            const select = document.getElementById('estimateVersionFilter');
            const select2 = document.getElementById('estimateVersionFilter2');
            if (!select) return;

            const versions = new Set();

            // 見積データから版数を抽出
            estimates.forEach(e => {
                if (e.version) {
                    versions.add(e.version);
                }
            });

            // 版数を降順でソート（最新が上）
            const sortedVersions = Array.from(versions).sort().reverse();

            // 選択肢を生成（両方のセレクトボックス）
            select.innerHTML = '<option value="all">全版数</option>';
            if (select2) select2.innerHTML = '<option value="all">全版数</option>';

            sortedVersions.forEach(version => {
                const option = document.createElement('option');
                option.value = version;
                option.textContent = version;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = version;
                    option2.textContent = version;
                    select2.appendChild(option2);
                }
            });

            // デフォルトで最新の版数を選択
            const defaultValue = sortedVersions.length > 0 ? sortedVersions[0] : 'all';
            select.value = defaultValue;
            if (select2) select2.value = defaultValue;

            // セグメントボタン版を生成
            const items = [
                { value: 'all', label: '全版数' },
                ...sortedVersions.slice().reverse().map(version => {
                    return {
                        value: version,
                        label: version
                    };
                })
            ];
            createSegmentButtons(
                'estimateVersionButtons2',
                'estimateVersionFilter2',
                items,
                defaultValue,
                8, // 最大8個までセグメントボタン表示
                handleEstimateVersionChange
            );
        }

        function handleEstimateFilterTypeChange() {
            const filterType = document.getElementById('estimateFilterType').value;
            const monthFilterCompact = document.getElementById('estimateMonthFilterCompact');
            const versionFilterCompact = document.getElementById('estimateVersionFilterCompact');
            const monthFilterSegmented = document.getElementById('estimateMonthFilterSegmented');
            const versionFilterSegmented = document.getElementById('estimateVersionFilterSegmented');

            if (filterType === 'month') {
                // 月別フィルタを表示
                if (monthFilterCompact) monthFilterCompact.style.display = 'flex';
                if (versionFilterCompact) versionFilterCompact.style.display = 'none';
                if (monthFilterSegmented) monthFilterSegmented.style.display = 'flex';
                if (versionFilterSegmented) versionFilterSegmented.style.display = 'none';

                // 月別フィルタに切り替えた時、デフォルト月が選択されていない場合は設定
                const estimateMonthEl = document.getElementById('estimateMonthFilter');
                if (estimateMonthEl && !estimateMonthEl.value) {
                    setDefaultEstimateMonth();
                }
            } else {
                // 版数別フィルタを表示
                if (monthFilterCompact) monthFilterCompact.style.display = 'none';
                if (versionFilterCompact) versionFilterCompact.style.display = 'flex';
                if (monthFilterSegmented) monthFilterSegmented.style.display = 'none';
                if (versionFilterSegmented) versionFilterSegmented.style.display = 'flex';

                // 版数別フィルタに切り替えた時、デフォルト版数が選択されていない場合は最新版数を設定
                const estimateVersionEl = document.getElementById('estimateVersionFilter');
                if (estimateVersionEl && (!estimateVersionEl.value || estimateVersionEl.value === 'all')) {
                    const options = estimateVersionEl.options;
                    if (options.length > 1) {
                        // 'all'以外の最初の版数を選択（最新版数）
                        estimateVersionEl.value = options[1].value;
                        // セグメントボタンも更新
                        const estimateVersion2El = document.getElementById('estimateVersionFilter2');
                        if (estimateVersion2El) estimateVersion2El.value = options[1].value;
                        updateSegmentButtonSelection('estimateVersionButtons2', options[1].value);
                    }
                }
            }

            // レポートのフィルタタイプも同期
            syncFilterTypeToReport(filterType);

            // 選択値も同期
            if (filterType === 'month') {
                const estimateMonthEl = document.getElementById('estimateMonthFilter');
                if (estimateMonthEl && estimateMonthEl.value) {
                    syncMonthToReport(estimateMonthEl.value);
                }
            } else {
                const estimateVersionEl = document.getElementById('estimateVersionFilter');
                if (estimateVersionEl && estimateVersionEl.value) {
                    syncVersionToReport(estimateVersionEl.value);
                }
            }

            renderEstimateList();
        }

        function setEstimateFilterType(type) {
            document.getElementById('estimateFilterType').value = type;

            // セグメントボタンのスタイル更新（activeクラス使用）
            const btnMonth = document.getElementById('btnEstimateFilterMonth');
            const btnVersion = document.getElementById('btnEstimateFilterVersion');

            if (type === 'month') {
                btnMonth.classList.add('active');
                btnVersion.classList.remove('active');
            } else {
                btnMonth.classList.remove('active');
                btnVersion.classList.add('active');
            }

            handleEstimateFilterTypeChange();
        }

        function updateActualMonthOptions() {
            const select = document.getElementById('actualMonthFilter');
            const select2 = document.getElementById('actualMonthFilter2');

            // 現在の選択値を保存（再構築前に取得）
            const currentValue = select ? select.value : 'all';

            const months = new Set();

            // 実績データから月を抽出
            actuals.forEach(a => {
                if (a.date) {
                    const month = a.date.substring(0, 7); // YYYY-MM形式
                    months.add(month);
                }
            });

            // 月を降順でソート（最新が上）
            const sortedMonths = Array.from(months).sort().reverse();

            // 選択肢を生成（両方のセレクトボックス）
            select.innerHTML = '<option value="all">全期間</option>';
            if (select2) select2.innerHTML = '<option value="all">全期間</option>';

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const option = document.createElement('option');
                option.value = month;
                option.textContent = `${year}年${parseInt(monthNum)}月`;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = month;
                    option2.textContent = `${year}年${parseInt(monthNum)}月`;
                    select2.appendChild(option2);
                }
            });

            // 保存していた選択値を復元（オプションに存在する場合のみ）
            const validValue = sortedMonths.includes(currentValue) || currentValue === 'all' ? currentValue : 'all';
            select.value = validValue;
            if (select2) select2.value = validValue;

            // セグメントボタン版を生成（実績一覧セグメントレイアウト用）
            // セグメントボタンは昇順で表示（古い→新しい）
            const items = [
                { value: 'all', label: '全期間' },
                ...sortedMonths.slice().reverse().map(month => {
                    const [year, monthNum] = month.split('-');
                    return {
                        value: month,
                        label: `${year}/${parseInt(monthNum)}`
                    };
                })
            ];
            createSegmentButtons(
                'actualMonthButtons2',
                'actualMonthFilter2',
                items,
                validValue,
                8, // 最大8個までセグメントボタン表示
                handleActualMonthChange
            );
        }

        // 最新の登録月を取得する汎用関数
        function getDefaultMonth(selectElement) {
            // selectElementのオプションを確認
            const options = Array.from(selectElement.options);

            // 'all'以外のオプションを取得
            const monthOptions = options.filter(opt => opt.value !== 'all');

            if (monthOptions.length > 0) {
                // 月の値を比較して最新月（最も大きい値）を返す
                // ソート順に依存せず、実際の最新月を取得
                const latestMonth = monthOptions.reduce((latest, opt) => {
                    return opt.value > latest ? opt.value : latest;
                }, monthOptions[0].value);
                return latestMonth;
            }

            return 'all'; // デフォルトは全期間
        }

        function setDefaultActualMonth() {
            const select = document.getElementById('actualMonthFilter');
            if (!select) return;

            const select2 = document.getElementById('actualMonthFilter2');

            const defaultMonth = getDefaultMonth(select);
            select.value = defaultMonth;
            if (select2) select2.value = defaultMonth;

            // セグメントボタンの選択状態を更新
            updateSegmentButtonSelection('actualMonthButtons2', defaultMonth);
        }

        function setDefaultReportMonth() {
            const select = document.getElementById('reportMonth');
            if (!select) return;

            const select2 = document.getElementById('reportMonth2');

            const defaultMonth = getDefaultMonth(select);
            select.value = defaultMonth;
            if (select2) select2.value = defaultMonth;

            // セグメントボタンの選択状態を更新
            updateSegmentButtonSelection('reportMonthButtons2', defaultMonth);
        }

        function setDefaultEstimateMonth() {
            const select = document.getElementById('estimateMonthFilter');
            if (!select) return;

            const defaultMonth = getDefaultMonth(select);
            select.value = defaultMonth;
        }

        function autoBackup() {
            // 現在の設定を取得
            const settings = {
                themeColor: currentThemeColor,
                themePattern: currentThemePattern,
                themeTabColor: currentTabColor,
                themeBackgroundColor: currentBackgroundColor,
                estimateLayout: estimateLayout,
                actualLayout: actualLayout,
                reportLayout: reportLayout,
                showMonthColors: showMonthColorsSetting,
                showDeviationColors: showDeviationColorsSetting,
                showProgressBars: showProgressBarsSetting,
                showProgressPercentage: showProgressPercentageSetting,
                progressBarStyle: progressBarStyle,
                matrixEstActFormat: matrixEstActFormat,
                matrixDayMonthFormat: matrixDayMonthFormat,
                defaultEstimateViewType: document.getElementById('defaultEstimateViewType') ? document.getElementById('defaultEstimateViewType').value : 'grouped',
                defaultReportViewType: document.getElementById('defaultReportViewType') ? document.getElementById('defaultReportViewType').value : 'grouped',
                chartColorScheme: selectedChartColorScheme,
                memberOrder: document.getElementById('memberOrder').value.trim(),
                stickyFilterEnabled: localStorage.getItem('stickyFilterEnabled') !== 'false',
                floatingFilterEnabled: localStorage.getItem('floatingFilterEnabled') !== 'false',
                debugModeEnabled: debugModeEnabled
            };

            const data = {
                estimates: estimates,
                actuals: actuals,
                companyHolidays: companyHolidays,
                vacations: vacations,
                remainingEstimates: remainingEstimates,
                settings: settings,
                timestamp: new Date().toISOString(),
                version: '1.0'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            // ローカルタイムでファイル名を生成
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            const timestamp = `${year}-${month}-${day}_${hour}-${minute}-${second}`;
            
            a.href = url;
            a.download = `工数管理_バックアップ_${timestamp}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // タブの順序を定義
        const TAB_ORDER = ['quick', 'estimate', 'actual', 'report', 'settings'];

        function showTab(tabName) {
            // 全タブからactiveクラスとテーマクラスを削除
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.remove('active');
                // テーマクラスを削除
                const classes = Array.from(t.classList);
                classes.forEach(cls => {
                    if (cls.startsWith('theme-') || cls.startsWith('pattern-') || cls.startsWith('tab-theme-')) {
                        t.classList.remove(cls);
                    }
                });
            });
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

            // 対象のタブボタンを見つけてactiveクラスを追加
            const tabButtons = document.querySelectorAll('.tab');
            const tabIndex = TAB_ORDER.indexOf(tabName);
            if (tabIndex !== -1 && tabButtons[tabIndex]) {
                tabButtons[tabIndex].classList.add('active');
            }

            // タブコンテンツを表示
            const tabContent = document.getElementById(tabName);
            if (tabContent) {
                tabContent.classList.add('active');
            }

            // アクティブタブにテーマを適用
            updateThemeElements();

            // 見積一覧タブまたはレポートタブの場合、デフォルト表示形式を適用
            if (tabName === 'estimate') {
                applyDefaultEstimateViewType();
            } else if (tabName === 'report') {
                applyDefaultReportViewType();
                // レポートタブを開いた時は常にupdateReport()を呼び出してグラフを更新
                updateReport();
                // フローティングフィルタボタンを表示
                showFloatingFilterButton();
                // フローティングパネルの状態を同期
                syncFloatingFilters();
            } else {
                // レポートタブ以外ではフローティングフィルタボタンを非表示
                hideFloatingFilterButton();
            }
        }

        // 次のタブに切り替え
        function nextTab() {
            const currentIndex = TAB_ORDER.findIndex(tab =>
                document.getElementById(tab).classList.contains('active')
            );
            if (currentIndex !== -1 && currentIndex < TAB_ORDER.length - 1) {
                showTab(TAB_ORDER[currentIndex + 1]);
            }
        }

        // 前のタブに切り替え
        function prevTab() {
            const currentIndex = TAB_ORDER.findIndex(tab =>
                document.getElementById(tab).classList.contains('active')
            );
            if (currentIndex > 0) {
                showTab(TAB_ORDER[currentIndex - 1]);
            }
        }

        function addEstimate() {
            const version = document.getElementById('estVersion').value;
            const task = document.getElementById('estTask').value;
            
            if (!version || !task) {
                alert('版数と対応名を入力してください');
                return;
            }

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const monthSplitEnabled = document.getElementById('enableMonthSplit').checked;
            
            if (monthSplitEnabled) {
                // どの工程を分割するかチェック
                const splitProcesses = [];
                processes.forEach(proc => {
                    if (document.getElementById(`split${proc}`).checked) {
                        splitProcesses.push(proc);
                    }
                });
                
                if (splitProcesses.length === 0) {
                    alert('分割する工程を選択してください');
                    return;
                }
                
                // 月分割モード
                addEstimateWithMonthSplit(version, task, processes, splitProcesses);
            } else {
                // 通常モード
                processes.forEach(proc => {
                    const hours = parseFloat(document.getElementById(`est${proc}`).value);
                    const member = document.getElementById(`est${proc}_member`).value;

                    if (hours > 0 && member) {
                        estimates.push({
                            id: Date.now() + Math.random(),
                            version: version,
                            task: task,
                            process: proc,
                            member: member,
                            hours: hours,
                            workMonth: '',
                            workMonths: [],
                            monthlyHours: {},
                            createdAt: new Date().toISOString()
                        });

                        // 見込残存時間も自動設定（見積時間と同じ）
                        saveRemainingEstimate(version, task, proc, member, hours);
                    }
                });
            }

            saveData();
            clearEstimateForm();
            updateMemberOptions();
            renderEstimateList();
            updateQuickTaskList();
            updateReport();
            showAlert('見積を登録しました', true);
        }

        function addEstimateWithMonthSplit(version, task, processes, splitProcesses) {
            const totalHours = parseFloat(document.getElementById('totalHours').value) || 0;
            const startMonth = document.getElementById('startMonth').value;
            const endMonth = document.getElementById('endMonth').value;
            const method = document.querySelector('input[name="splitMethod"]:checked').value;
            
            if (totalHours <= 0 || !startMonth || !endMonth) {
                alert('総工数と作業期間を入力してください');
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            
            // 月別工数を計算
            const monthlyHours = {};
            
            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                // 手動設定の場合
                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`monthHours_${index}`);
                    const hours = input ? parseFloat(input.value) || 0 : 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });
                
                // 合計チェック
                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計(${total.toFixed(1)}h)が総工数(${totalHours}h)と一致しません`);
                    return;
                }
            }
            
            // 工程ごとに見積を作成
            processes.forEach(proc => {
                const member = document.getElementById(`est${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`est${proc}`).value);

                if (!member) return;

                // この工程が分割対象かチェック
                if (splitProcesses.includes(proc)) {
                    // 月分割見積を作成
                    estimates.push({
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: totalHours,
                        workMonth: startMonth,
                        workMonths: months,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    });

                    // 見込残存時間も自動設定（総工数と同じ）
                    saveRemainingEstimate(version, task, proc, member, totalHours);
                } else {
                    // 通常の見積を作成（工数入力があれば）
                    if (hours > 0) {
                        estimates.push({
                            id: Date.now() + Math.random(),
                            version: version,
                            task: task,
                            process: proc,
                            member: member,
                            hours: hours,
                            workMonth: '',
                            workMonths: [],
                            monthlyHours: {},
                            createdAt: new Date().toISOString()
                        });

                        // 見込残存時間も自動設定（見積時間と同じ）
                        saveRemainingEstimate(version, task, proc, member, hours);
                    }
                }
            });
        }

        function toggleMonthSplit() {
            const enabled = document.getElementById('enableMonthSplit').checked;
            const panel = document.getElementById('monthSplitPanel');
            
            if (enabled) {
                panel.style.display = 'block';
                
                // 月選択肢を初期化
                const now = new Date();
                const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                generateMonthOptions('startMonth', currentMonth);
                generateMonthOptions('endMonth', currentMonth);
                
                // 通常の工数入力は有効のまま（分割しない工程用）
                
                updateMonthPreview();
            } else {
                panel.style.display = 'none';
            }
        }

        function updateMonthPreview() {
            const totalHours = parseFloat(document.getElementById('totalHours').value) || 0;
            const startMonth = document.getElementById('startMonth').value;
            const endMonth = document.getElementById('endMonth').value;
            const method = document.querySelector('input[name="splitMethod"]:checked').value;
            const preview = document.getElementById('monthPreview');
            
            if (!startMonth || !endMonth || totalHours <= 0) {
                preview.innerHTML = '<p style="color: #999; font-size: 14px;">総工数と作業期間を入力してください</p>';
                return;
            }
            
            if (startMonth > endMonth) {
                preview.innerHTML = '<p style="color: #e74c3c; font-size: 14px;">⚠️ 開始月は終了月より前にしてください</p>';
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            let html = '<div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #2196f3;">';
            html += '<strong style="color: #1976d2;">📋 プレビュー</strong><br>';
            html += '<div style="margin-top: 10px;">';
            
            if (method === 'equal') {
                const hoursPerMonth = (totalHours / months.length).toFixed(1);
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; border-bottom: 1px solid #eee;">`;
                    html += `${y}年${parseInt(m)}月: <strong>${hoursPerMonth}h</strong>`;
                    html += `</div>`;
                });
                html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #2196f3; font-weight: 600;">`;
                html += `合計: ${totalHours}h (${months.length}ヶ月)`;
                html += `</div>`;
            } else {
                // 手動設定UI
                let manualTotal = 0;
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; display: flex; align-items: center; gap: 10px;">`;
                    html += `<label style="flex: 1;">${y}年${parseInt(m)}月:</label>`;
                    html += `<input type="number" id="monthHours_${index}" value="0" step="0.1" min="0" `;
                    html += `onchange="updateManualTotal()" style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"> h`;
                    html += `</div>`;
                });
                html += `<div id="manualTotal" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #2196f3; font-weight: 600;">`;
                html += `合計: 0h / 目標: ${totalHours}h`;
                html += `</div>`;
            }
            
            html += '</div></div>';
            preview.innerHTML = html;
        }

        function updateManualTotal() {
            const totalHours = parseFloat(document.getElementById('totalHours').value) || 0;
            const startMonth = document.getElementById('startMonth').value;
            const endMonth = document.getElementById('endMonth').value;
            
            if (!startMonth || !endMonth) return;
            
            const months = generateMonthRange(startMonth, endMonth);
            let total = 0;
            
            months.forEach((month, index) => {
                const input = document.getElementById(`monthHours_${index}`);
                if (input) {
                    total += parseFloat(input.value) || 0;
                }
            });
            
            const manualTotalDiv = document.getElementById('manualTotal');
            if (manualTotalDiv) {
                const diff = total - totalHours;
                const color = Math.abs(diff) < 0.01 ? '#27ae60' : (diff > 0 ? '#e74c3c' : '#f39c12');
                manualTotalDiv.innerHTML = `合計: <span style="color: ${color};">${total.toFixed(1)}h</span> / 目標: ${totalHours}h`;
                
                if (Math.abs(diff) < 0.01) {
                    manualTotalDiv.innerHTML += ' <span style="color: #27ae60;">✓</span>';
                } else if (diff > 0) {
                    manualTotalDiv.innerHTML += ` <span style="color: #e74c3c;">(+${diff.toFixed(1)}h 超過)</span>`;
                } else {
                    manualTotalDiv.innerHTML += ` <span style="color: #f39c12;">(${diff.toFixed(1)}h 不足)</span>`;
                }
            }
        }

        // 既存見積の月分割機能
        function openSplitEstimateModal(id) {
            const estimate = estimates.find(e => e.id === id);
            if (!estimate) {
                alert('データが見つかりません');
                return;
            }

            const est = normalizeEstimate(estimate);

            // モーダルに情報を設定
            document.getElementById('splitEstimateId').value = id;
            document.getElementById('splitEstimateInfo').innerHTML = `
                <strong>${est.version}</strong> - ${est.task} [${est.process}] (${est.member})<br>
                現在の工数: ${est.hours.toFixed(1)}h
            `;
            document.getElementById('splitTotalHours').value = est.hours;

            // 既存の月別工数データがある場合は先に手動設定モードに切り替え（onchangeイベントが発火する前に）
            if (est.monthlyHours && Object.keys(est.monthlyHours).length > 0) {
                document.querySelector('input[name="splitMethodModal"][value="manual"]').checked = true;
            } else {
                document.querySelector('input[name="splitMethodModal"][value="equal"]').checked = true;
            }

            // 月選択肢を初期化
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

            // 既存の作業月がある場合はそれを使用
            let defaultStart = currentMonth;
            let defaultEnd = currentMonth;

            if (est.workMonths.length > 0) {
                defaultStart = est.workMonths[0];
                defaultEnd = est.workMonths[est.workMonths.length - 1];
            }

            generateMonthOptions('splitStartMonth', defaultStart);
            generateMonthOptions('splitEndMonth', defaultEnd);

            updateSplitPreview();

            // モーダルを表示
            document.getElementById('splitEstimateModal').style.display = 'flex';
        }

        function closeSplitEstimateModal() {
            document.getElementById('splitEstimateModal').style.display = 'none';
        }

        function updateSplitPreview() {
            const totalHours = parseFloat(document.getElementById('splitTotalHours').value) || 0;
            const startMonth = document.getElementById('splitStartMonth').value;
            const endMonth = document.getElementById('splitEndMonth').value;
            const method = document.querySelector('input[name="splitMethodModal"]:checked').value;
            const preview = document.getElementById('splitPreview');

            if (!startMonth || !endMonth || totalHours <= 0) {
                preview.innerHTML = '<p style="color: #999; font-size: 14px;">作業期間を選択してください</p>';
                return;
            }

            if (startMonth > endMonth) {
                preview.innerHTML = '<p style="color: #e74c3c; font-size: 14px;">⚠️ 開始月は終了月より前にしてください</p>';
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);

            // 既存の月別工数データを取得（編集中の場合）
            const estimateId = parseFloat(document.getElementById('splitEstimateId').value);
            const currentEstimate = estimates.find(e => e.id === estimateId);
            const normalizedEstimate = normalizeEstimate(currentEstimate);
            const currentMonthlyHours = normalizedEstimate && normalizedEstimate.monthlyHours ? normalizedEstimate.monthlyHours : {};

            let html = '<div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #3498db;">';
            html += '<strong style="color: #2c3e50;">📋 分割プレビュー</strong><br>';
            html += '<div style="margin-top: 10px;">';

            if (method === 'equal') {
                const hoursPerMonth = (totalHours / months.length).toFixed(1);
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; border-bottom: 1px solid #eee;">`;
                    html += `${y}年${parseInt(m)}月: <strong>${hoursPerMonth}h</strong>`;
                    html += `</div>`;
                });
                html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #3498db; font-weight: 600;">`;
                html += `合計: ${totalHours}h (${months.length}ヶ月)`;
                html += `</div>`;
            } else {
                // 手動設定UI
                let calculatedTotal = 0;
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    // 既存データがあればそれを初期値に、なければ0
                    const existingHours = currentMonthlyHours[month] !== undefined ? currentMonthlyHours[month] : 0;
                    calculatedTotal += existingHours;
                    html += `<div style="padding: 5px 0; display: flex; align-items: center; gap: 10px;">`;
                    html += `<label style="flex: 1;">${y}年${parseInt(m)}月:</label>`;
                    html += `<input type="number" id="splitMonthHours_${index}" value="${existingHours}" step="0.1" min="0" `;
                    html += `onchange="updateSplitManualTotal()" style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"> h`;
                    html += `</div>`;
                });
                html += `<div id="splitManualTotal" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #3498db; font-weight: 600;">`;
                const isMatch = Math.abs(calculatedTotal - totalHours) < 0.01;
                const color = isMatch ? '#27ae60' : '#e74c3c';
                html += `合計: <span style="color: ${color};">${calculatedTotal.toFixed(1)}h</span> / 目標: ${totalHours}h`;
                if (Math.abs(calculatedTotal - totalHours) >= 0.01) {
                    const diff = calculatedTotal - totalHours;
                    if (diff > 0) {
                        html += ` <span style="color: #e74c3c;">(+${diff.toFixed(1)}h 超過)</span>`;
                    } else {
                        html += ` <span style="color: #f39c12;">(${diff.toFixed(1)}h 不足)</span>`;
                    }
                } else {
                    html += ' <span style="color: #27ae60;">✓</span>';
                }
                html += `</div>`;
            }

            html += '</div></div>';
            preview.innerHTML = html;
        }

        function updateSplitManualTotal() {
            const totalHours = parseFloat(document.getElementById('splitTotalHours').value) || 0;
            const startMonth = document.getElementById('splitStartMonth').value;
            const endMonth = document.getElementById('splitEndMonth').value;
            
            if (!startMonth || !endMonth) return;
            
            const months = generateMonthRange(startMonth, endMonth);
            let total = 0;
            
            months.forEach((month, index) => {
                const input = document.getElementById(`splitMonthHours_${index}`);
                if (input) {
                    total += parseFloat(input.value) || 0;
                }
            });
            
            const manualTotalDiv = document.getElementById('splitManualTotal');
            if (manualTotalDiv) {
                const diff = total - totalHours;
                const color = Math.abs(diff) < 0.01 ? '#27ae60' : (diff > 0 ? '#e74c3c' : '#f39c12');
                manualTotalDiv.innerHTML = `合計: <span style="color: ${color};">${total.toFixed(1)}h</span> / 目標: ${totalHours}h`;
                
                if (Math.abs(diff) < 0.01) {
                    manualTotalDiv.innerHTML += ' <span style="color: #27ae60;">✓</span>';
                } else if (diff > 0) {
                    manualTotalDiv.innerHTML += ` <span style="color: #e74c3c;">(+${diff.toFixed(1)}h 超過)</span>`;
                } else {
                    manualTotalDiv.innerHTML += ` <span style="color: #f39c12;">(${diff.toFixed(1)}h 不足)</span>`;
                }
            }
        }

        function executeSplitEstimate() {
            const id = parseFloat(document.getElementById('splitEstimateId').value);
            const totalHours = parseFloat(document.getElementById('splitTotalHours').value) || 0;
            const startMonth = document.getElementById('splitStartMonth').value;
            const endMonth = document.getElementById('splitEndMonth').value;
            const method = document.querySelector('input[name="splitMethodModal"]:checked').value;
            
            if (!startMonth || !endMonth || totalHours <= 0) {
                alert('作業期間を正しく設定してください');
                return;
            }
            
            if (startMonth > endMonth) {
                alert('開始月は終了月より前にしてください');
                return;
            }
            
            const months = generateMonthRange(startMonth, endMonth);
            const monthlyHours = {};
            
            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                // 手動設定の場合
                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`splitMonthHours_${index}`);
                    const hours = input ? parseFloat(input.value) || 0 : 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });
                
                // 合計チェック
                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計(${total.toFixed(1)}h)が総工数(${totalHours}h)と一致しません`);
                    return;
                }
            }
            
            // 見積を更新
            const estimateIndex = estimates.findIndex(e => e.id === id);
            if (estimateIndex !== -1) {
                estimates[estimateIndex] = {
                    ...estimates[estimateIndex],
                    workMonth: startMonth,
                    workMonths: months,
                    monthlyHours: monthlyHours
                };
                
                saveData();
                closeSplitEstimateModal();
                renderEstimateList();
                updateReport();
                
                showAlert('見積を月別に分割しました', true);
            } else {
                showAlert('データの更新に失敗しました', false);
            }
        }

        function clearEstimateForm() {
            document.getElementById('estVersion').value = '';
            document.getElementById('estTask').value = '';
            ['UI', 'PG', 'PT', 'IT', 'ST'].forEach(proc => {
                document.getElementById(`est${proc}`).value = '';
                document.getElementById(`est${proc}_member`).value = '';
                // 工程チェックボックスもクリア
                const checkbox = document.getElementById(`split${proc}`);
                if (checkbox) {
                    checkbox.checked = false;
                }
            });
            
            // 月分割アシスタントをクリア
            document.getElementById('enableMonthSplit').checked = false;
            toggleMonthSplit();
        }

        // クイック入力用の変数
        let allQuickTasks = [];
        let selectedQuickTask = null;
        let selectedMemberFilter = null; // 担当者フィルタ
        let quickInputMode = 'actual'; // 'actual' or 'estimate'
        let rememberQuickInputMode = false; // 前回モードを記憶するかどうか

        // 作業月割り当て用の変数
        let workMonthSelectionMode = false;
        let selectedEstimateIds = new Set(); // 選択された見積IDのセット

        // 編集モード用の変数
        let estimateEditMode = false;

        // 月分割モード用の変数
        let monthSplitEnabled = false;

        // 月別カラーマップ（季節のイメージに合わせた色）
        const monthColors = {
            '01': { bg: 'rgba(200, 220, 240, 0.25)', rgb: '200, 220, 240', name: '1月', label: '1月' },   // 雪・冬空
            '02': { bg: 'rgba(180, 140, 180, 0.20)', rgb: '180, 140, 180', name: '2月', label: '2月' },   // 梅
            '03': { bg: 'rgba(255, 180, 200, 0.20)', rgb: '255, 180, 200', name: '3月', label: '3月' },   // 桃・早咲き桜
            '04': { bg: 'rgba(255, 200, 210, 0.20)', rgb: '255, 200, 210', name: '4月', label: '4月' },   // 桜
            '05': { bg: 'rgba(120, 200, 120, 0.20)', rgb: '120, 200, 120', name: '5月', label: '5月' },   // 新緑
            '06': { bg: 'rgba(130, 160, 210, 0.20)', rgb: '130, 160, 210', name: '6月', label: '6月' },   // 紫陽花・梅雨
            '07': { bg: 'rgba(100, 180, 220, 0.20)', rgb: '100, 180, 220', name: '7月', label: '7月' },   // 海・空
            '08': { bg: 'rgba(255, 180, 80, 0.20)', rgb: '255, 180, 80', name: '8月', label: '8月' },     // 向日葵・太陽
            '09': { bg: 'rgba(210, 160, 130, 0.20)', rgb: '210, 160, 130', name: '9月', label: '9月' },   // 秋の始まり
            '10': { bg: 'rgba(230, 120, 80, 0.20)', rgb: '230, 120, 80', name: '10月', label: '10月' },   // 紅葉
            '11': { bg: 'rgba(180, 120, 80, 0.20)', rgb: '180, 120, 80', name: '11月', label: '11月' },   // 枯葉
            '12': { bg: 'rgba(160, 180, 210, 0.22)', rgb: '160, 180, 210', name: '12月', label: '12月' }  // 冬・クリスマス
        };

        // 月別色付け設定
        let showMonthColorsSetting = true;
        let showDeviationColorsSetting = true; // 乖離率背景色の表示設定
        let showProgressBarsSetting = true; // 進捗バー表示設定
        let showProgressPercentageSetting = true; // 進捗バーのパーセンテージ表示設定
        let progressBarStyle = 'inline'; // 進捗バーのスタイル: inline, bottom
        let matrixEstActFormat = 'twoRows'; // 見積と実績の表示形式: twoRows, slash
        let matrixDayMonthFormat = 'inline'; // 人日/人月の表示形式: inline, separate, side, arrow
        let debugModeEnabled = false; // デバッグモード設定

        // 月別色付け設定のトグル
        function toggleMonthColorsSetting() {
            showMonthColorsSetting = document.getElementById('showMonthColorsCheckbox').checked;
            saveData(true);
            renderEstimates();
            updateReport();
        }

        // 乖離率背景色設定のトグル
        function toggleDeviationColorsSetting() {
            showDeviationColorsSetting = document.getElementById('showDeviationColorsCheckbox').checked;
            saveData(true);
            updateReport();
        }

        // 進捗バー表示設定のトグル
        function toggleProgressBarsSetting() {
            showProgressBarsSetting = document.getElementById('showProgressBarsCheckbox').checked;
            saveData(true);
            updateReport();
        }

        // 進捗バーのパーセンテージ表示設定のトグル
        function toggleProgressPercentageSetting() {
            showProgressPercentageSetting = document.getElementById('showProgressPercentageCheckbox').checked;
            saveData(true);
            updateReport();
        }

        // 進捗バーのスタイル保存
        function saveProgressBarStyle() {
            const selectedStyle = document.querySelector('input[name="progressBarStyle"]:checked');
            if (selectedStyle) {
                progressBarStyle = selectedStyle.value;
                saveData(true);
                updateReport();
            }
        }

        // 見積と実績の表示形式の保存
        function saveMatrixEstActFormat() {
            const selectedFormat = document.querySelector('input[name="matrixEstActFormat"]:checked');
            if (selectedFormat) {
                matrixEstActFormat = selectedFormat.value;
                saveData(true);
                updateReport();
            }
        }

        // デフォルト表示形式設定の保存
        function saveDefaultViewTypeSetting() {
            saveData(true);
        }

        // 人日/人月表示形式の保存
        function saveMatrixDayMonthFormat() {
            const selectedFormat = document.querySelector('input[name="matrixDayMonthFormat"]:checked');
            if (selectedFormat) {
                matrixDayMonthFormat = selectedFormat.value;
                saveData(true);
                updateReport();
            }
        }

        // グラフカラースキームの保存
        function saveChartColorScheme() {
            const selector = document.getElementById('chartColorScheme');
            if (selector) {
                selectedChartColorScheme = selector.value;
                saveData(true);
                updateChartColorPreview();
                // レポートが表示されている場合、グラフを再描画
                if (document.getElementById('report').style.display !== 'none') {
                    updateReport();
                }
            }
        }

        // グラフカラープレビューの更新
        function updateChartColorPreview() {
            const scheme = getActiveChartColorScheme();
            if (!scheme) return;

            // 棒グラフプレビュー
            const estimateBar = document.getElementById('chartPreviewEstimateBar');
            const actualBar = document.getElementById('chartPreviewActualBar');
            if (estimateBar) estimateBar.style.backgroundColor = scheme.barColors.estimate;
            if (actualBar) actualBar.style.backgroundColor = scheme.barColors.actual;

            // ドーナツグラフプレビュー
            const uiPreview = document.getElementById('chartPreviewUI');
            const pgPreview = document.getElementById('chartPreviewPG');
            const ptPreview = document.getElementById('chartPreviewPT');
            const itPreview = document.getElementById('chartPreviewIT');
            const stPreview = document.getElementById('chartPreviewST');

            if (uiPreview) uiPreview.style.backgroundColor = scheme.processColors['UI'];
            if (pgPreview) pgPreview.style.backgroundColor = scheme.processColors['PG'];
            if (ptPreview) ptPreview.style.backgroundColor = scheme.processColors['PT'];
            if (itPreview) itPreview.style.backgroundColor = scheme.processColors['IT'];
            if (stPreview) stPreview.style.backgroundColor = scheme.processColors['ST'];
        }

        // グラフカラースキームの読み込み
        function loadChartColorScheme() {
            const savedSettings = localStorage.getItem('manhour_settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.chartColorScheme) {
                    selectedChartColorScheme = settings.chartColorScheme;
                    const selector = document.getElementById('chartColorScheme');
                    if (selector) {
                        selector.value = selectedChartColorScheme;
                    }
                }
            }
            updateChartColorPreview();
        }

        // 見積一覧タブのデフォルト表示形式を適用
        function applyDefaultEstimateViewType() {
            if (!isEstimateTabFirstView) {
                return; // 初回表示以外は何もしない
            }
            isEstimateTabFirstView = false;

            const savedSettings = localStorage.getItem('manhour_settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                const defaultViewType = settings.defaultEstimateViewType || 'grouped';
                const estimateViewTypeElement = document.getElementById('estimateViewType');
                if (estimateViewTypeElement && estimateViewTypeElement.value !== defaultViewType) {
                    estimateViewTypeElement.value = defaultViewType;
                    // セグメントボタンの状態も更新
                    setEstimateViewType(defaultViewType);
                }
            }
        }

        // レポートタブのデフォルト表示形式を適用
        function applyDefaultReportViewType() {
            if (!isReportTabFirstView) {
                return; // 初回表示以外は何もしない
            }
            isReportTabFirstView = false;

            const savedSettings = localStorage.getItem('manhour_settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                const defaultViewType = settings.defaultReportViewType || 'grouped';
                const reportViewTypeElement = document.getElementById('reportViewType');
                if (reportViewTypeElement && reportViewTypeElement.value !== defaultViewType) {
                    reportViewTypeElement.value = defaultViewType;
                    // セグメントボタンの状態も更新
                    setReportViewType(defaultViewType);
                }
            }
        }

        // 月から背景色を取得
        function getMonthColor(workMonths) {
            if (!workMonths || workMonths.length === 0) {
                return { bg: 'rgba(150, 150, 150, 0.15)', tooltip: '未設定', isMultiple: false };
            }

            if (workMonths.length === 1) {
                const month = workMonths[0].split('-')[1];
                const [year, m] = workMonths[0].split('-');
                const color = monthColors[month] || { bg: 'rgba(200, 200, 200, 0.3)', name: month + '月' };
                return {
                    bg: color.bg,
                    tooltip: `${year}年${parseInt(m)}月`,
                    isMultiple: false
                };
            }

            // 複数月の場合 - 逆斜線ストライプで開始月と終了月の色を使用
            const firstMonth = workMonths[0].split('-')[1];
            const lastMonth = workMonths[workMonths.length - 1].split('-')[1];
            const [y1, m1] = workMonths[0].split('-');
            const [y2, m2] = workMonths[workMonths.length - 1].split('-');

            const color1 = monthColors[firstMonth]?.rgb || '150, 150, 150';
            const color2 = monthColors[lastMonth]?.rgb || '150, 150, 150';

            return {
                bg: `repeating-linear-gradient(-45deg, rgba(${color1}, 0.20) 0px, rgba(${color1}, 0.20) 6px, rgba(${color2}, 0.20) 6px, rgba(${color2}, 0.20) 12px)`,
                tooltip: `${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月`,
                isMultiple: true
            };
        }

        // 月カラー凡例を生成
        function generateMonthColorLegend(usedMonths, hasMultipleMonths = false, hasUnassigned = false) {
            if (!usedMonths || usedMonths.size === 0) return '';

            let html = '<div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 6px; font-size: 12px;">';
            html += '<span style="font-weight: 600; color: #666; margin-right: 5px;">月別:</span>';

            // 使用されている月のみ表示（ソートして）
            const sortedMonths = Array.from(usedMonths).sort();
            sortedMonths.forEach(monthKey => {
                const [year, month] = monthKey.split('-');
                const color = monthColors[month];
                if (color) {
                    html += `<span style="display: inline-flex; align-items: center; gap: 4px;">
                        <span style="width: 16px; height: 16px; background: ${color.bg}; border: 1px solid rgba(0,0,0,0.1); border-radius: 3px;"></span>
                        <span style="color: #555;">${year}/${parseInt(month)}</span>
                    </span>`;
                }
            });

            // 複数月の凡例（表示中のデータに存在する場合のみ）
            if (hasMultipleMonths) {
                html += `<span style="display: inline-flex; align-items: center; gap: 4px; margin-left: 10px;">
                    <span style="width: 16px; height: 16px; background: repeating-linear-gradient(-45deg, rgba(70, 130, 200, 0.35) 0px, rgba(70, 130, 200, 0.35) 3px, rgba(50, 180, 140, 0.35) 3px, rgba(50, 180, 140, 0.35) 6px); border: 1px solid rgba(0,0,0,0.1); border-radius: 3px;"></span>
                    <span style="color: #666;">複数月</span>
                </span>`;
            }

            // 未設定の凡例（表示中のデータに存在する場合のみ）
            if (hasUnassigned) {
                html += `<span style="display: inline-flex; align-items: center; gap: 4px; margin-left: 5px;">
                    <span style="width: 16px; height: 16px; background: rgba(150, 150, 150, 0.15); border: 1px solid rgba(0,0,0,0.1); border-radius: 3px;"></span>
                    <span style="color: #999;">未設定</span>
                </span>`;
            }

            html += '</div>';
            return html;
        }

        // 見積データの正規化（旧形式→新形式）
        function normalizeEstimate(e) {
            // 新形式がすでにある場合
            if (e.workMonths && e.monthlyHours) {
                return e;
            }
            
            // 旧形式（workMonthのみ）を新形式に変換
            if (e.workMonth && !e.workMonths) {
                return {
                    ...e,
                    workMonths: [e.workMonth],
                    monthlyHours: { [e.workMonth]: e.hours }
                };
            }
            
            // workMonthもworkMonthsもない場合（未設定）
            if (!e.workMonth && !e.workMonths) {
                return {
                    ...e,
                    workMonths: [],
                    monthlyHours: {}
                };
            }
            
            return e;
        }

        // 月の範囲を生成（YYYY-MM形式）
        function generateMonthRange(startMonth, endMonth) {
            const months = [];
            let current = startMonth;
            
            while (current <= endMonth) {
                months.push(current);
                const [y, m] = current.split('-').map(Number);
                const nextDate = new Date(y, m, 1); // 次の月の1日
                const nextYear = nextDate.getFullYear();
                const nextMonth = nextDate.getMonth() + 1;
                current = `${nextYear}-${String(nextMonth).padStart(2, '0')}`;
            }
            
            return months;
        }

        // 月選択肢を生成
        function generateMonthOptions(selectId, selectedValue = '', minValue = null) {
            const select = document.getElementById(selectId);
            if (!select) return;

            select.innerHTML = '';

            // 過去1年から未来2年まで
            const now = new Date();
            const startDate = new Date(now.getFullYear() - 1, 0, 1);
            const endDate = new Date(now.getFullYear() + 2, 11, 31);

            const months = [];
            let current = new Date(startDate);

            while (current <= endDate) {
                const year = current.getFullYear();
                const month = current.getMonth() + 1;
                const value = `${year}-${String(month).padStart(2, '0')}`;
                // minValueが指定されている場合、それより後の月のみを含める
                if (!minValue || value > minValue) {
                    months.push({ value, label: `${year}年${month}月` });
                }
                current.setMonth(current.getMonth() + 1);
            }

            months.forEach(m => {
                const option = document.createElement('option');
                option.value = m.value;
                option.textContent = m.label;
                if (m.value === selectedValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        function updateQuickTaskList() {
            // 見積データから一意のタスクを抽出（担当者情報も含む）
            const taskMap = new Map();
            estimates.forEach(e => {
                const key = `${e.version}|${e.task}|${e.process}|${e.member}`;
                if (!taskMap.has(key)) {
                    taskMap.set(key, {
                        version: e.version,
                        task: e.task,
                        process: e.process,
                        member: e.member,
                        display: `${e.version} - ${e.task} [${e.process}] (${e.member})`
                    });
                }
            });
            
            allQuickTasks = Array.from(taskMap.values());
            
            // 担当者セレクトボックスを更新
            updateQuickMemberSelect();
        }

        function updateQuickMemberSelect() {
            const select = document.getElementById('quickMemberSelect');
            const members = new Set();
            
            // 見積データから担当者を抽出
            estimates.forEach(e => members.add(e.member));
            
            // 表示順が設定されている場合はそれを使用
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = orderList.filter(m => members.has(m));
                const unorderedMembers = Array.from(members).filter(m => !orderedMembers.includes(m)).sort();
                sortedMembers = [...orderedMembers, ...unorderedMembers];
            } else {
                sortedMembers = Array.from(members).sort();
            }
            
            // オプションを生成
            const currentValue = select.value;
            select.innerHTML = '<option value="">（自動）</option>';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                select.appendChild(option);
            });
            
            // 前回選択していた値を復元
            if (currentValue && sortedMembers.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        function handleMemberChange() {
            const selectedMember = document.getElementById('quickMemberSelect').value;
            selectedMemberFilter = selectedMember || null;
            
            // 対応が既に選択されている場合
            if (selectedQuickTask) {
                // 何もしない（担当者変更として扱う）
                return;
            }
            
            // 対応が未選択の場合、ドロップダウンを更新
            const searchInput = document.getElementById('quickTaskSearch');
            if (searchInput.value) {
                filterQuickTaskList();
            }
        }

        function showQuickTaskDropdown() {
            filterQuickTaskList();
        }

        function hideQuickTaskDropdown() {
            document.getElementById('quickTaskDropdown').style.display = 'none';
        }

        function clearQuickTaskSelection() {
            document.getElementById('quickTaskSearch').value = '';
            document.getElementById('quickTaskClearBtn').style.display = 'none';
            selectedQuickTask = null;
            // 担当者もリセット
            document.getElementById('quickMemberSelect').value = '';
            selectedMemberFilter = null;
            // ドロップダウンを非表示
            hideQuickTaskDropdown();
        }

        function filterQuickTaskList() {
            const searchText = document.getElementById('quickTaskSearch').value.toLowerCase();
            const dropdown = document.getElementById('quickTaskDropdown');
            
            // 担当者フィルタが設定されている場合は絞り込む
            let filtered = allQuickTasks;
            if (selectedMemberFilter) {
                filtered = filtered.filter(taskInfo => taskInfo.member === selectedMemberFilter);
            }
            
            // 検索テキストで絞り込む
            if (searchText) {
                filtered = filtered.filter(taskInfo => 
                    taskInfo.display.toLowerCase().includes(searchText)
                );
            }
            
            if (filtered.length === 0) {
                const msg = selectedMemberFilter 
                    ? `${selectedMemberFilter}さんの対応が見つかりません` 
                    : '該当する対応が見つかりません';
                dropdown.innerHTML = `<div class="custom-dropdown-empty">${msg}</div>`;
            } else {
                dropdown.innerHTML = filtered.map(taskInfo => {
                    const value = `${taskInfo.version}|${taskInfo.task}|${taskInfo.process}|${taskInfo.member}`;
                    return `<div class="custom-dropdown-item" onmousedown="selectQuickTask('${value.replace(/'/g, "\\'")}', '${taskInfo.display.replace(/'/g, "\\'")}')">${taskInfo.display}</div>`;
                }).join('');
            }
            
            dropdown.style.display = 'block';
        }

        function selectQuickTask(value, display) {
            selectedQuickTask = value;
            const [version, task, process, member] = value.split('|');
            
            // 表示を更新
            document.getElementById('quickTaskSearch').value = `${version} - ${task} [${process}]`;
            
            // ×ボタンを表示
            document.getElementById('quickTaskClearBtn').style.display = 'block';
            
            // 担当者セレクトを更新
            const memberSelect = document.getElementById('quickMemberSelect');
            
            // 担当者フィルタが未設定の場合、見積の担当者を自動設定
            if (!selectedMemberFilter) {
                memberSelect.value = member;
            }
            // 担当者フィルタが設定されていて、見積の担当者と異なる場合は変更として扱う
            // （何もしない。ユーザーが選んだ担当者を維持）
            
            document.getElementById('quickTaskDropdown').style.display = 'none';
        }

        // 外部クリックでドロップダウンを閉じる
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('quickTaskDropdown');
            const searchInput = document.getElementById('quickTaskSearch');
            
            if (dropdown && searchInput) {
                // クリックされた要素がドロップダウンまたは検索入力欄でない場合
                if (!dropdown.contains(event.target) && event.target !== searchInput) {
                    hideQuickTaskDropdown();
                }
            }
        });

        function quickAddActual() {
            const hours = parseFloat(document.getElementById('quickHours').value);
            const memberOverride = document.getElementById('quickMemberSelect').value;
            
            if (!selectedQuickTask || !hours) {
                alert('対応と実績工数を入力してください');
                return;
            }

            const [version, task, process, originalMember] = selectedQuickTask.split('|');
            
            // 担当者の決定ロジック:
            // 1. ユーザーが明示的に選択した担当者があればそれを使用
            // 2. なければ見積の担当者を使用
            const finalMember = memberOverride || originalMember;

            actuals.push({
                id: Date.now(),
                date: new Date().toISOString().split('T')[0],
                version: version,
                task: task,
                process: process,
                member: finalMember,
                hours: hours,
                createdAt: new Date().toISOString()
            });

            saveData();

            // 次の入力のために、今追加した実績をデフォルト選択
            // selectedQuickTaskはそのまま保持（version|task|process|member）
            selectedQuickTask = `${version}|${task}|${process}|${finalMember}`;

            // 検索ボックスに表示
            const searchInput = document.getElementById('quickTaskSearch');
            searchInput.value = `${version} - ${task} [${process}]`;

            // 工数は8にリセット
            document.getElementById('quickHours').value = '8';

            // クリアボタンを表示
            document.getElementById('quickTaskClearBtn').style.display = 'inline-block';

            // 担当者選択はリセット（次の入力に備える）
            document.getElementById('quickMemberSelect').value = '';
            selectedMemberFilter = null;

            updateMonthOptions();
            updateActualMonthOptions();
            updateMemberOptions();
            renderTodayActuals();
            renderActualList();
            updateReport();
            showAlert('実績を追加しました', true);
        }

        function renderTodayActuals() {
            const today = new Date().toISOString().split('T')[0];
            const todayData = actuals.filter(a => a.date === today);
            
            const container = document.getElementById('todayActuals');
            
            if (todayData.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">まだ実績が入力されていません</p>';
                return;
            }

            let html = '<div class="table-wrapper"><table><tr><th>時刻</th><th>版数</th><th>対応名</th><th>工程</th><th>担当</th><th>工数</th><th>操作</th></tr>';

            todayData.forEach(a => {
                // createdAtが存在しない場合は「-」を表示
                let time = '-';
                if (a.createdAt) {
                    const date = new Date(a.createdAt);
                    if (!isNaN(date.getTime())) {
                        time = date.toLocaleTimeString('ja-JP');
                    }
                }
                html += `
                    <tr>
                        <td>${time}</td>
                        <td>${a.version}</td>
                        <td>${a.task}</td>
                        <td><span class="badge badge-${a.process.toLowerCase()}">${a.process}</span></td>
                        <td>${a.member}</td>
                        <td>${a.hours}h</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editActual(${a.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-danger btn-small" onclick="deleteActual(${a.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        // クイック入力モード切り替え
        function switchQuickInputMode(mode) {
            quickInputMode = mode;

            const actualForm = document.getElementById('quickActualForm');
            const estimateForm = document.getElementById('quickEstimateForm');
            const vacationForm = document.getElementById('quickVacationForm');
            const modeTitle = document.getElementById('quickModeTitle');
            const bottomTitle = document.getElementById('quickBottomTitle');
            const actualBtn = document.getElementById('quickActualModeBtn');
            const estimateBtn = document.getElementById('quickEstimateModeBtn');
            const vacationBtn = document.getElementById('quickVacationModeBtn');

            // 全てのフォームとボタンをリセット
            actualForm.style.display = 'none';
            estimateForm.style.display = 'none';
            vacationForm.style.display = 'none';
            actualBtn.classList.remove('active');
            estimateBtn.classList.remove('active');
            vacationBtn.classList.remove('active');

            if (mode === 'actual') {
                actualForm.style.display = 'block';
                modeTitle.textContent = '今日の実績を入力';
                bottomTitle.textContent = '今日の入力済み実績';
                bottomTitle.style.display = 'block';
                document.getElementById('todayActuals').style.display = 'block';
                actualBtn.classList.add('active');

                // 前回の実績を自動選択
                setQuickInputPreviousActual();
            } else if (mode === 'estimate') {
                estimateForm.style.display = 'block';
                modeTitle.textContent = '新規見積登録';
                bottomTitle.style.display = 'none';
                document.getElementById('todayActuals').style.display = 'none';
                estimateBtn.classList.add('active');
            } else if (mode === 'vacation') {
                vacationForm.style.display = 'block';
                modeTitle.textContent = '休暇登録';
                bottomTitle.style.display = 'none';
                document.getElementById('todayActuals').style.display = 'none';
                vacationBtn.classList.add('active');

                // 休暇登録フォームの日付を今日に設定
                const today = new Date().toISOString().split('T')[0];
                document.getElementById('quickVacationDate').value = today;
            }

            // 設定で記憶が有効な場合、localStorageに保存
            if (rememberQuickInputMode) {
                localStorage.setItem('quickInputMode', mode);
            }
        }

        // 作業月タイプの切り替え（単一月/複数月）
        function switchQuickEstMonthType() {
            const monthType = document.querySelector('input[name="quickEstMonthType"]:checked').value;
            const singleMonthInput = document.getElementById('quickEstSingleMonthInput');
            const multiMonthInput = document.getElementById('quickEstMultiMonthInput');

            if (monthType === 'single') {
                singleMonthInput.style.display = 'block';
                multiMonthInput.style.display = 'none';
                updateQuickEstimateTableHeader(false);
            } else {
                singleMonthInput.style.display = 'none';
                multiMonthInput.style.display = 'block';
                updateQuickEstimateTableHeader(true);

                // 複数月モードの場合、開始月と終了月を同期
                const startMonth = document.getElementById('quickEstStartMonth').value;
                const startMonthMulti = document.getElementById('quickEstStartMonthMulti');
                const endMonth = document.getElementById('quickEstEndMonth');

                if (startMonth && startMonthMulti) {
                    startMonthMulti.value = startMonth;
                    if (endMonth && !endMonth.value) {
                        endMonth.value = startMonth;
                    }
                }
                updateDefaultProcessMonths(startMonthMulti.value, endMonth.value);
            }
        }

        // 作業月UIの更新（単一月/複数月の切り替え）
        function updateQuickEstWorkMonthUI() {
            const monthType = document.querySelector('input[name="quickEstMonthType"]:checked')?.value || 'single';

            if (monthType === 'single') {
                // 単一月モードでは何もしない
                return;
            }

            // 複数月モードの場合のみ処理
            const startMonthMulti = document.getElementById('quickEstStartMonthMulti');
            const endMonth = document.getElementById('quickEstEndMonth');

            if (!startMonthMulti || !endMonth) return;
            if (!startMonthMulti.value) return;

            // 工程別のデフォルト作業月を更新
            if (endMonth.value && startMonthMulti.value !== endMonth.value) {
                updateDefaultProcessMonths(startMonthMulti.value, endMonth.value);
            }
        }

        // 工程表のヘッダーと作業月列を更新
        function updateQuickEstimateTableHeader(showWorkMonthColumn) {
            const table = document.getElementById('quickEstimateTable');
            const headerRow = table.querySelector('thead tr');
            const bodyRows = table.querySelectorAll('tbody tr');

            if (showWorkMonthColumn) {
                // 作業月列を追加
                if (headerRow.children.length === 3) {
                    const th = document.createElement('th');
                    th.style.width = '150px';
                    th.style.padding = '8px';
                    th.textContent = '作業月';
                    headerRow.appendChild(th);
                }

                bodyRows.forEach((row, index) => {
                    if (row.children.length === 3) {
                        const td = document.createElement('td');
                        const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
                        const processName = processes[index];
                        td.innerHTML = `
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <select id="quickEst${processName}_startMonth" style="margin: 0; flex: 1;"></select>
                                <span>〜</span>
                                <select id="quickEst${processName}_endMonth" style="margin: 0; flex: 1;"></select>
                            </div>
                        `;
                        row.appendChild(td);
                    }
                });
            } else {
                // 作業月列を削除
                if (headerRow.children.length === 4) {
                    headerRow.removeChild(headerRow.lastChild);
                }

                bodyRows.forEach(row => {
                    if (row.children.length === 4) {
                        row.removeChild(row.lastChild);
                    }
                });
            }
        }

        // ウォーターフォール方式でデフォルトの作業月を計算
        function calculateDefaultWorkMonths(startMonth, endMonth) {
            if (!startMonth || !endMonth) return [];

            const months = generateMonthRange(startMonth, endMonth);
            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const result = [];

            processes.forEach((process, index) => {
                const monthIndex = Math.floor(index * months.length / processes.length);
                const assignedMonth = months[monthIndex];
                result.push({
                    process: process,
                    startMonth: assignedMonth,
                    endMonth: assignedMonth
                });
            });

            return result;
        }

        // 各工程のデフォルト作業月を設定
        function updateDefaultProcessMonths(startMonth, endMonth) {
            const defaults = calculateDefaultWorkMonths(startMonth, endMonth);
            const months = generateMonthRange(startMonth, endMonth);

            defaults.forEach(item => {
                const startSelect = document.getElementById(`quickEst${item.process}_startMonth`);
                const endSelect = document.getElementById(`quickEst${item.process}_endMonth`);

                if (startSelect && endSelect) {
                    // セレクトボックスに選択肢を設定
                    startSelect.innerHTML = '';
                    endSelect.innerHTML = '';
                    months.forEach(month => {
                        startSelect.innerHTML += `<option value="${month}">${month.substring(0, 4)}年${parseInt(month.substring(5))}月</option>`;
                        endSelect.innerHTML += `<option value="${month}">${month.substring(0, 4)}年${parseInt(month.substring(5))}月</option>`;
                    });

                    // デフォルト値を設定
                    startSelect.value = item.startMonth;
                    endSelect.value = item.endMonth;
                }
            });
        }

        // 見積登録関数（クイック入力タブ用）
        function addQuickEstimate() {
            const version = document.getElementById('quickEstVersion').value;

            // 帳票名を取得（selectまたはinputから）
            const formNameSelect = document.getElementById('quickEstFormNameSelect');
            const formNameInput = document.getElementById('quickEstFormName');
            const formName = (formNameInput.style.display === 'none' ? formNameSelect.value : formNameInput.value).trim();

            const taskName = document.getElementById('quickEstTask').value.trim();

            // ラジオボタンの選択に応じて適切なセレクトボックスから値を取得
            const monthType = document.querySelector('input[name="quickEstMonthType"]:checked').value;
            let startMonth, endMonth;

            if (monthType === 'single') {
                startMonth = document.getElementById('quickEstStartMonth').value;
                endMonth = null;
            } else {
                startMonth = document.getElementById('quickEstStartMonthMulti').value;
                endMonth = document.getElementById('quickEstEndMonth');
            }

            if (!version || version === '新規追加') {
                alert('版数を選択してください');
                return;
            }

            if (!formName) {
                alert('帳票名を入力してください');
                return;
            }

            if (!taskName) {
                alert('対応名を入力してください');
                return;
            }

            // 帳票名と対応名を結合
            const task = `${formName}：${taskName}`;

            if (!startMonth) {
                alert('作業月を選択してください');
                return;
            }

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const monthSplitEnabled = document.getElementById('quickEnableMonthSplit').checked;

            if (monthSplitEnabled) {
                // 月分割モード
                const splitProcesses = [];
                processes.forEach(proc => {
                    if (document.getElementById(`quickSplit${proc}`).checked) {
                        splitProcesses.push(proc);
                    }
                });

                if (splitProcesses.length === 0) {
                    alert('分割する工程を少なくとも一つ選択してください');
                    return;
                }

                addQuickEstimateWithMonthSplit(version, task, processes, splitProcesses);
            } else {
                // 通常モード
                addQuickEstimateNormal(version, task, processes, startMonth, endMonth);
            }
        }

        // 通常モードで見積登録
        function addQuickEstimateNormal(version, task, processes, startMonth, endMonthSelect) {
            const isSingleMonth = !endMonthSelect || endMonthSelect.style.display === 'none' || !endMonthSelect.value || startMonth === endMonthSelect.value;

            processes.forEach(proc => {
                const member = document.getElementById(`quickEst${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`quickEst${proc}`).value) || 0;

                if (hours > 0) {
                    let workMonths, monthlyHours, workMonth;

                    if (isSingleMonth) {
                        // 単一月モード
                        workMonth = startMonth;
                        workMonths = [startMonth];
                        monthlyHours = { [startMonth]: hours };
                    } else {
                        // 複数月モード: 各工程の作業月を取得
                        const procStartMonth = document.getElementById(`quickEst${proc}_startMonth`).value;
                        const procEndMonth = document.getElementById(`quickEst${proc}_endMonth`).value;

                        if (procStartMonth === procEndMonth) {
                            workMonth = procStartMonth;
                            workMonths = [procStartMonth];
                            monthlyHours = { [procStartMonth]: hours };
                        } else {
                            const months = generateMonthRange(procStartMonth, procEndMonth);
                            workMonth = procStartMonth;
                            workMonths = months;
                            const hoursPerMonth = hours / months.length;
                            monthlyHours = {};
                            months.forEach(m => {
                                monthlyHours[m] = hoursPerMonth;
                            });
                        }
                    }

                    estimates.push({
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: hours,
                        workMonth: workMonth,
                        workMonths: workMonths,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    });
                }
            });

            saveData();
            clearQuickEstimateForm();
            updateMonthOptions();
            updateEstimateVersionOptions(); // 版数選択肢を更新
            updateQuickTaskList();
            updateMemberOptions();
            renderEstimateList();
            updateReport();
            showAlert('見積を登録しました', true);
        }

        // 月分割モードで見積登録
        function addQuickEstimateWithMonthSplit(version, task, processes, splitProcesses) {
            const totalHours = parseFloat(document.getElementById('quickTotalHours').value) || 0;
            const startMonth = document.getElementById('quickStartMonth').value;
            const endMonth = document.getElementById('quickEndMonth').value;
            const method = document.querySelector('input[name="quickSplitMethod"]:checked').value;

            if (totalHours === 0) {
                alert('総工数を入力してください');
                return;
            }

            if (!startMonth || !endMonth) {
                alert('作業期間を選択してください');
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);
            const monthlyHours = {};

            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`quickMonthHours_${index}`);
                    const hours = input ? parseFloat(input.value) || 0 : 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });

                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計（${total}h）が総工数（${totalHours}h）と一致しません`);
                    return;
                }
            }

            processes.forEach(proc => {
                const member = document.getElementById(`quickEst${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`quickEst${proc}`).value) || 0;

                if (hours > 0) {
                    const est = {
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: totalHours,
                        workMonth: startMonth,
                        workMonths: months,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    };

                    if (splitProcesses.includes(proc)) {
                        estimates.push(est);
                    } else {
                        estimates.push({
                            id: Date.now() + Math.random(),
                            version: version,
                            task: task,
                            process: proc,
                            member: member,
                            hours: hours,
                            workMonth: '',
                            workMonths: [],
                            monthlyHours: {},
                            createdAt: new Date().toISOString()
                        });
                    }
                }
            });

            saveData();
            clearQuickEstimateForm();
            updateMonthOptions();
            updateEstimateVersionOptions(); // 版数選択肢を更新
            updateQuickTaskList();
            updateMemberOptions();
            renderEstimateList();
            updateReport();
            alert('見積を登録しました（月分割）');
        }

        // 見積フォームのクリア
        function clearQuickEstimateForm() {
            // 帳票名のselectとinputをリセット
            const formNameSelect = document.getElementById('quickEstFormNameSelect');
            const formNameInput = document.getElementById('quickEstFormName');
            formNameSelect.value = '';
            formNameSelect.style.display = 'block';
            formNameInput.value = '';
            formNameInput.style.display = 'none';

            document.getElementById('quickEstTask').value = '';

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            processes.forEach(proc => {
                document.getElementById(`quickEst${proc}`).value = '';
            });

            // 月分割アシスタントをクリア
            document.getElementById('quickEnableMonthSplit').checked = false;
            toggleQuickMonthSplit();

            // 合計表示をリセット
            updateQuickEstimateTotals();
        }

        // 月分割アシスタントの表示切り替え
        function toggleQuickMonthSplit() {
            const enabled = document.getElementById('quickEnableMonthSplit').checked;
            const panel = document.getElementById('quickMonthSplitPanel');

            if (enabled) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        // 月分割プレビューの更新
        function updateQuickMonthPreview() {
            const totalHours = parseFloat(document.getElementById('quickTotalHours').value) || 0;
            const startMonth = document.getElementById('quickStartMonth').value;
            const endMonth = document.getElementById('quickEndMonth').value;
            const method = document.querySelector('input[name="quickSplitMethod"]:checked').value;
            const preview = document.getElementById('quickMonthPreview');

            if (!startMonth || !endMonth || totalHours === 0) {
                preview.innerHTML = '';
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);

            let html = '<div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 4px;">';
            html += '<div style="font-weight: 600; margin-bottom: 8px; color: rgba(255,255,255,0.9);">月別工数設定</div>';

            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="margin-bottom: 4px; color: rgba(255,255,255,0.8);">${y}年${parseInt(m)}月: ${hoursPerMonth.toFixed(1)}h</div>`;
                });
            } else {
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    html += `<div style="margin-bottom: 6px;">
                        <label style="display: inline-block; width: 100px; color: rgba(255,255,255,0.9);">${y}年${parseInt(m)}月:</label>
                        <input type="number" id="quickMonthHours_${index}" step="0.1" min="0" placeholder="h" style="width: 80px; margin: 0;" oninput="updateQuickMonthPreview()">
                        <span style="margin-left: 5px;">h</span>
                    </div>`;
                });

                let total = 0;
                months.forEach((month, index) => {
                    const input = document.getElementById(`quickMonthHours_${index}`);
                    if (input) total += parseFloat(input.value) || 0;
                });

                html += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.2); color: rgba(255,255,255,0.9);">
                    合計: ${total.toFixed(1)}h / 目標: ${totalHours}h
                    ${Math.abs(total - totalHours) > 0.01 ? '<span style="color: #ff6b6b; margin-left: 10px;">⚠ 合計が一致していません</span>' : '<span style="color: #51cf66; margin-left: 10px;">✓ OK</span>'}
                </div>`;
            }

            html += '</div>';
            preview.innerHTML = html;
        }

        // 見積登録フォームの合計をリアルタイム計算
        function updateQuickEstimateTotals() {
            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            let totalHours = 0;

            processes.forEach(proc => {
                const input = document.getElementById(`quickEst${proc}`);
                if (input && input.value) {
                    totalHours += parseFloat(input.value) || 0;
                }
            });

            // 人日・人月を計算（1人日=8h、1人月=20人日）
            const workingDaysPerMonth = 20;
            const totalDays = totalHours / 8;
            const totalMonths = totalDays / workingDaysPerMonth;

            // 表示を更新
            document.getElementById('quickEstTotalHours').textContent = totalHours.toFixed(1);
            document.getElementById('quickEstTotalDays').textContent = totalDays.toFixed(1);
            document.getElementById('quickEstTotalMonths').textContent = totalMonths.toFixed(2);
        }

        // クイック入力の見積登録フォーム初期化
        function initQuickEstimateForm() {
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

            // 作業月セレクトボックスの初期化
            generateMonthOptions('quickEstStartMonth', currentMonth);
            generateMonthOptions('quickEstStartMonthMulti', currentMonth);
            generateMonthOptions('quickEstEndMonth', currentMonth);
            generateMonthOptions('quickStartMonth', currentMonth);
            generateMonthOptions('quickEndMonth', currentMonth);

            // 前回モードを記憶する設定の読み込み
            const savedRememberMode = localStorage.getItem('rememberQuickInputMode');
            rememberQuickInputMode = savedRememberMode === 'true';

            // チェックボックスのUIに反映
            const rememberCheckbox = document.getElementById('rememberQuickInputMode');
            if (rememberCheckbox) {
                rememberCheckbox.checked = rememberQuickInputMode;
            }

            // 前回モードの復元
            if (rememberQuickInputMode) {
                const savedMode = localStorage.getItem('quickInputMode');
                if (savedMode && (savedMode === 'actual' || savedMode === 'estimate')) {
                    quickInputMode = savedMode;
                    switchQuickInputMode(savedMode);
                }
            }
        }

        // ========== 見積もり新規登録モーダル関連関数 ==========

        function openAddEstimateModal() {
            initAddEstimateForm();
            document.getElementById('addEstimateModal').style.display = 'flex';
        }

        function closeAddEstimateModal() {
            document.getElementById('addEstimateModal').style.display = 'none';
            // フォームをリセット
            document.getElementById('addEstVersion').value = '';

            // 帳票名のselectとinputをリセット
            const formNameSelect = document.getElementById('addEstFormNameSelect');
            const formNameInput = document.getElementById('addEstFormName');
            formNameSelect.value = '';
            formNameSelect.style.display = 'block';
            formNameInput.value = '';
            formNameInput.style.display = 'none';

            document.getElementById('addEstTask').value = '';
            document.querySelector('input[name="addEstMonthType"][value="single"]').checked = true;
            switchAddEstMonthType();

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            processes.forEach(proc => {
                document.getElementById(`addEst${proc}_member`).value = '';
                document.getElementById(`addEst${proc}`).value = '';
            });

            document.getElementById('addEnableMonthSplit').checked = false;
            toggleAddMonthSplit();
            updateAddEstimateTotals();
        }

        // 担当者の自動コピー機能（PG↔PT、IT↔ST）
        function autoFillMember(changedFieldId) {
            // フィールドIDからプレフィックス（add/quick）と工程を抽出
            const match = changedFieldId.match(/^(add|quick)Est(\w+)_member$/);
            if (!match) return;

            const prefix = match[1];
            const changedProcess = match[2];

            // 変更されたフィールドの値を取得
            const changedValue = document.getElementById(changedFieldId).value;
            if (!changedValue) return; // 空の場合は何もしない

            // コピー先の工程を決定（PG↔PT、IT↔ST）
            let targetProcess = null;
            if (changedProcess === 'PG') targetProcess = 'PT';
            else if (changedProcess === 'PT') targetProcess = 'PG';
            else if (changedProcess === 'IT') targetProcess = 'ST';
            else if (changedProcess === 'ST') targetProcess = 'IT';

            if (!targetProcess) return; // 対象外の工程

            // コピー先フィールドを取得
            const targetFieldId = `${prefix}Est${targetProcess}_member`;
            const targetField = document.getElementById(targetFieldId);

            // コピー先が空の場合のみ自動コピー
            if (targetField && !targetField.value) {
                targetField.value = changedValue;
            }
        }

        function initAddEstimateForm() {
            const now = new Date();
            const currentMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;

            // 版数オプションを生成（updateVersionOptionsで全てのセレクトが更新される）
            updateVersionOptions();

            // 担当者オプションを生成（updateMemberOptionsで全てのセレクトが更新される）
            updateMemberOptions();

            // 作業月セレクトボックスの初期化
            generateMonthOptions('addEstStartMonth', currentMonth);
            generateMonthOptions('addEstStartMonthMulti', currentMonth);
            generateMonthOptions('addEstEndMonth', currentMonth);
            generateMonthOptions('addStartMonth', currentMonth);
            generateMonthOptions('addEndMonth', currentMonth);

            // 複数月選択の期間変更時にリアルタイム更新
            const startMonthMulti = document.getElementById('addEstStartMonthMulti');
            const endMonth = document.getElementById('addEstEndMonth');
            if (startMonthMulti) {
                startMonthMulti.addEventListener('change', function() {
                    // 開始月が変更されたら、終了月の選択肢を更新（開始月より後の月のみ）
                    const currentEndValue = endMonth.value;
                    generateMonthOptions('addEstEndMonth', currentEndValue, startMonthMulti.value);
                    updateAddEstWorkMonthUI();
                });
            }
            if (endMonth) {
                endMonth.addEventListener('change', updateAddEstWorkMonthUI);
            }
        }

        // 作業月UIの更新（見積登録モーダル用）
        function updateAddEstWorkMonthUI() {
            const monthType = document.querySelector('input[name="addEstMonthType"]:checked')?.value || 'single';

            if (monthType === 'single') {
                // 単一月モードでは何もしない
                return;
            }

            // 複数月モードの場合のみ処理
            const startMonthMulti = document.getElementById('addEstStartMonthMulti');
            const endMonth = document.getElementById('addEstEndMonth');

            if (!startMonthMulti || !endMonth) return;
            if (!startMonthMulti.value) return;

            // 工程別のデフォルト作業月を更新
            if (endMonth.value && startMonthMulti.value !== endMonth.value) {
                updateDefaultAddProcessMonths(startMonthMulti.value, endMonth.value);
            } else if (endMonth.value === startMonthMulti.value) {
                // 開始月と終了月が同じ場合も更新
                updateDefaultAddProcessMonths(startMonthMulti.value, endMonth.value);
            }
        }

        function switchAddEstMonthType() {
            const monthType = document.querySelector('input[name="addEstMonthType"]:checked').value;
            const singleMonthInput = document.getElementById('addEstSingleMonthInput');
            const multiMonthInput = document.getElementById('addEstMultiMonthInput');

            if (monthType === 'single') {
                singleMonthInput.style.display = 'block';
                multiMonthInput.style.display = 'none';
                updateAddEstimateTableHeader(false);
            } else {
                singleMonthInput.style.display = 'none';
                multiMonthInput.style.display = 'block';

                // 複数月モードの場合、開始月と終了月を同期
                const startMonth = document.getElementById('addEstStartMonth').value;
                const startMonthMulti = document.getElementById('addEstStartMonthMulti');
                const endMonth = document.getElementById('addEstEndMonth');

                if (startMonth && startMonthMulti) {
                    startMonthMulti.value = startMonth;
                    // 終了月の選択肢を開始月より後の月のみに更新
                    const currentEndValue = endMonth ? endMonth.value : '';
                    generateMonthOptions('addEstEndMonth', currentEndValue, startMonth);
                    if (endMonth && !endMonth.value) {
                        endMonth.value = startMonth;
                    }
                }

                // テーブルに作業月列を追加（内部で選択肢も設定される）
                updateAddEstimateTableHeader(true);
            }
        }

        // 工程表のヘッダーと作業月列を更新（見積登録モーダル用）
        function updateAddEstimateTableHeader(showWorkMonthColumn) {
            const table = document.getElementById('addEstimateTable');
            if (!table) return;

            const headerRow = table.querySelector('thead tr');
            const bodyRows = table.querySelectorAll('tbody tr');

            if (showWorkMonthColumn) {
                // 作業月列を追加
                if (headerRow.children.length === 3) {
                    const th = document.createElement('th');
                    th.style.width = '150px';
                    th.style.padding = '8px';
                    th.textContent = '作業月';
                    headerRow.appendChild(th);
                }

                bodyRows.forEach((row, index) => {
                    if (row.children.length === 3) {
                        const td = document.createElement('td');
                        const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
                        const processName = processes[index];
                        td.innerHTML = `
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <select id="addEst${processName}_startMonth" style="margin: 0; flex: 1;"></select>
                                <span>〜</span>
                                <select id="addEst${processName}_endMonth" style="margin: 0; flex: 1;"></select>
                            </div>
                        `;
                        row.appendChild(td);
                    }
                });

                // DOM更新後に選択肢を設定
                setTimeout(() => {
                    const startMonthMulti = document.getElementById('addEstStartMonthMulti');
                    const endMonth = document.getElementById('addEstEndMonth');
                    if (startMonthMulti && endMonth && startMonthMulti.value && endMonth.value) {
                        updateDefaultAddProcessMonths(startMonthMulti.value, endMonth.value);
                    }
                }, 0);
            } else {
                // 作業月列を削除
                if (headerRow.children.length === 4) {
                    headerRow.removeChild(headerRow.lastChild);
                }

                bodyRows.forEach(row => {
                    if (row.children.length === 4) {
                        row.removeChild(row.lastChild);
                    }
                });
            }
        }

        // 各工程のデフォルト作業月を設定（見積登録モーダル用）
        function updateDefaultAddProcessMonths(startMonth, endMonth) {
            const defaults = calculateDefaultWorkMonths(startMonth, endMonth);
            const months = generateMonthRange(startMonth, endMonth);

            defaults.forEach(item => {
                const startSelect = document.getElementById(`addEst${item.process}_startMonth`);
                const endSelect = document.getElementById(`addEst${item.process}_endMonth`);

                if (startSelect && endSelect) {
                    // セレクトボックスに選択肢を設定（年なし表示）
                    startSelect.innerHTML = '';
                    endSelect.innerHTML = '';
                    months.forEach(month => {
                        startSelect.innerHTML += `<option value="${month}">${parseInt(month.substring(5))}月</option>`;
                        endSelect.innerHTML += `<option value="${month}">${parseInt(month.substring(5))}月</option>`;
                    });

                    // デフォルト値を設定
                    startSelect.value = item.startMonth;
                    endSelect.value = item.endMonth;
                }
            });
        }

        function toggleAddMonthSplit() {
            const enabled = document.getElementById('addEnableMonthSplit').checked;
            const panel = document.getElementById('addMonthSplitPanel');

            if (enabled) {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function updateAddEstimateTotals() {
            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            let totalHours = 0;

            processes.forEach(proc => {
                const hours = parseFloat(document.getElementById(`addEst${proc}`).value) || 0;
                totalHours += hours;
            });

            const totalDays = (totalHours / 8).toFixed(1);
            const totalMonths = (totalHours / 160).toFixed(2);

            document.getElementById('addEstTotalHours').textContent = totalHours.toFixed(1);
            document.getElementById('addEstTotalDays').textContent = totalDays;
            document.getElementById('addEstTotalMonths').textContent = totalMonths;
        }

        function updateAddMonthPreview() {
            const startMonth = document.getElementById('addStartMonth').value;
            const endMonth = document.getElementById('addEndMonth').value;
            const totalHours = parseFloat(document.getElementById('addTotalHours').value) || 0;
            const method = document.querySelector('input[name="addSplitMethod"]:checked').value;
            const preview = document.getElementById('addMonthPreview');

            if (!startMonth || !endMonth || totalHours <= 0) {
                preview.innerHTML = '';
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);
            let html = '<div style="background: #f0f0f0; padding: 10px; border-radius: 5px;">';
            html += '<strong>分割プレビュー:</strong><br>';

            if (method === 'equal') {
                const hoursPerMonth = (totalHours / months.length).toFixed(1);
                months.forEach(month => {
                    html += `<div style="margin-top: 5px;">${month}: ${hoursPerMonth}h</div>`;
                });
            } else {
                months.forEach(month => {
                    html += `<div style="margin-top: 5px; display: flex; align-items: center; gap: 10px;">`;
                    html += `<span style="min-width: 100px;">${month}:</span>`;
                    html += `<input type="number" id="addMonthHours_${month}" step="0.1" min="0" placeholder="0" style="width: 80px; padding: 4px;" oninput="checkAddMonthTotal()"> h`;
                    html += `</div>`;
                });
            }

            html += '</div>';
            preview.innerHTML = html;
        }

        function checkAddMonthTotal() {
            const startMonth = document.getElementById('addStartMonth').value;
            const endMonth = document.getElementById('addEndMonth').value;
            const totalHours = parseFloat(document.getElementById('addTotalHours').value) || 0;

            if (!startMonth || !endMonth) return;

            const months = generateMonthRange(startMonth, endMonth);
            let sum = 0;

            months.forEach(month => {
                const input = document.getElementById(`addMonthHours_${month}`);
                if (input) {
                    sum += parseFloat(input.value) || 0;
                }
            });

            const preview = document.getElementById('addMonthPreview');
            const existingWarning = preview.querySelector('.total-warning');
            if (existingWarning) {
                existingWarning.remove();
            }

            if (Math.abs(sum - totalHours) > 0.01) {
                const warning = document.createElement('div');
                warning.className = 'total-warning';
                warning.style.cssText = 'color: #d32f2f; margin-top: 10px; font-weight: 600;';
                warning.textContent = `⚠️ 合計: ${sum.toFixed(1)}h（総工数: ${totalHours.toFixed(1)}h）`;
                preview.appendChild(warning);
            }
        }

        function addEstimateFromModal() {
            const version = document.getElementById('addEstVersion').value;

            // 帳票名を取得（selectまたはinputから）
            const formNameSelect = document.getElementById('addEstFormNameSelect');
            const formNameInput = document.getElementById('addEstFormName');
            const formName = (formNameInput.style.display === 'none' ? formNameSelect.value : formNameInput.value).trim();

            const taskName = document.getElementById('addEstTask').value.trim();

            // ラジオボタンの選択に応じて適切なセレクトボックスから値を取得
            const monthType = document.querySelector('input[name="addEstMonthType"]:checked').value;
            let startMonth, endMonth;

            if (monthType === 'single') {
                startMonth = document.getElementById('addEstStartMonth').value;
                endMonth = null;
            } else {
                startMonth = document.getElementById('addEstStartMonthMulti').value;
                endMonth = document.getElementById('addEstEndMonth').value;
            }

            if (!version || version === '新規追加') {
                alert('版数を選択してください');
                return;
            }

            if (!formName) {
                alert('帳票名を入力してください');
                return;
            }

            if (!taskName) {
                alert('対応名を入力してください');
                return;
            }

            // 帳票名と対応名を結合
            const task = `${formName}：${taskName}`;

            if (!startMonth) {
                alert('作業月を選択してください');
                return;
            }

            const processes = ['UI', 'PG', 'PT', 'IT', 'ST'];
            const monthSplitEnabled = document.getElementById('addEnableMonthSplit').checked;

            if (monthSplitEnabled) {
                // 月分割モード
                const splitProcesses = [];
                processes.forEach(proc => {
                    if (document.getElementById(`addSplit${proc}`).checked) {
                        splitProcesses.push(proc);
                    }
                });

                if (splitProcesses.length === 0) {
                    alert('分割する工程を少なくとも一つ選択してください');
                    return;
                }

                addEstimateFromModalWithMonthSplit(version, task, processes, splitProcesses);
            } else {
                // 通常モード
                addEstimateFromModalNormal(version, task, processes, startMonth, endMonth);
            }
        }

        function addEstimateFromModalNormal(version, task, processes, startMonth, endMonth) {
            const isSingleMonth = !endMonth || startMonth === endMonth;

            processes.forEach(proc => {
                const member = document.getElementById(`addEst${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`addEst${proc}`).value) || 0;

                if (hours > 0) {
                    let workMonths, monthlyHours, workMonth;

                    if (isSingleMonth) {
                        // 単一月モード
                        workMonth = startMonth;
                        workMonths = [startMonth];
                        monthlyHours = { [startMonth]: hours };
                    } else {
                        // 複数月モード: 各工程の作業月を取得
                        const procStartMonth = document.getElementById(`addEst${proc}_startMonth`)?.value;
                        const procEndMonth = document.getElementById(`addEst${proc}_endMonth`)?.value;

                        if (procStartMonth && procEndMonth) {
                            if (procStartMonth === procEndMonth) {
                                workMonth = procStartMonth;
                                workMonths = [procStartMonth];
                                monthlyHours = { [procStartMonth]: hours };
                            } else {
                                const months = generateMonthRange(procStartMonth, procEndMonth);
                                workMonth = procStartMonth;
                                workMonths = months;
                                monthlyHours = {};
                                months.forEach(m => {
                                    monthlyHours[m] = hours / months.length;
                                });
                            }
                        } else {
                            // 工程別作業月が設定されていない場合は全期間
                            const months = generateMonthRange(startMonth, endMonth);
                            workMonth = startMonth;
                            workMonths = months;
                            monthlyHours = {};
                            months.forEach(m => {
                                monthlyHours[m] = hours / months.length;
                            });
                        }
                    }

                    const est = {
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: hours,
                        workMonth: workMonth,
                        workMonths: workMonths,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    };

                    estimates.push(est);

                    // 見込残存時間も自動設定（見積時間と同じ）
                    saveRemainingEstimate(version, task, proc, member, hours);
                }
            });

            saveData();
            updateEstimateVersionOptions(); // 版数選択肢を更新
            renderEstimateList();
            updateReport();
            closeAddEstimateModal();
            showAlert('見積を登録しました', true);
        }

        function addEstimateFromModalWithMonthSplit(version, task, processes, splitProcesses) {
            const startMonth = document.getElementById('addStartMonth').value;
            const endMonth = document.getElementById('addEndMonth').value;
            const totalHours = parseFloat(document.getElementById('addTotalHours').value) || 0;
            const method = document.querySelector('input[name="addSplitMethod"]:checked').value;

            if (!startMonth || !endMonth) {
                alert('作業期間を選択してください');
                return;
            }

            if (totalHours <= 0) {
                alert('総工数を入力してください');
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);

            if (months.length === 0) {
                alert('有効な作業期間を選択してください');
                return;
            }

            let monthlyHours = {};

            if (method === 'equal') {
                const hoursPerMonth = totalHours / months.length;
                months.forEach(month => {
                    monthlyHours[month] = hoursPerMonth;
                });
            } else {
                let total = 0;
                months.forEach(month => {
                    const input = document.getElementById(`addMonthHours_${month}`);
                    const hours = parseFloat(input.value) || 0;
                    monthlyHours[month] = hours;
                    total += hours;
                });

                if (Math.abs(total - totalHours) > 0.01) {
                    alert(`月別工数の合計（${total}h）が総工数（${totalHours}h）と一致しません`);
                    return;
                }
            }

            processes.forEach(proc => {
                const member = document.getElementById(`addEst${proc}_member`).value;
                const hours = parseFloat(document.getElementById(`addEst${proc}`).value) || 0;

                if (hours > 0) {
                    const est = {
                        id: Date.now() + Math.random(),
                        version: version,
                        task: task,
                        process: proc,
                        member: member,
                        hours: totalHours,
                        workMonth: startMonth,
                        workMonths: months,
                        monthlyHours: monthlyHours,
                        createdAt: new Date().toISOString()
                    };

                    if (splitProcesses.includes(proc)) {
                        estimates.push(est);
                        // 見込残存時間も自動設定（総工数と同じ）
                        saveRemainingEstimate(version, task, proc, member, totalHours);
                    } else {
                        // 分割対象外の工程は通常通り登録
                        est.hours = hours;
                        est.monthlyHours = { [startMonth]: hours };
                        est.workMonths = [startMonth];
                        estimates.push(est);
                        // 見込残存時間も自動設定（見積時間と同じ）
                        saveRemainingEstimate(version, task, proc, member, hours);
                    }
                }
            });

            saveData();
            updateEstimateVersionOptions(); // 版数選択肢を更新
            renderEstimateList();
            updateReport();
            closeAddEstimateModal();
            showAlert('見積を登録しました', true);
        }

        // ========== ここまで見積もり新規登録モーダル関連関数 ==========

        function renderEstimateList() {
            const container = document.getElementById('estimateList');
            if (!container) return;

            const viewTypeElement = document.getElementById('estimateViewType');
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const filterTypeElement = document.getElementById('estimateFilterType');
            const versionFilterElement = document.getElementById('estimateVersionFilter');

            if (!viewTypeElement || !monthFilterElement) return;

            const viewType = viewTypeElement.value;
            const filterType = filterTypeElement ? filterTypeElement.value : 'month';
            const monthFilter = monthFilterElement.value;
            const versionFilter = versionFilterElement ? versionFilterElement.value : 'all';

            if (estimates.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">見積データがありません</p>';
                // 合計を0にリセット
                const totalHoursElement = document.getElementById('estimateTotalHours');
                const totalManpowerElement = document.getElementById('estimateTotalManpower');
                if (totalHoursElement) totalHoursElement.textContent = '0h';
                if (totalManpowerElement) totalManpowerElement.textContent = '0人日 / 0人月';
                // 担当者別合計を非表示
                const memberSummaryContainer = document.getElementById('estimateMemberSummary');
                if (memberSummaryContainer) memberSummaryContainer.style.display = 'none';
                return;
            }

            // フィルタを適用（グローバル変数に格納）
            filteredEstimates = estimates;

            if (filterType === 'version') {
                // 版数別フィルタ
                if (versionFilter !== 'all') {
                    filteredEstimates = estimates.filter(e => e.version === versionFilter);
                }
            } else {
                // 月別フィルタ
                if (monthFilter !== 'all') {
                    filteredEstimates = estimates.filter(e => {
                        const est = normalizeEstimate(e);
                        // workMonthsが空または未定義の場合は全期間表示（常に表示）
                        if (!est.workMonths || est.workMonths.length === 0) {
                            return true;
                        }
                        return est.workMonths.includes(monthFilter);
                    });
                }
            }

            // フィルタ後にデータがない場合
            if (filteredEstimates.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した期間に見積データがありません</p>';
                // 合計を0にリセット
                const totalHoursElement = document.getElementById('estimateTotalHours');
                const totalManpowerElement = document.getElementById('estimateTotalManpower');
                if (totalHoursElement) totalHoursElement.textContent = '0h';
                if (totalManpowerElement) totalManpowerElement.textContent = '0人日 / 0人月';
                // 担当者別合計を非表示
                const memberSummaryContainer = document.getElementById('estimateMemberSummary');
                if (memberSummaryContainer) memberSummaryContainer.style.display = 'none';
                return;
            }

            // 合計工数を計算
            let totalHours = 0;
            if (filterType === 'version') {
                // 版数別フィルタの場合は全工数を合計
                totalHours = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
            } else {
                // 月別フィルタの場合
                if (monthFilter === 'all') {
                    totalHours = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
                } else {
                    filteredEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        // 月別工数が設定されている場合はそれを使用
                        if (est.monthlyHours && est.monthlyHours[monthFilter]) {
                            totalHours += est.monthlyHours[monthFilter];
                        }
                        // workMonthsが空（作業月未設定）の場合は全工数を含める
                        else if (!est.workMonths || est.workMonths.length === 0) {
                            totalHours += est.hours;
                        }
                    });
                }
            }

            // 人日・人月を計算
            let workingDaysPerMonth = 20; // デフォルト
            if (monthFilter !== 'all') {
                const [year, month] = monthFilter.split('-');
                const calculatedDays = getWorkingDays(parseInt(year), parseInt(month));
                // 0で割るのを防ぐため、最小値を1に設定
                workingDaysPerMonth = calculatedDays > 0 ? calculatedDays : 20;
            }
            const totalManDays = (totalHours / 8).toFixed(1);
            const totalManMonths = (totalHours / 8 / workingDaysPerMonth).toFixed(2);

            // 合計を表示
            const totalHoursElement = document.getElementById('estimateTotalHours');
            const totalManpowerElement = document.getElementById('estimateTotalManpower');
            if (totalHoursElement) totalHoursElement.textContent = totalHours.toFixed(1) + 'h';
            if (totalManpowerElement) totalManpowerElement.textContent = `${totalManDays}人日 / ${totalManMonths}人月`;

            // 合計カードにテーマカラーのグラデーションを適用
            const totalCard = document.getElementById('estimateTotalCard');
            if (totalCard) {
                const gradients = {
                    'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                    'teal': 'linear-gradient(135deg, #0f766e 0%, #0d9488 100%)',
                    'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                    'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #075985 100%)',
                    'sky': 'linear-gradient(135deg, #0369a1 0%, #0284c7 100%)',
                    'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                    'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                    'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                    'green': 'linear-gradient(135deg, #047857 0%, #059669 100%)',
                    'emerald': 'linear-gradient(135deg, #059669 0%, #10b981 100%)'
                };
                totalCard.style.background = gradients[currentThemeColor] || gradients['purple'];
            }

            // 担当者別の合計を集計
            const memberSummary = {};
            filteredEstimates.forEach(e => {
                const est = normalizeEstimate(e);
                const member = est.member || '未設定';

                if (!memberSummary[member]) {
                    memberSummary[member] = 0;
                }

                if (filterType === 'version') {
                    // 版数別フィルタの場合は全工数を加算
                    memberSummary[member] += est.hours;
                } else {
                    // 月別フィルタの場合は分割後の工数を使用
                    if (monthFilter === 'all') {
                        memberSummary[member] += est.hours;
                    } else if (est.monthlyHours && est.monthlyHours[monthFilter]) {
                        memberSummary[member] += est.monthlyHours[monthFilter];
                    }
                    // workMonthsが空（作業月未設定）の場合は全工数を含める
                    else if (!est.workMonths || est.workMonths.length === 0) {
                        memberSummary[member] += est.hours;
                    }
                }
            });

            // 担当者別合計を表示
            const memberSummaryContainer = document.getElementById('estimateMemberSummary');
            const memberSummaryContent = document.getElementById('estimateMemberSummaryContent');
            if (memberSummaryContainer && memberSummaryContent) {
                // memberOrderの順序に従ってソート
                const memberSet = new Set(Object.keys(memberSummary));
                let sortedMembers = [];
                const memberOrderElement = document.getElementById('memberOrder');
                const memberOrderInput = memberOrderElement ? memberOrderElement.value.trim() : '';

                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = orderList.filter(m => memberSet.has(m));
                    const unorderedMembers = Array.from(memberSet).filter(m => !orderedMembers.includes(m)).sort();
                    sortedMembers = [...orderedMembers, ...unorderedMembers];
                } else {
                    sortedMembers = Array.from(memberSet).sort();
                }

                if (sortedMembers.length > 0) {
                    memberSummaryContainer.style.display = 'block';
                    // テーマカラーを取得
                    const themeColors = {
                        'purple': '#667eea',
                        'deep-blue': '#1e3c72',
                        'teal': '#0f766e',
                        'cyan': '#0891b2',
                        'ocean': '#0c4a6e',
                        'sky': '#0369a1',
                        'indigo': '#4338ca',
                        'navy': '#1e40af',
                        'slate': '#334155',
                        'green': '#047857',
                        'emerald': '#059669'
                    };
                    const borderColor = themeColors[currentThemeColor] || '#667eea';

                    let memberHtml = '';
                    sortedMembers.forEach(member => {
                        const hours = memberSummary[member];
                        const days = (hours / 8).toFixed(1);
                        const months = (hours / 8 / workingDaysPerMonth).toFixed(2);
                        memberHtml += `
                            <div style="background: white; padding: 10px 15px; border-radius: 6px; border-left: 4px solid ${borderColor}; min-width: 150px;">
                                <div style="font-size: 13px; color: #666; margin-bottom: 3px;">${member}</div>
                                <div style="font-size: 18px; font-weight: 700; color: #333;">${hours.toFixed(1)}h</div>
                                <div style="font-size: 12px; color: #666; font-weight: 500;">${days}人日 / ${months}人月</div>
                            </div>
                        `;
                    });
                    memberSummaryContent.innerHTML = memberHtml;
                } else {
                    memberSummaryContainer.style.display = 'none';
                }
            }

            if (viewType === 'grouped') {
                renderEstimateGrouped();
            } else if (viewType === 'matrix') {
                renderEstimateMatrix();
            } else {
                renderEstimateDetailList();
            }
        }

        // 月の実働日数を計算（土日祝日・会社休日を除く）
        function getWorkingDays(year, month) {
            const lastDay = new Date(year, month, 0).getDate();
            let workingDays = 0;

            for (let day = 1; day <= lastDay; day++) {
                const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const date = new Date(year, month - 1, day);
                const dayOfWeek = date.getDay();
                const isWeekend = (dayOfWeek === 0 || dayOfWeek === 6); // 日曜or土曜
                const holiday = getHoliday(dateStr);
                const companyHol = isCompanyHoliday(dateStr);

                if (!isWeekend && !holiday && !companyHol) {
                    workingDays++;
                }
            }

            return workingDays;
        }
        
        // 現在の年月の実働日数を取得（デフォルト値として使用）
        function getCurrentMonthWorkingDays() {
            const now = new Date();
            return getWorkingDays(now.getFullYear(), now.getMonth() + 1);
        }

        // 実績または見積が「その他付随作業」かどうかを判定
        function isOtherWork(item) {
            const hasVersion = item.version && item.version.trim() !== '';
            const hasTask = item.task && item.task.trim() !== '';
            return !hasVersion || !hasTask;
        }

        // 数値を整数表示（小数点以下が0の場合）または小数表示
        function formatNumber(num, decimals = 1) {
            const rounded = parseFloat(num.toFixed(decimals));
            return rounded % 1 === 0 ? rounded.toFixed(0) : rounded.toFixed(decimals);
        }

        function renderEstimateGrouped() {
            const container = document.getElementById('estimateList');

            // 対応全体の作業月を計算する関数
            function getTaskWorkMonths(version, task) {
                // この対応の全工程を取得
                const taskEstimates = estimates.filter(e => e.version === version && e.task === task);

                // 全工程の作業月を収集（重複なし）
                const allMonths = new Set();
                taskEstimates.forEach(e => {
                    const est = normalizeEstimate(e);
                    if (est.workMonths && est.workMonths.length > 0) {
                        est.workMonths.forEach(month => allMonths.add(month));
                    }
                });

                return Array.from(allMonths).sort();
            }

            // 実働日数を取得（人月計算用）
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const filterTypeElement = document.getElementById('estimateFilterType');
            const workMonthFilter = monthFilterElement ? monthFilterElement.value : 'all';
            const filterType = filterTypeElement ? filterTypeElement.value : 'month';

            let workingDaysPerMonth = 20; // デフォルト
            if (filterType === 'month' && workMonthFilter !== 'all') {
                const [year, month] = workMonthFilter.split('-');
                const calculatedDays = getWorkingDays(parseInt(year), parseInt(month));
                // 0で割るのを防ぐため、最小値を1に設定
                workingDaysPerMonth = calculatedDays > 0 ? calculatedDays : 20;
            }

            // グローバルのfilteredEstimatesを使用（renderEstimateListで設定済み）
            // フィルタ内の工程がない場合
            if (filteredEstimates.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">該当する見積データがありません</p>';
                return;
            }

            // 表示する全ての見積
            const allDisplayEstimates = filteredEstimates;

            // 版数ごとにグループ化
            const versionGroups = {};
            allDisplayEstimates.forEach(e => {
                if (!versionGroups[e.version]) {
                    versionGroups[e.version] = {};
                }
                const taskKey = e.task;
                if (!versionGroups[e.version][taskKey]) {
                    versionGroups[e.version][taskKey] = {
                        task: e.task,
                        processes: []
                    };
                }

                // 月別フィルタで特定月が選択されている場合は分割後の工数を使用
                const est = normalizeEstimate(e);
                let displayHours = e.hours;
                if (filterType === 'month' && workMonthFilter !== 'all' && est.monthlyHours && est.monthlyHours[workMonthFilter]) {
                    displayHours = est.monthlyHours[workMonthFilter];
                }

                versionGroups[e.version][taskKey].processes.push({
                    process: e.process,
                    member: e.member,
                    hours: displayHours,
                    id: e.id
                });
            });

            let html = '<div style="margin-bottom: 30px;">';

            // 換算基準の表示を生成
            let workDaysLabel = 'デフォルト20日';
            if (filterType === 'month' && workMonthFilter !== 'all' && workMonthFilter !== 'unassigned') {
                const [year, month] = workMonthFilter.split('-');
                workDaysLabel = `${year}年${parseInt(month)}月の営業日数（${workingDaysPerMonth}日）`;
            }

            html += `<div style="background: #e3f2fd; padding: 12px 20px; border-radius: 8px; margin-bottom: 20px; font-size: 14px; color: #1565c0;">
                <strong>換算基準:</strong> 1人日 = 8h、1人月 = ${workingDaysPerMonth}人日（${workDaysLabel}）
            </div>`;

            // 版数ごとに表示
            Object.keys(versionGroups).sort().forEach(version => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                html += '<div class="table-wrapper"><table class="estimate-grouped">';

                // 選択モードの場合、選択列を追加
                if (workMonthSelectionMode) {
                    if (estimateEditMode) {
                        html += '<tr><th style="min-width: 50px;">選択</th><th style="min-width: 200px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">工数</th><th style="min-width: 150px;">対応合計</th><th style="min-width: 100px;">操作</th></tr>';
                    } else {
                        html += '<tr><th style="min-width: 50px;">選択</th><th style="min-width: 200px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">工数</th><th style="min-width: 150px;">対応合計</th></tr>';
                    }
                } else {
                    if (estimateEditMode) {
                        html += '<tr><th style="min-width: 200px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">工数</th><th style="min-width: 150px;">対応合計</th><th style="min-width: 100px;">操作</th></tr>';
                    } else {
                        html += '<tr><th style="min-width: 200px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">工数</th><th style="min-width: 150px;">対応合計</th></tr>';
                    }
                }
                
                Object.values(versionGroups[version]).forEach(taskGroup => {
                    const total = taskGroup.processes.reduce((sum, p) => sum + p.hours, 0);
                    const days = total / 8;
                    const months = total / 8 / workingDaysPerMonth;
                    
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];
                    const sortedProcesses = taskGroup.processes.sort((a, b) => 
                        processOrder.indexOf(a.process) - processOrder.indexOf(b.process)
                    );
                    
                    // 対応全体の作業月を計算
                    const taskWorkMonths = getTaskWorkMonths(version, taskGroup.task);

                    // 作業月バッジの生成（レスポンシブ対応）
                    let workMonthBadgeInline = ''; // 広い画面用（1行表示）
                    let workMonthBadgeBlock = ''; // 狭い画面用（改行表示）

                    if (taskWorkMonths.length === 0) {
                        workMonthBadgeInline = ' <span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">未設定</span>';
                        workMonthBadgeBlock = '<div style="margin-top: 4px;"><span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">未設定</span></div>';
                    } else if (taskWorkMonths.length === 1) {
                        const [y, m] = taskWorkMonths[0].split('-');
                        workMonthBadgeInline = ` <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y}年${parseInt(m)}月</span>`;
                        workMonthBadgeBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y}年${parseInt(m)}月</span></div>`;
                    } else {
                        // 複数月の場合
                        const [y1, m1] = taskWorkMonths[0].split('-');
                        const [y2, m2] = taskWorkMonths[taskWorkMonths.length - 1].split('-');
                        // 広い画面用: 1行表示
                        workMonthBadgeInline = ` <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月</span>`;
                        // 狭い画面用: 〜の前で改行可能にするため2つのバッジに分割
                        workMonthBadgeBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">${y1}年${parseInt(m1)}月</span> <span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: normal; white-space: nowrap;">〜${y2}年${parseInt(m2)}月</span></div>`;
                    }
                    
                    // 対応名を「:」または「：」で分割してレスポンシブ表示（祝日と同じ方式）
                    let taskDisplayHtml = taskGroup.task;
                    if (taskGroup.task.includes(':') || taskGroup.task.includes('：')) {
                        // 半角と全角の両方に対応
                        let separator = ':';
                        let parts;
                        
                        if (taskGroup.task.includes(':')) {
                            parts = taskGroup.task.split(':');
                        } else {
                            separator = '：';
                            parts = taskGroup.task.split('：');
                        }
                        
                        const restPart = parts.slice(1).join(separator);
                        // デスクトップ: コロンあり、モバイル: コロンなし
                        taskDisplayHtml = `${parts[0]}<span class="task-separator-inline">${separator} ${restPart}</span><span class="task-separator-break"><br><span style="font-size: 13px; font-weight: normal;">${restPart}</span></span>`;
                    }
                    
                    // 作業月バッジを追加（レスポンシブ対応）
                    taskDisplayHtml += `<span class="work-month-inline">${workMonthBadgeInline}</span><span class="work-month-block">${workMonthBadgeBlock}</span>`;
                    
                    // 対応の全工程が選択されているかチェック
                    const taskIds = taskGroup.processes.map(p => p.id);
                    const allSelected = taskIds.every(id => selectedEstimateIds.has(id));
                    
                    sortedProcesses.forEach((proc, index) => {
                        // この工程の見積データを取得
                        const estimate = estimates.find(e => e.id === proc.id);
                        const est = normalizeEstimate(estimate);
                        
                        // フィルタ外かどうか
                        const isOutOfFilter = proc.isOutOfFilter || false;
                        const grayStyle = isOutOfFilter ? 'opacity: 0.4;' : '';
                        const grayPrefix = isOutOfFilter ? '○ ' : '';
                        
                        // 作業月の表示を生成（レスポンシブ対応）
                        let processWorkMonthInline = ''; // 広い画面用（1行表示）
                        let processWorkMonthBlock = ''; // 狭い画面用（2行表示）
                        
                        if (est.workMonths.length > 0) {
                            if (est.workMonths.length === 1) {
                                const [y, m] = est.workMonths[0].split('-');
                                processWorkMonthInline = `<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px; white-space: nowrap;">${y}年${parseInt(m)}月</span>`;
                                processWorkMonthBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap;">${y}年${parseInt(m)}月</span></div>`;
                            } else {
                                const [y1, m1] = est.workMonths[0].split('-');
                                const [y2, m2] = est.workMonths[est.workMonths.length - 1].split('-');
                                processWorkMonthInline = `<span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px; white-space: nowrap;">${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月</span>`;
                                processWorkMonthBlock = `<div style="margin-top: 4px;"><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap;">${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月</span></div>`;
                            }
                        } else {
                            processWorkMonthInline = `<span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px; white-space: nowrap;">未設定</span>`;
                            processWorkMonthBlock = `<div style="margin-top: 4px;"><span style="background: #dc3545; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; white-space: nowrap;">未設定</span></div>`;
                        }
                        
                        html += '<tr>';
                        
                        // 選択モードの場合、チェックボックスを追加
                        if (workMonthSelectionMode) {
                            if (index === 0) {
                                // 対応名の行: 対応全体の選択チェックボックス（グレーなし）
                                html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; text-align: center; cursor: pointer;" onclick="selectTaskEstimates('${version}', '${taskGroup.task.replace(/'/g, "\\'")}', event)">
                                    <input type="checkbox" ${allSelected ? 'checked' : ''} style="width: auto; cursor: pointer;" onclick="selectTaskEstimates('${version}', '${taskGroup.task.replace(/'/g, "\\'")}', event)">
                                </td>`;
                            }
                        }
                        
                        if (index === 0) {
                            // 対応名（グレーなし）
                            if (estimateEditMode) {
                                html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; font-weight: 600;">
                                    <div style="display: flex; align-items: flex-start; gap: 8px;">
                                        <div style="flex: 1; cursor: pointer; color: #007bff;" onclick="editTask('${version}', '${taskGroup.task.replace(/'/g, "\\'")}')" title="クリックして対応名を編集">${taskDisplayHtml}</div>
                                        <span onclick="deleteTask('${version}', '${taskGroup.task.replace(/'/g, "\\'")}'); event.stopPropagation();" style="cursor: pointer; font-size: 18px; color: #dc3545; flex-shrink: 0;" title="対応ごと削除">🗑️</span>
                                    </div>
                                </td>`;
                            } else {
                                html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; font-weight: 600;">${taskDisplayHtml}</td>`;
                            }
                        }
                        
                        // 選択モードではないときは通常の工程バッジ
                        // 選択モードのときは個別選択チェックボックスを表示
                        if (workMonthSelectionMode) {
                            const isSelected = selectedEstimateIds.has(proc.id);
                            // 工程セル（グレー適用）
                            html += `<td style="cursor: pointer; ${grayStyle}" onclick="toggleEstimateSelection(${proc.id}, event)">
                                <input type="checkbox" ${isSelected ? 'checked' : ''} style="width: auto; margin-right: 6px; cursor: pointer;" onclick="toggleEstimateSelection(${proc.id}, event)">
                                <div>
                                    <span>${grayPrefix}</span><span class="badge badge-${proc.process.toLowerCase()}">${proc.process}</span>
                                    <span class="work-month-inline">${processWorkMonthInline}</span>
                                </div>
                                <div class="work-month-block">${processWorkMonthBlock}</div>
                            </td>`;
                        } else {
                            // 工程セル（グレー適用）
                            html += `<td style="${grayStyle}"><span>${grayPrefix}</span><span class="badge badge-${proc.process.toLowerCase()}">${proc.process}</span></td>`;
                        }
                        
                        // 担当セル（グレー適用）
                        html += `<td style="${grayStyle}">${proc.member}</td>`;
                        // 工数セル（グレー適用）
                        html += `<td style="text-align: right; ${grayStyle}">${proc.hours}h</td>`;
                        
                        if (index === 0) {
                            // 対応合計（グレーなし）
                            html += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; text-align: right;">
                                <div style="font-weight: 700; color: #1976d2; font-size: 16px; margin-bottom: 4px;">${formatNumber(total, 1)}h</div>
                                <div class="manpower-display" style="font-size: 13px; color: #666;">${formatNumber(days, 1)}人日 / ${formatNumber(months, 2)}人月</div>
                            </td>`;
                        }

                        // 操作ボタン（編集モード時のみ表示）
                        if (estimateEditMode) {
                            html += `<td style="text-align: center;">
                                <span onclick="editEstimate(${proc.id})" style="cursor: pointer; font-size: 18px; margin-right: 10px;" title="編集">✏️</span>
                                <span onclick="deleteEstimate(${proc.id})" style="cursor: pointer; font-size: 18px; color: #dc3545;" title="削除">🗑️</span>
                            </td>`;
                        }
                        html += '</tr>';
                    });
                });
                
                // 版数の合計
                const versionTotal = Object.values(versionGroups[version])
                    .reduce((sum, taskGroup) => sum + taskGroup.processes.reduce((s, p) => s + p.hours, 0), 0);
                const versionDays = versionTotal / 8;
                const versionMonths = versionTotal / 8 / workingDaysPerMonth;
                
                html += `<tr style="background: #f5f5f5; font-weight: 700;">`;
                if (workMonthSelectionMode) {
                    html += `<td></td>`;
                }
                html += `<td style="text-align: right; padding-right: 20px;">${version} 合計</td>`;
                html += `<td colspan="2"></td>`;
                html += `<td style="text-align: right;">${formatNumber(versionTotal, 1)}h</td>`;
                html += `<td style="text-align: right;">
                    <div style="font-size: 15px; margin-bottom: 3px;">${formatNumber(versionDays, 1)}人日 / ${formatNumber(versionMonths, 2)}人月</div>
                </td>`;
                if (estimateEditMode) {
                    html += `<td></td>`;
                }
                html += `</tr>`;
                
                html += '</table></div>';
                html += '</div>';
            });
            
            html += '</div>';
            container.innerHTML = html;
        }

        function renderEstimateMatrix() {
            const container = document.getElementById('estimateList');

            // フィルタタイプと月フィルタを取得
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const filterTypeElement = document.getElementById('estimateFilterType');
            const workMonthFilter = monthFilterElement ? monthFilterElement.value : 'all';
            const filterType = filterTypeElement ? filterTypeElement.value : 'month';

            // グローバルのfilteredEstimatesを使用（renderEstimateListで設定済み）

            // 使用されている月を収集（凡例用）
            const usedMonths = new Set();
            let hasMultipleMonths = false;
            let hasUnassigned = false;

            // 版数ごとにグループ化
            const versionGroups = {};
            filteredEstimates.forEach(e => {
                if (!versionGroups[e.version]) {
                    versionGroups[e.version] = {};
                }
                const taskKey = e.task;
                if (!versionGroups[e.version][taskKey]) {
                    versionGroups[e.version][taskKey] = {
                        task: e.task,
                        processes: {}
                    };
                }

                // 月別フィルタで特定月が選択されている場合は分割後の工数を使用
                const est = normalizeEstimate(e);
                let displayHours = e.hours;
                if (filterType === 'month' && workMonthFilter !== 'all' && est.monthlyHours && est.monthlyHours[workMonthFilter]) {
                    displayHours = est.monthlyHours[workMonthFilter];
                }

                // 使用されている月を収集 & 複数月・未設定の判定
                if (est.workMonths && est.workMonths.length > 0) {
                    est.workMonths.forEach(m => usedMonths.add(m));
                    if (est.workMonths.length > 1) {
                        hasMultipleMonths = true;
                    }
                } else {
                    hasUnassigned = true;
                }

                versionGroups[e.version][taskKey].processes[e.process] = {
                    member: e.member,
                    hours: displayHours,
                    id: e.id,
                    workMonths: est.workMonths || []
                };
            });

            const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

            // 設定がオンの時に色付けする
            const showMonthColors = showMonthColorsSetting;

            let html = '<div style="margin-bottom: 30px;">';

            // 月カラー凡例を追加（設定がオンの時のみ）
            if (showMonthColors) {
                html += generateMonthColorLegend(usedMonths, hasMultipleMonths, hasUnassigned);
            }

            // 版数ごとに表示
            Object.keys(versionGroups).sort().forEach(version => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                html += '<div class="table-wrapper"><table class="estimate-matrix">';
                html += '<tr><th style="min-width: 200px;">対応名</th>';
                processOrder.forEach(proc => {
                    html += `<th style="min-width: 100px; text-align: center;">${proc}</th>`;
                });
                html += '<th style="min-width: 80px; text-align: center;">合計</th></tr>';

                Object.values(versionGroups[version]).forEach(group => {
                    // 対応名を「：」（全角コロン）で分割して2行表示
                    let taskDisplayHtml = group.task;
                    if (group.task.includes('：')) {
                        const parts = group.task.split('：');
                        const restPart = parts.slice(1).join('：');
                        taskDisplayHtml = `${parts[0]}<br><span style="font-size: 13px; font-weight: normal;">${restPart}</span>`;
                    }

                    html += '<tr>';
                    if (estimateEditMode) {
                        html += `<td style="font-weight: 600;">
                            <div style="display: flex; align-items: flex-start; gap: 8px;">
                                <div style="flex: 1; cursor: pointer; color: #007bff;" onclick="editTask('${version}', '${group.task.replace(/'/g, "\\'")}')" title="クリックして対応名を編集">${taskDisplayHtml}</div>
                                <span onclick="deleteTask('${version}', '${group.task.replace(/'/g, "\\'")}'); event.stopPropagation();" style="cursor: pointer; font-size: 18px; color: #dc3545; flex-shrink: 0;" title="対応ごと削除">🗑️</span>
                            </div>
                        </td>`;
                    } else {
                        html += `<td style="font-weight: 600;">${taskDisplayHtml}</td>`;
                    }

                    let total = 0;
                    processOrder.forEach(proc => {
                        if (group.processes[proc]) {
                            const p = group.processes[proc];
                            total += p.hours;

                            // 設定がオンの時に月に基づく背景色を適用
                            const monthColor = showMonthColors ? getMonthColor(p.workMonths) : { bg: '', tooltip: '' };
                            const bgStyle = showMonthColors ? `background: ${monthColor.bg};` : '';

                            // 編集モード時はクリック可能なセルにする
                            if (estimateEditMode) {
                                html += `<td style="text-align: center; cursor: pointer; transition: background 0.2s; ${bgStyle}"
                                    onclick="editEstimate(${p.id})"
                                    ${showMonthColors ? `title="${monthColor.tooltip}"` : ''}
                                    onmouseover="this.style.background='#e3f2fd'"
                                    onmouseout="this.style.background='${showMonthColors ? monthColor.bg : ''}'">
                                    <div style="font-weight: 600;">${p.hours.toFixed(1)}h</div>
                                    <div style="font-size: 12px; color: #666;">(${p.member})</div>
                                    <div style="font-size: 10px; color: #1976d2; margin-top: 2px;">✏️ 編集</div>
                                </td>`;
                            } else {
                                html += `<td style="text-align: center; ${bgStyle}" ${showMonthColors ? `title="${monthColor.tooltip}"` : ''}>
                                    <div style="font-weight: 600;">${p.hours.toFixed(1)}h</div>
                                    <div style="font-size: 12px; color: #666;">(${p.member})</div>
                                </td>`;
                            }
                        } else {
                            html += `<td style="text-align: center; color: #ccc;">-</td>`;
                        }
                    });

                    // 人日・人月を計算
                    const totalDays = total / 8;
                    const totalMonths = totalDays / 20;

                    html += `<td style="text-align: center;">
                        <div style="font-weight: 700; color: #1976d2;">${total.toFixed(1)}h</div>
                        <div style="font-size: 11px; color: #666;">${totalDays.toFixed(1)}人日</div>
                        <div style="font-size: 11px; color: #666;">${totalMonths.toFixed(2)}人月</div>
                    </td>`;
                    html += '</tr>';
                });

                html += '</table></div>';
                html += '</div>';
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function renderEstimateDetailList() {
            const container = document.getElementById('estimateList');

            // フィルタタイプと月フィルタを取得
            const monthFilterElement = document.getElementById('estimateMonthFilter');
            const filterTypeElement = document.getElementById('estimateFilterType');
            const workMonthFilter = monthFilterElement ? monthFilterElement.value : 'all';
            const filterType = filterTypeElement ? filterTypeElement.value : 'month';

            // グローバルのfilteredEstimatesを使用（renderEstimateListで設定済み）

            let html = '<div class="table-wrapper"><table><tr><th>版数</th><th>対応名</th><th>工程</th><th>担当</th><th>見積工数</th><th>作業予定月</th><th>操作</th></tr>';

            filteredEstimates.forEach(e => {
                const est = normalizeEstimate(e);

                // 月別フィルタで特定月が選択されている場合は分割後の工数を表示
                let displayHours = est.hours;
                if (filterType === 'month' && workMonthFilter !== 'all' && est.monthlyHours[workMonthFilter]) {
                    displayHours = est.monthlyHours[workMonthFilter];
                }
                
                // 作業予定月の表示
                let workMonthDisplay = '-';
                if (est.workMonths.length > 0) {
                    if (est.workMonths.length === 1) {
                        const [y, m] = est.workMonths[0].split('-');
                        workMonthDisplay = `${y}年${parseInt(m)}月`;
                    } else {
                        const [y1, m1] = est.workMonths[0].split('-');
                        const [y2, m2] = est.workMonths[est.workMonths.length - 1].split('-');
                        workMonthDisplay = `${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月`;
                        // 月別内訳を表示
                        workMonthDisplay += '<br><small style="color: #666;">';
                        est.workMonths.forEach((month, idx) => {
                            const [y, m] = month.split('-');
                            const hours = est.monthlyHours[month] || 0;
                            if (idx > 0) workMonthDisplay += ', ';
                            workMonthDisplay += `${y}年${parseInt(m)}月:${hours.toFixed(1)}h`;
                        });
                        workMonthDisplay += '</small>';
                    }
                }
                
                html += `
                    <tr>
                        <td>${est.version}</td>
                        <td>${est.task}</td>
                        <td><span class="badge badge-${est.process.toLowerCase()}">${est.process}</span></td>
                        <td>${est.member}</td>
                        <td>${displayHours.toFixed(1)}h</td>
                        <td>${workMonthDisplay}</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editEstimate(${est.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-small" onclick="openSplitEstimateModal(${est.id})" style="margin-right: 5px; background: #3498db; color: white;">分割</button>
                            <button class="btn btn-danger btn-small" onclick="deleteEstimate(${est.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        function renderActualList() {
            const container = document.getElementById('actualList');
            const viewType = document.getElementById('actualViewType').value;
            const viewMode = document.getElementById('actualViewMode').value;

            // 担当者別モード時は担当者選択を表示（両方のレイアウトを同期）
            const memberSelectGroup = document.getElementById('memberSelectGroup');
            const memberSelectGroup2 = document.getElementById('memberSelectGroup2');
            if (viewMode === 'member') {
                memberSelectGroup.style.display = 'flex';
                if (memberSelectGroup2) memberSelectGroup2.style.display = 'flex';
                updateMemberSelectOptions();
            } else {
                memberSelectGroup.style.display = 'none';
                if (memberSelectGroup2) memberSelectGroup2.style.display = 'none';
            }
            
            if (actuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">実績データがありません</p>';
                return;
            }

            if (viewType === 'matrix') {
                if (viewMode === 'member') {
                    renderMemberCalendar();
                } else {
                    renderActualMatrix();
                }
            } else {
                renderActualListView();
            }
        }

        function updateMemberSelectOptions() {
            const select = document.getElementById('actualMemberSelect');
            const select2 = document.getElementById('actualMemberSelect2');
            const currentValue = select.value;

            // 担当者を抽出
            const allMembers = new Set();
            actuals.forEach(a => allMembers.add(a.member));
            estimates.forEach(e => allMembers.add(e.member));

            // 表示順でソート
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];

                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });

                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });

                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(allMembers).sort();
            }

            // 両方のセレクトボックスを更新
            select.innerHTML = '';
            if (select2) select2.innerHTML = '';

            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                select.appendChild(option);

                if (select2) {
                    const option2 = document.createElement('option');
                    option2.value = member;
                    option2.textContent = member;
                    select2.appendChild(option2);
                }
            });

            // 以前の選択を復元
            if (currentValue && sortedMembers.includes(currentValue)) {
                select.value = currentValue;
                if (select2) select2.value = currentValue;
            } else if (sortedMembers.length > 0) {
                select.value = sortedMembers[0];
                if (select2) select2.value = sortedMembers[0];
            }

            // セグメントボタン版を生成（実績一覧セグメントレイアウト用）
            const items = sortedMembers.map(member => ({
                value: member,
                label: member
            }));
            const selectedValue = select.value;
            createSegmentButtons(
                'actualMemberButtons2',
                'actualMemberSelect2',
                items,
                selectedValue,
                6, // 最大6個までセグメントボタン表示
                handleActualMemberChange
            );
        }

        function renderMemberCalendar() {
            const container = document.getElementById('actualList');
            const selectedMonth = document.getElementById('actualMonthFilter').value;
            const selectedMember = document.getElementById('actualMemberSelect').value;
            
            if (!selectedMember) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">担当者を選択してください</p>';
                return;
            }
            
            // 担当者と月でフィルタリング
            let filteredActuals = actuals.filter(a => a.member === selectedMember);
            if (selectedMonth !== 'all') {
                filteredActuals = filteredActuals.filter(a => a.date && a.date.startsWith(selectedMonth));
            }
            
            if (filteredActuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した期間に実績データがありません</p>';
                return;
            }
            
            // 日付範囲を計算
            const dates = filteredActuals.map(a => a.date).sort();
            let startDate, endDate;
            
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                const yearNum = parseInt(year);
                const monthNum = parseInt(month);
                
                startDate = `${year}-${month}-01`;
                const lastDay = new Date(yearNum, monthNum, 0).getDate();
                endDate = `${year}-${month}-${String(lastDay).padStart(2, '0')}`;
            } else {
                const [minYear, minMonth] = dates[0].split('-');
                const [maxYear, maxMonth] = dates[dates.length - 1].split('-');
                
                startDate = `${minYear}-${minMonth}-01`;
                const lastDay = new Date(parseInt(maxYear), parseInt(maxMonth), 0).getDate();
                endDate = `${maxYear}-${maxMonth}-${String(lastDay).padStart(2, '0')}`;
            }
            
            // 日付リスト生成
            const allDates = [];
            let currentDateStr = startDate;
            while (currentDateStr <= endDate) {
                allDates.push(currentDateStr);
                const [y, m, d] = currentDateStr.split('-').map(Number);
                const nextDate = new Date(y, m - 1, d + 1);
                currentDateStr = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}-${String(nextDate.getDate()).padStart(2, '0')}`;
            }
            
            // 合計情報
            const totalHours = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
            const workedDays = new Set(filteredActuals.map(a => a.date)).size;
            
            let html = `<h3 style="margin-bottom: 10px;">${selectedMember}の実績カレンダー</h3>`;
            
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                html += `<div style="margin-bottom: 15px;">
                    <p style="margin: 0 0 5px 0; font-weight: 600;">${year}年${parseInt(month)}月の合計</p>
                    <p style="margin: 0; color: #666; font-size: 14px;">稼働日数: ${workedDays}日 / 合計工数: ${totalHours.toFixed(1)}h</p>
                </div>`;
            }
            
            html += '<div id="calendarTableWrapper" class="table-wrapper" style="overflow-x: auto;"><table style="min-width: 100%;">';
            html += '<tr><th style="min-width: 120px;">日付</th><th style="min-width: 300px;">作業内容</th><th style="min-width: 80px;">工数</th></tr>';
            
            allDates.forEach(date => {
                const dateObj = new Date(date);
                const dayOfWeek = getDayOfWeek(date);
                const holiday = getHoliday(date);
                const isWeekend = dayOfWeek === '土' || dayOfWeek === '日';
                const isHoliday = holiday !== null;
                
                const dayActuals = filteredActuals.filter(a => a.date === date);
                const dayTotal = dayActuals.reduce((sum, a) => sum + a.hours, 0);
                
                const bgColor = (isWeekend || isHoliday) ? '#ffebee' : 'white';
                const dateColor = (isWeekend || isHoliday) ? 'color: #c62828;' : '';
                
                const [year, m, day] = date.split('-');
                // 祝日の場合、クラスで制御して画面幅に応じて表示を変える
                const dateDisplay = isHoliday 
                    ? `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})<span class="holiday-inline"> ${holiday}</span><span class="holiday-break"><br><span style="font-size: 11px; font-weight: normal;">${holiday}</span></span>`
                    : `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})`;
                
                if (dayActuals.length === 0) {
                    html += `<tr style="background: ${bgColor};">`;
                    html += `<td style="font-weight: 500; ${dateColor}">${dateDisplay}</td>`;
                    html += `<td style="color: #999;">-</td>`;
                    html += `<td style="text-align: center; color: #999;">-</td>`;
                    html += `</tr>`;
                } else {
                    dayActuals.forEach((actual, index) => {
                        if (index === 0) {
                            html += `<tr style="background: ${bgColor};">`;
                            html += `<td rowspan="${dayActuals.length}" style="font-weight: 500; ${dateColor} vertical-align: top; padding-top: 12px;">${dateDisplay}</td>`;
                        } else {
                            html += `<tr style="background: ${bgColor};">`;
                        }
                        // HTMLエスケープ関数
                        const escapeHtml = (str) => {
                            const div = document.createElement('div');
                            div.textContent = str;
                            return div.innerHTML;
                        };
                        html += `<td style="font-size: 14px;">${escapeHtml(actual.version)} - ${escapeHtml(actual.task)} [${actual.process}]</td>`;
                        html += `<td style="text-align: center; font-weight: 600;">${actual.hours}h</td>`;
                        html += `</tr>`;
                    });
                }
            });
            
            // 総合計行
            html += `<tr style="background: #1565c0; color: white; font-weight: 700;">`;
            html += `<td>総合計</td>`;
            html += `<td style="text-align: right;">${workedDays}日稼働</td>`;
            html += `<td style="text-align: center;">${totalHours.toFixed(1)}h</td>`;
            html += `</tr>`;
            
            html += '</table></div>';
            container.innerHTML = html;

            // スワイプで月切り替え機能を設定
            setupCalendarSwipe();
        }

        // カレンダースワイプ機能のセットアップ
        function setupCalendarSwipe() {
            const wrapper = document.getElementById('calendarTableWrapper');
            if (!wrapper) return;

            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            wrapper.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            wrapper.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleCalendarSwipe();
            }, { passive: true });

            function handleCalendarSwipe() {
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;

                // 横スワイプが縦スワイプより大きく、かつ50px以上の場合のみ反応
                if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 50) {
                    const monthSelect = document.getElementById('actualMonthFilter');
                    const monthSelect2 = document.getElementById('actualMonthFilter2');
                    const currentIndex = monthSelect.selectedIndex;

                    if (diffX > 0) {
                        // 右スワイプ → 過去の月へ
                        if (currentIndex < monthSelect.options.length - 1) {
                            monthSelect.selectedIndex = currentIndex + 1;
                            const newValue = monthSelect.value;
                            if (monthSelect2) monthSelect2.value = newValue;
                            updateSegmentButtonSelection('actualMonthButtons2', newValue);
                            monthSelect.dispatchEvent(new Event('change'));
                        }
                    } else {
                        // 左スワイプ → 未来の月へ
                        // インデックス1が最新月なので、それより小さくならないようにする
                        if (currentIndex > 1) {
                            monthSelect.selectedIndex = currentIndex - 1;
                            const newValue = monthSelect.value;
                            if (monthSelect2) monthSelect2.value = newValue;
                            updateSegmentButtonSelection('actualMonthButtons2', newValue);
                            monthSelect.dispatchEvent(new Event('change'));
                        }
                    }
                }
            }
        }

        function renderActualMatrix() {
            const container = document.getElementById('actualList');
            const selectedMonth = document.getElementById('actualMonthFilter').value;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            
            // 月でフィルタリング
            let filteredActuals = actuals;
            if (selectedMonth !== 'all') {
                filteredActuals = actuals.filter(a => a.date && a.date.startsWith(selectedMonth));
            }
            
            if (filteredActuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した期間に実績データがありません</p>';
                return;
            }
            
            // 担当者を抽出して並び替え
            let members = [...new Set(filteredActuals.map(a => a.member))];
            
            // 表示順が指定されている場合
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                // 指定された順序で追加
                orderList.forEach(name => {
                    if (members.includes(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                // 指定されていない担当者を後ろに追加
                members.forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                members = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                members.sort();
            }
            
            // 実績データの日付範囲を取得
            const dates = filteredActuals.map(a => a.date).sort();
            
            // 表示範囲を決定
            let startDate, endDate;
            if (selectedMonth !== 'all') {
                // 選択した月のみ（月初から月末まで正確に）
                const [year, month] = selectedMonth.split('-');
                const yearNum = parseInt(year);
                const monthNum = parseInt(month);
                
                // 月の最初の日
                startDate = `${year}-${month}-01`;
                
                // 月の最後の日を計算
                const lastDay = new Date(yearNum, monthNum, 0).getDate();
                endDate = `${year}-${month}-${String(lastDay).padStart(2, '0')}`;
            } else {
                // 全期間（最小日付の月初から最大日付の月末まで）
                const minDate = dates[0];
                const maxDate = dates[dates.length - 1];
                
                const [minYear, minMonth] = minDate.split('-');
                const [maxYear, maxMonth] = maxDate.split('-');
                
                startDate = `${minYear}-${minMonth}-01`;
                
                const lastDay = new Date(parseInt(maxYear), parseInt(maxMonth), 0).getDate();
                endDate = `${maxYear}-${maxMonth}-${String(lastDay).padStart(2, '0')}`;
            }
            
            // 日付範囲を生成
            const allDates = [];
            let currentDateStr = startDate;
            while (currentDateStr <= endDate) {
                allDates.push(currentDateStr);
                
                // 次の日付を計算
                const [y, m, d] = currentDateStr.split('-').map(Number);
                const nextDate = new Date(y, m - 1, d + 1);
                currentDateStr = `${nextDate.getFullYear()}-${String(nextDate.getMonth() + 1).padStart(2, '0')}-${String(nextDate.getDate()).padStart(2, '0')}`;
            }
            
            let html = '';
            
            // 月の合計を最上部に表示（月選択時のみ）
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                
                // 稼働日数を計算（実績が入力されている日数）
                const workedDays = new Set(filteredActuals.map(a => a.date)).size;
                
                html += `<div style="margin-bottom: 15px;">
                    <h3 style="margin: 0 0 5px 0;">${year}年${parseInt(month)}月の合計</h3>
                    <p style="margin: 0 0 10px 0; color: #666; font-size: 14px;">稼働日数: ${workedDays}日</p>
                </div>`;
                
                // 同じtable-wrapper内に合計表を配置
                html += '<div id="calendarTableWrapper" class="table-wrapper"><table class="actual-matrix">';

                // 合計行（濃い青色）
                html += '<tr style="background: #1565c0; color: white; font-weight: 700;"><th style="min-width: 100px;">総合計</th>';
                
                let monthGrandTotal = 0;
                members.forEach(member => {
                    const memberTotal = filteredActuals.filter(a => a.member === member).reduce((sum, a) => sum + a.hours, 0);
                    monthGrandTotal += memberTotal;
                    html += `<th style="text-align: center; min-width: 80px;">${memberTotal.toFixed(1)}h</th>`;
                });
                
                html += `<th class="daily-total" style="background: #ff9800; text-align: center; min-width: 80px;">${monthGrandTotal.toFixed(1)}h</th>`;
                html += '</tr>';
                
                // ヘッダー行（通常の色）
                html += '<tr><th style="min-width: 100px;">日付</th>';
                
                // 担当者ヘッダー
                members.forEach(member => {
                    html += `<th style="min-width: 80px; text-align: center;">${member}</th>`;
                });
                html += '<th class="daily-total" style="min-width: 80px; text-align: center;">日別合計</th></tr>';
            } else {
                // 全期間表示の場合は通常通りヘッダーのみ
                html += '<div id="calendarTableWrapper" class="table-wrapper"><table class="actual-matrix">';
                html += '<tr><th style="min-width: 100px;">日付</th>';
                
                // 担当者ヘッダー
                members.forEach(member => {
                    html += `<th style="min-width: 80px; text-align: center;">${member}</th>`;
                });
                html += '<th class="daily-total" style="min-width: 80px; text-align: center;">日別合計</th></tr>';
            }
            
            let currentMonth = '';
            let monthTotals = {};
            members.forEach(m => monthTotals[m] = 0);
            let monthTotal = 0;
            
            // 日付ごとの行
            allDates.forEach(date => {
                const dateObj = new Date(date);
                const month = `${dateObj.getFullYear()}年${dateObj.getMonth() + 1}月`;
                const dayOfWeek = getDayOfWeek(date);
                const isWeekend = dayOfWeek === '土' || dayOfWeek === '日';
                
                // 祝日判定
                const holiday = getHoliday(date);
                const isHoliday = holiday !== null;
                
                // 月が変わったら月次小計行を挿入（全期間表示時のみ）
                if (selectedMonth === 'all' && currentMonth && currentMonth !== month) {
                    html += '<tr style="background: #fff3cd; font-weight: 600;">';
                    html += `<td>${currentMonth} 小計</td>`;
                    members.forEach(member => {
                        html += `<td style="text-align: center;">${monthTotals[member].toFixed(1)}h</td>`;
                    });
                    html += `<td class="daily-total" style="background: #ffc107; color: white; text-align: center;">${monthTotal.toFixed(1)}h</td>`;
                    html += '</tr>';
                    
                    // リセット
                    members.forEach(m => monthTotals[m] = 0);
                    monthTotal = 0;
                }
                
                currentMonth = month;

                // 会社休日判定
                const companyHolidayName = getCompanyHolidayName(date);
                const isCompanyHol = companyHolidayName !== null;

                // 日付行（祝日・会社休日・週末）
                let bgColor = 'white';
                if (isWeekend || isHoliday) {
                    bgColor = '#ffebee';
                } else if (isCompanyHol) {
                    bgColor = '#fff9c4';
                }
                html += `<tr style="background: ${bgColor};">`;

                // 日付セル
                const [year, m, day] = date.split('-');
                let dateColor = '';
                let dateDisplay = '';

                if (isHoliday) {
                    dateColor = 'color: #c62828;';
                    dateDisplay = `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})<span class="holiday-inline"> ${holiday}</span><span class="holiday-break"><br><span style="font-size: 11px; font-weight: normal;">${holiday}</span></span>`;
                } else if (isCompanyHol) {
                    dateColor = 'color: #f57c00;';
                    dateDisplay = `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})<span class="holiday-inline"> ${companyHolidayName}</span><span class="holiday-break"><br><span style="font-size: 11px; font-weight: normal;">${companyHolidayName}</span></span>`;
                } else if (isWeekend) {
                    dateColor = 'color: #c62828;';
                    dateDisplay = `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})`;
                } else {
                    dateDisplay = `${parseInt(m)}/${parseInt(day)} (${dayOfWeek})`;
                }

                html += `<td style="font-weight: 500; ${dateColor}">
                    ${dateDisplay}
                </td>`;
                
                let dayTotal = 0;
                
                // 担当者ごとのセル
                members.forEach(member => {
                    const dayActuals = filteredActuals.filter(a => a.member === member && a.date === date);
                    const memberDayTotal = dayActuals.reduce((sum, a) => sum + a.hours, 0);
                    const memberVacations = getVacation(member, date);

                    dayTotal += memberDayTotal;
                    monthTotals[member] += memberDayTotal;

                    let cellContent = '';
                    let bgColor = '#fafafa';
                    let onclick = `addActualFromCalendar('${member}', '${date}')`;
                    let title = '実績を登録';

                    if (memberDayTotal > 0) {
                        bgColor = '#e3f2fd';
                        onclick = `showWorkDetail('${member}', '${date}')`;
                        cellContent = `<strong>${memberDayTotal.toFixed(1)}</strong>`;
                        title = '';
                    } else if (memberVacations.length > 0) {
                        bgColor = '#fff3e0';
                        onclick = `showWorkDetail('${member}', '${date}')`;
                        const vacationLabels = memberVacations.map(v => v.vacationType).join(',');
                        const totalVacationHours = memberVacations.reduce((sum, v) => sum + v.hours, 0);
                        cellContent = `<span style="color: #f57c00; font-weight: 600;">${vacationLabels}</span>`;
                        if (totalVacationHours < 8) {
                            cellContent += `<br><span style="font-size: 10px; color: #666;">${totalVacationHours}h</span>`;
                        }
                        title = '休暇';
                    } else {
                        cellContent = '<span style="color: #ccc;">-</span>';
                    }

                    html += `<td style="background: ${bgColor}; text-align: center; cursor: pointer;"
                                onclick="${onclick}" title="${title}">
                        ${cellContent}
                    </td>`;
                });
                
                monthTotal += dayTotal;
                
                // 日別合計
                if (dayTotal > 0) {
                    html += `<td class="daily-total" style="font-weight: 700; background: #fff3cd; text-align: center;">${dayTotal.toFixed(1)}h</td>`;
                } else {
                    html += `<td class="daily-total" style="background: #fafafa; text-align: center; color: #ccc;">-</td>`;
                }
                
                html += '</tr>';
            });
            
            // 最後の月の小計（全期間表示時のみ）
            if (selectedMonth === 'all' && currentMonth) {
                html += '<tr style="background: #fff3cd; font-weight: 600;">';
                html += `<td>${currentMonth} 小計</td>`;
                members.forEach(member => {
                    html += `<td style="text-align: center;">${monthTotals[member].toFixed(1)}h</td>`;
                });
                html += `<td style="background: #ffc107; color: white; text-align: center;">${monthTotal.toFixed(1)}h</td>`;
                html += '</tr>';
            }
            
            // 全期間の合計行
            html += '<tr style="background: #2c3e50; color: white; font-weight: 700;">';
            html += '<td>総合計</td>';
            let grandTotal = 0;
            
            members.forEach(member => {
                const memberTotal = filteredActuals.filter(a => a.member === member).reduce((sum, a) => sum + a.hours, 0);
                grandTotal += memberTotal;
                html += `<td style="text-align: center;">${memberTotal.toFixed(1)}h</td>`;
            });
            
            html += `<td class="daily-total" style="background: #ffc107; text-align: center;">${grandTotal.toFixed(1)}h</td>`;
            html += '</tr>';
            
            html += '</table></div>';

            container.innerHTML = html;

            // スワイプで月切り替え機能を設定
            setupCalendarSwipe();
        }


        function renderActualListView() {
            const container = document.getElementById('actualList');
            const viewMode = document.getElementById('actualViewMode').value;
            const selectedMonth = document.getElementById('actualMonthFilter').value;
            
            // フィルタリング処理
            let filteredActuals = actuals;
            
            // 担当者別モードの場合
            if (viewMode === 'member') {
                const selectedMember = document.getElementById('actualMemberSelect').value;
                if (selectedMember) {
                    filteredActuals = filteredActuals.filter(a => a.member === selectedMember);
                }
            }
            
            // 月でフィルタリング
            if (selectedMonth !== 'all') {
                filteredActuals = filteredActuals.filter(a => a.date && a.date.startsWith(selectedMonth));
            }
            
            let html = '<div class="table-wrapper"><table><tr><th>日付</th><th>版数</th><th>対応名</th><th>工程</th><th>担当</th><th>実績工数</th><th>操作</th></tr>';
            
            const sortedActuals = [...filteredActuals].sort((a, b) => new Date(b.date) - new Date(a.date));
            
            if (sortedActuals.length === 0) {
                container.innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">選択した条件に該当する実績データがありません</p>';
                return;
            }
            
            sortedActuals.forEach(a => {
                html += `
                    <tr>
                        <td>${a.date}</td>
                        <td>${a.version}</td>
                        <td>${a.task}</td>
                        <td><span class="badge badge-${a.process.toLowerCase()}">${a.process}</span></td>
                        <td>${a.member}</td>
                        <td>${a.hours}h</td>
                        <td>
                            <button class="btn btn-primary btn-small" onclick="editActual(${a.id})" style="margin-right: 5px;">編集</button>
                            <button class="btn btn-danger btn-small" onclick="deleteActual(${a.id})">削除</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</table></div>';
            container.innerHTML = html;
        }

        function getDayOfWeek(dateStr) {
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            const date = new Date(dateStr);
            return days[date.getDay()];
        }

        function getHoliday(dateStr) {
            // @holiday-jp/holiday_jp ライブラリを使用
            if (typeof holiday_jp !== 'undefined' && typeof holiday_jp.isHoliday === 'function') {
                try {
                    const date = new Date(dateStr + 'T00:00:00');
                    const holiday = holiday_jp.isHoliday(date);
                    if (holiday) {
                        // holiday.name が祝日名
                        return holiday.name || holiday;
                    }
                } catch (error) {
                    console.error('Holiday check error:', error);
                }
            }
            
            // フォールバック: 主要な祝日のみ対応（2025-2030年）
            const holidays = {
                // 2025年
                '2025-01-01': '元日',
                '2025-01-13': '成人の日',
                '2025-02-11': '建国記念の日',
                '2025-02-23': '天皇誕生日',
                '2025-02-24': '振替休日',
                '2025-03-20': '春分の日',
                '2025-04-29': '昭和の日',
                '2025-05-03': '憲法記念日',
                '2025-05-04': 'みどりの日',
                '2025-05-05': 'こどもの日',
                '2025-05-06': '振替休日',
                '2025-07-21': '海の日',
                '2025-08-11': '山の日',
                '2025-09-15': '敬老の日',
                '2025-09-23': '秋分の日',
                '2025-10-13': 'スポーツの日',
                '2025-11-03': '文化の日',
                '2025-11-23': '勤労感謝の日',
                '2025-11-24': '振替休日',
                // 2026年
                '2026-01-01': '元日',
                '2026-01-12': '成人の日',
                '2026-02-11': '建国記念の日',
                '2026-02-23': '天皇誕生日',
                '2026-03-20': '春分の日',
                '2026-04-29': '昭和の日',
                '2026-05-03': '憲法記念日',
                '2026-05-04': 'みどりの日',
                '2026-05-05': 'こどもの日',
                '2026-05-06': '振替休日',
                '2026-07-20': '海の日',
                '2026-08-11': '山の日',
                '2026-09-21': '敬老の日',
                '2026-09-22': '秋分の日',
                '2026-10-12': 'スポーツの日',
                '2026-11-03': '文化の日',
                '2026-11-23': '勤労感謝の日',
                '2026-12-23': '天皇誕生日',
                // 2027年
                '2027-01-01': '元日',
                '2027-01-11': '成人の日',
                '2027-02-11': '建国記念の日',
                '2027-02-23': '天皇誕生日',
                '2027-03-21': '春分の日',
                '2027-03-22': '振替休日',
                '2027-04-29': '昭和の日',
                '2027-05-03': '憲法記念日',
                '2027-05-04': 'みどりの日',
                '2027-05-05': 'こどもの日',
                '2027-07-19': '海の日',
                '2027-08-11': '山の日',
                '2027-09-20': '敬老の日',
                '2027-09-23': '秋分の日',
                '2027-10-11': 'スポーツの日',
                '2027-11-03': '文化の日',
                '2027-11-23': '勤労感謝の日',
                '2027-12-23': '天皇誕生日',
                // 2028年
                '2028-01-01': '元日',
                '2028-01-10': '成人の日',
                '2028-02-11': '建国記念の日',
                '2028-02-23': '天皇誕生日',
                '2028-03-20': '春分の日',
                '2028-04-29': '昭和の日',
                '2028-05-03': '憲法記念日',
                '2028-05-04': 'みどりの日',
                '2028-05-05': 'こどもの日',
                '2028-07-17': '海の日',
                '2028-08-11': '山の日',
                '2028-09-18': '敬老の日',
                '2028-09-22': '秋分の日',
                '2028-10-09': 'スポーツの日',
                '2028-11-03': '文化の日',
                '2028-11-23': '勤労感謝の日',
                '2028-12-23': '天皇誕生日',
                // 2029年
                '2029-01-01': '元日',
                '2029-01-08': '成人の日',
                '2029-02-11': '建国記念の日',
                '2029-02-12': '振替休日',
                '2029-02-23': '天皇誕生日',
                '2029-03-20': '春分の日',
                '2029-04-29': '昭和の日',
                '2029-04-30': '振替休日',
                '2029-05-03': '憲法記念日',
                '2029-05-04': 'みどりの日',
                '2029-05-05': 'こどもの日',
                '2029-07-16': '海の日',
                '2029-08-11': '山の日',
                '2029-09-17': '敬老の日',
                '2029-09-23': '秋分の日',
                '2029-09-24': '振替休日',
                '2029-10-08': 'スポーツの日',
                '2029-11-03': '文化の日',
                '2029-11-23': '勤労感謝の日',
                '2029-12-23': '天皇誕生日',
                '2029-12-24': '振替休日',
                // 2030年
                '2030-01-01': '元日',
                '2030-01-14': '成人の日',
                '2030-02-11': '建国記念の日',
                '2030-02-23': '天皇誕生日',
                '2030-03-20': '春分の日',
                '2030-04-29': '昭和の日',
                '2030-05-03': '憲法記念日',
                '2030-05-04': 'みどりの日',
                '2030-05-05': 'こどもの日',
                '2030-05-06': '振替休日',
                '2030-07-15': '海の日',
                '2030-08-11': '山の日',
                '2030-08-12': '振替休日',
                '2030-09-16': '敬老の日',
                '2030-09-23': '秋分の日',
                '2030-10-14': 'スポーツの日',
                '2030-11-03': '文化の日',
                '2030-11-04': '振替休日',
                '2030-11-23': '勤労感謝の日',
                '2030-12-23': '天皇誕生日'
            };
            
            return holidays[dateStr] || null;
        }

        function showWorkDetail(member, date) {
            const dayActuals = actuals.filter(a => a.member === member && a.date === date);
            const memberVacations = getVacation(member, date);

            if (dayActuals.length === 0 && memberVacations.length === 0) return;

            const dateObj = new Date(date);
            const [year, month, day] = date.split('-');
            const dayOfWeek = getDayOfWeek(date);

            // モーダルタイトル
            document.getElementById('modalTitle').textContent =
                `${member}さんの作業 - ${year}年${parseInt(month)}月${parseInt(day)}日(${dayOfWeek})`;

            // モーダル本文
            let html = '';
            const totalHours = dayActuals.reduce((sum, a) => sum + a.hours, 0);

            // 休暇情報を表示
            if (memberVacations.length > 0) {
                html += '<div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #f57c00;">';
                html += '<div style="font-weight: 600; color: #f57c00; margin-bottom: 10px;">🏖️ 休暇</div>';
                memberVacations.forEach(vacation => {
                    html += `
                        <div style="margin-bottom: 8px; padding: 10px; background: white; border-radius: 4px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>${vacation.vacationType}</strong>
                                    <span style="color: #666; font-size: 14px; margin-left: 10px;">${vacation.hours}h</span>
                                </div>
                                <button onclick="deleteVacationFromModal(${vacation.id}, '${member}', '${date}')" style="background: none; border: none; color: #95a5a6; cursor: pointer; font-size: 12px; padding: 4px 8px; text-decoration: underline;">削除</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
            }
            
            dayActuals.forEach(actual => {
                html += `
                    <div class="work-item">
                        <div class="work-item-header">
                            <div class="work-item-title">${actual.task}</div>
                            <div class="work-item-hours">${actual.hours}h</div>
                        </div>
                        <div class="work-item-details">
                            <span><strong>版数:</strong> ${actual.version || '(なし)'}</span>
                            <span><strong>工程:</strong> ${actual.process ? `<span class="badge badge-${actual.process.toLowerCase()}">${actual.process}</span>` : '(なし)'}</span>
                        </div>
                        <div style="margin-top: 8px; text-align: right;">
                            <button onclick="editActualFromModal(${actual.id})" style="background: none; border: none; color: #3498db; cursor: pointer; font-size: 12px; padding: 4px 8px; text-decoration: underline;">編集</button>
                            <button onclick="deleteActualFromModal(${actual.id}, '${member}', '${date}')" style="background: none; border: none; color: #95a5a6; cursor: pointer; font-size: 12px; padding: 4px 8px; text-decoration: underline;">削除</button>
                        </div>
                    </div>
                `;
            });
            
            html += `
                <div style="margin-top: 20px; padding-top: 15px; border-top: 2px solid #eee; text-align: right;">
                    <strong style="font-size: 16px;">合計: ${totalHours.toFixed(1)}時間</strong>
                    <span style="color: #666; font-size: 14px; margin-left: 10px;">(${dayActuals.length}件)</span>
                </div>
                <div style="margin-top: 15px; text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="addActualFromCalendar('${member}', '${date}'); closeWorkModal();"
                            style="padding: 10px 20px; background: #4caf50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                        + 新しい実績を追加
                    </button>
                    <button onclick="addVacationFromCalendar('${member}', '${date}'); closeWorkModal();"
                            style="padding: 10px 20px; background: #f57c00; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;">
                        + 休暇を追加
                    </button>
                </div>
            `;

            document.getElementById('modalBody').innerHTML = html;
            document.getElementById('workModal').style.display = 'flex';
        }

        function closeWorkModal() {
            document.getElementById('workModal').style.display = 'none';
        }
        
        // カレンダーから実績を新規登録
        function addActualFromCalendar(member, date) {
            // 実績編集モーダルを開く（新規登録モード）
            document.getElementById('editActualId').value = '';
            document.getElementById('editActualDate').value = date;

            // 前回の実績を取得
            const previousActual = getPreviousActual(member, date);

            // 版数のデフォルト設定
            const versionSelect = document.getElementById('editActualVersion');
            if (previousActual) {
                // 前回の実績の版数を選択
                versionSelect.value = previousActual.version;
            } else {
                // 前回の実績がない場合は最新のものにデフォルト設定
                // options[0]="-- 版数を選択 --", options[1]="+ 新しい版数を追加...", 以降が実際の版数
                if (versionSelect.options.length > 2) {
                    versionSelect.value = versionSelect.options[versionSelect.options.length - 1].value;
                } else {
                    versionSelect.value = '';
                }
            }

            // 対応名のselect/inputを初期化
            document.getElementById('editActualTaskSelect').style.display = 'block';
            document.getElementById('editActualTaskSelect').value = '';
            document.getElementById('editActualTaskSearch').style.display = 'none';
            document.getElementById('editActualTaskSearch').value = '';

            if (previousActual) {
                // 前回の実績の工程を選択
                document.getElementById('editActualProcess').value = previousActual.process;
            } else {
                document.getElementById('editActualProcess').value = 'UI';
            }
            
            // 担当者を設定（カレンダーからの場合は表示のみ）
            const memberSelect = document.getElementById('editActualMember');
            const memberDisplay = document.getElementById('editActualMemberDisplay');

            // optionを追加してから値を設定
            memberSelect.innerHTML = '';
            const option = document.createElement('option');
            option.value = member;
            option.textContent = member;
            memberSelect.appendChild(option);
            memberSelect.value = member;

            memberSelect.style.display = 'none';
            memberDisplay.style.display = 'block';
            memberDisplay.textContent = member;

            document.getElementById('editActualHours').value = '8';
            document.getElementById('editActualRemainingHours').value = '';

            // モーダルのタイトルを変更
            const modalTitle = document.querySelector('#editActualModal .modal-header h3');
            const [year, month, day] = date.split('-');
            modalTitle.textContent = `実績を新規登録 - ${member} (${year}/${parseInt(month)}/${parseInt(day)})`;

            // この担当者の未完了対応を取得してdatalistに設定
            // 新規登録時なのでisEditMode=false、選択した版数を渡す
            updateEditActualTaskList(member, false, versionSelect.value);

            // 前回の実績がある場合は対応名を選択
            if (previousActual) {
                const taskSelect = document.getElementById('editActualTaskSelect');
                taskSelect.value = previousActual.task;
            }

            // 「その他作業」「休暇登録」ボタンを表示し、データを保持
            document.getElementById('editActualOtherBtn').style.display = 'block';
            document.getElementById('editActualVacationBtn').style.display = 'block';
            document.getElementById('editActualModal').dataset.calendarMember = member;
            document.getElementById('editActualModal').dataset.calendarDate = date;

            document.getElementById('editActualModal').style.display = 'flex';
        }

        // カレンダーからその他作業モーダルを開く
        function openOtherWorkFromCalendar() {
            const modal = document.getElementById('editActualModal');
            const member = modal.dataset.calendarMember;
            const date = modal.dataset.calendarDate;

            // 実績編集モーダルを閉じる
            closeEditActualModal();

            // その他作業モーダルを開き、担当者と日付を設定
            openOtherWorkModalWithContext(member, date);
        }

        // カレンダーから休暇登録モーダルを開く
        function openVacationFromCalendar() {
            const modal = document.getElementById('editActualModal');
            const member = modal.dataset.calendarMember;
            const date = modal.dataset.calendarDate;

            // 実績編集モーダルを閉じる
            closeEditActualModal();

            // 休暇登録モーダルを開く
            addVacationFromCalendar(member, date);
        }

        // コンテキスト付きでその他作業モーダルを開く
        function openOtherWorkModalWithContext(member, date) {
            // 担当者選択肢を更新
            const otherWorkMemberSelect = document.getElementById('otherWorkMember');
            if (otherWorkMemberSelect) {
                const allMembers = new Set();
                estimates.forEach(e => allMembers.add(e.member));
                actuals.forEach(a => allMembers.add(a.member));

                let sortedMembers;
                const memberOrderInput = document.getElementById('memberOrder').value.trim();
                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = orderList.filter(name => allMembers.has(name));
                    const unorderedMembers = Array.from(allMembers).filter(m => !orderedMembers.includes(m)).sort();
                    sortedMembers = [...orderedMembers, ...unorderedMembers];
                } else {
                    sortedMembers = Array.from(allMembers).sort();
                }

                otherWorkMemberSelect.innerHTML = '<option value="">選択...</option>';
                sortedMembers.forEach(m => {
                    const option = document.createElement('option');
                    option.value = m;
                    option.textContent = m;
                    otherWorkMemberSelect.appendChild(option);
                });

                // 担当者を選択
                otherWorkMemberSelect.value = member;
            }

            // 日付を保持（保存時に使用）
            document.getElementById('otherWorkModal').dataset.calendarDate = date;

            // モーダルのタイトルを更新
            const [year, month, day] = date.split('-');
            document.querySelector('#otherWorkModal .modal-header h3').textContent =
                `その他作業を登録 - ${member} (${year}/${parseInt(month)}/${parseInt(day)})`;

            document.getElementById('otherWorkModal').style.display = 'flex';
        }

        // 指定した担当者・日付より前の最新実績を取得
        function getPreviousActual(member, beforeDate) {
            // その担当者の、指定日付より前の実績を取得
            const previousActuals = actuals.filter(a =>
                a.member === member &&
                a.date < beforeDate &&
                a.version && a.task && a.process // 有効なデータのみ
            );

            // 日付順にソートして最新のものを返す
            if (previousActuals.length > 0) {
                previousActuals.sort((a, b) => b.date.localeCompare(a.date));
                return previousActuals[0];
            }

            return null;
        }

        // 全担当者の中から指定日付より前の最新実績を取得（クイック入力用）
        function getLatestActualBeforeDate(beforeDate) {
            // 指定日付より前の実績を取得
            const previousActuals = actuals.filter(a =>
                a.date < beforeDate &&
                a.version && a.task && a.process // 有効なデータのみ
            );

            // 日付順にソートして最新のものを返す
            if (previousActuals.length > 0) {
                previousActuals.sort((a, b) => b.date.localeCompare(a.date));
                return previousActuals[0];
            }

            return null;
        }

        // クイック入力で前回の実績を自動選択
        function setQuickInputPreviousActual() {
            const today = new Date().toISOString().split('T')[0];
            const previousActual = getLatestActualBeforeDate(today);

            if (previousActual) {
                // selectedQuickTaskを設定（形式：version|task|process|member）
                selectedQuickTask = `${previousActual.version}|${previousActual.task}|${previousActual.process}|${previousActual.member}`;

                // 検索ボックスに表示
                const searchInput = document.getElementById('quickTaskSearch');
                searchInput.value = `${previousActual.version} - ${previousActual.task} [${previousActual.process}]`;

                // クリアボタンを表示
                document.getElementById('quickTaskClearBtn').style.display = 'inline-block';
            }
        }

        // 実績編集モーダルの対応名リストを更新（担当者と版数に応じた対応）
        function updateEditActualTaskList(member, isEditMode = false, selectedVersion = null) {
            const select = document.getElementById('editActualTaskSelect');

            // 版数が選択されていない場合は、editActualVersionから取得
            if (!selectedVersion) {
                const versionSelect = document.getElementById('editActualVersion');
                selectedVersion = versionSelect ? versionSelect.value : null;
            }

            // すべての見積データを取得（担当者フィルタリングなし）
            let allEstimates = [...estimates];

            // 版数が選択されている場合は、その版数の作業のみに絞る
            if (selectedVersion && selectedVersion !== '') {
                allEstimates = allEstimates.filter(e => e.version === selectedVersion);
            }

            // 実績工数を集計
            const actualTotals = {};
            actuals.forEach(a => {
                const key = `${a.version}_${a.task}_${a.process}`;
                actualTotals[key] = (actualTotals[key] || 0) + a.hours;
            });

            // 担当者別に対応を抽出してグループ化
            const tasksByMember = {};
            allEstimates.forEach(est => {
                const key = `${est.version}_${est.task}_${est.process}`;
                const actualHours = actualTotals[key] || 0;
                const remaining = est.hours - actualHours;

                // 編集モードの場合はすべての対応を含める
                // 新規入力モードでも全ての対応を表示（超過した作業も選択可能にする）
                if (true) {
                    let displayText;
                    if (remaining > 0) {
                        displayText = `${est.task} [${est.process}] (残: ${remaining.toFixed(1)}h)`;
                    } else if (remaining < 0) {
                        displayText = `${est.task} [${est.process}] (超過: ${Math.abs(remaining).toFixed(1)}h)`;
                    } else {
                        displayText = `${est.task} [${est.process}] (完了)`;
                    }

                    if (!tasksByMember[est.member]) {
                        tasksByMember[est.member] = [];
                    }

                    tasksByMember[est.member].push({
                        version: est.version,
                        task: est.task,
                        process: est.process,
                        remaining: remaining,
                        display: displayText
                    });
                }
            });

            // selectを更新
            select.innerHTML = '<option value="">-- 対応を選択 --</option>';

            // 現在の担当者のグループを最初に表示
            if (tasksByMember[member] && tasksByMember[member].length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = `担当：${member}`;
                tasksByMember[member].forEach(task => {
                    const option = document.createElement('option');
                    option.value = task.task;
                    option.setAttribute('data-version', task.version);
                    option.setAttribute('data-process', task.process);
                    option.textContent = task.display;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }

            // 他の担当者のグループを表示
            Object.keys(tasksByMember).sort().forEach(otherMember => {
                if (otherMember !== member && tasksByMember[otherMember].length > 0) {
                    const optgroup = document.createElement('optgroup');
                    optgroup.label = `担当：${otherMember}`;
                    tasksByMember[otherMember].forEach(task => {
                        const option = document.createElement('option');
                        option.value = task.task;
                        option.setAttribute('data-version', task.version);
                        option.setAttribute('data-process', task.process);
                        option.textContent = task.display;
                        optgroup.appendChild(option);
                    });
                    select.appendChild(optgroup);
                }
            });

            // 「新規入力」オプションを追加
            const newOption = document.createElement('option');
            newOption.value = '__NEW__';
            newOption.textContent = '新規入力...';
            select.appendChild(newOption);
        }
        
        // 作業詳細モーダルから編集
        function editActualFromModal(id) {
            closeWorkModal();
            editActual(id);
        }
        
        // 作業詳細モーダルから削除
        function deleteActualFromModal(id, member, date) {
            if (confirm('この実績を削除しますか？')) {
                actuals = actuals.filter(a => a.id !== id);
                saveData();
                renderActualList();
                renderTodayActuals();
                updateReport();
                
                // モーダルを更新（まだ他の作業がある場合）
                const remainingActuals = actuals.filter(a => a.member === member && a.date === date);
                if (remainingActuals.length > 0) {
                    showWorkDetail(member, date);
                } else {
                    closeWorkModal();
                }
            }
        }

        function editActual(id) {
            const actual = actuals.find(a => a.id === id);
            if (!actual) {
                alert('データが見つかりません');
                return;
            }

            // フォームに既存データを設定
            document.getElementById('editActualId').value = id;
            document.getElementById('editActualDate').value = actual.date;
            document.getElementById('editActualVersion').value = actual.version;

            // 編集時はすべての対応（完了済み含む）のリストを更新して選択できるようにする
            // 選択した版数の作業のみを表示
            updateEditActualTaskList(actual.member, true, actual.version);

            // 対応名をセレクトボックスで選択
            const taskSelect = document.getElementById('editActualTaskSelect');
            taskSelect.style.display = 'block';
            document.getElementById('editActualTaskSearch').style.display = 'none';
            taskSelect.value = actual.task;

            document.getElementById('editActualProcess').value = actual.process;
            document.getElementById('editActualHours').value = actual.hours;

            // 見込残存時間を読み込み
            const existingRemaining = getRemainingEstimate(actual.version, actual.task, actual.process, actual.member);
            document.getElementById('editActualRemainingHours').value = existingRemaining ? existingRemaining.remainingHours : '';

            // モーダルのタイトルを更新
            const modalTitle = document.querySelector('#editActualModal .modal-header h3');
            const [year, month, day] = actual.date.split('-');
            modalTitle.textContent = `実績データを編集 - ${actual.member} (${year}/${parseInt(month)}/${parseInt(day)})`;
            
            // 担当者選択肢を更新
            const memberSelect = document.getElementById('editActualMember');
            const allMembers = new Set();
            estimates.forEach(e => allMembers.add(e.member));
            actuals.forEach(a => allMembers.add(a.member));
            
            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];
                
                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });
                
                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });
                
                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(allMembers).sort();
            }
            
            memberSelect.innerHTML = '';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                memberSelect.appendChild(option);
            });

            memberSelect.value = actual.member;

            // 編集時はセレクトを表示、表示用spanを非表示
            memberSelect.style.display = 'block';
            document.getElementById('editActualMemberDisplay').style.display = 'none';

            // 編集時は「その他作業」「休暇登録」ボタンを非表示
            document.getElementById('editActualOtherBtn').style.display = 'none';
            document.getElementById('editActualVacationBtn').style.display = 'none';

            // モーダルを表示
            document.getElementById('editActualModal').style.display = 'flex';
        }

        function closeEditActualModal() {
            document.getElementById('editActualModal').style.display = 'none';
        }

        function saveActualEdit() {
            const id = parseFloat(document.getElementById('editActualId').value);
            const date = document.getElementById('editActualDate').value;
            const version = document.getElementById('editActualVersion').value;

            // selectまたはinputから対応名を取得
            const taskSelect = document.getElementById('editActualTaskSelect');
            const taskInput = document.getElementById('editActualTaskSearch');
            const task = taskSelect.style.display !== 'none' && taskSelect.value && taskSelect.value !== '__NEW__'
                ? taskSelect.value
                : taskInput.value;

            const process = document.getElementById('editActualProcess').value;
            const member = document.getElementById('editActualMember').value;
            const hours = parseFloat(document.getElementById('editActualHours').value);
            const remainingHoursInput = document.getElementById('editActualRemainingHours');
            const remainingHours = remainingHoursInput.value !== '' ? parseFloat(remainingHoursInput.value) : null;

            if (!date || !version || !task || !process || !member || !hours) {
                alert('すべての項目を入力してください');
                return;
            }

            // 新規登録か既存データの更新かを判定
            if (id && !isNaN(id)) {
                // 既存データの更新
                const actualIndex = actuals.findIndex(a => a.id === id);
                if (actualIndex !== -1) {
                    actuals[actualIndex] = {
                        ...actuals[actualIndex],
                        date: date,
                        version: version,
                        task: task,
                        process: process,
                        member: member,
                        hours: hours
                    };

                    // 見込残存時間が入力されていれば保存
                    if (remainingHours !== null && !isNaN(remainingHours)) {
                        saveRemainingEstimate(version, task, process, member, remainingHours);
                    }

                    saveData();
                    closeEditActualModal();

                    updateMonthOptions();
                    updateActualMonthOptions();
                    updateMemberOptions();
                    updateQuickTaskList();
                    renderTodayActuals();
                    renderActualList();
                    updateReport();

                    showAlert('実績データを更新しました', true);
                } else {
                    showAlert('データの更新に失敗しました', false);
                }
            } else {
                // 新規登録
                const newActual = {
                    id: Date.now() + Math.random(),
                    date: date,
                    version: version,
                    task: task,
                    process: process,
                    member: member,
                    hours: hours
                };

                actuals.push(newActual);

                // 見込残存時間が入力されていれば保存
                if (remainingHours !== null && !isNaN(remainingHours)) {
                    saveRemainingEstimate(version, task, process, member, remainingHours);
                }

                saveData();
                closeEditActualModal();

                updateMonthOptions();
                updateActualMonthOptions();
                updateMemberOptions();
                updateQuickTaskList();
                renderTodayActuals();
                renderActualList();
                updateReport();

                showAlert('実績を登録しました', true);
            }
        }

        // 見込残存時間を保存/更新する関数
        function saveRemainingEstimate(version, task, process, member, remainingHours) {
            const existingIndex = remainingEstimates.findIndex(r =>
                r.version === version &&
                r.task === task &&
                r.process === process &&
                r.member === member
            );

            const record = {
                id: existingIndex >= 0 ? remainingEstimates[existingIndex].id : Date.now() + Math.random(),
                version: version,
                task: task,
                process: process,
                member: member,
                remainingHours: remainingHours,
                updatedAt: new Date().toISOString(),
                note: ''
            };

            if (existingIndex >= 0) {
                remainingEstimates[existingIndex] = record;
            } else {
                remainingEstimates.push(record);
            }
        }

        // 見込残存時間を取得する関数
        function getRemainingEstimate(version, task, process, member) {
            return remainingEstimates.find(r =>
                r.version === version &&
                r.task === task &&
                r.process === process &&
                r.member === member
            );
        }

        // 進捗率から表示色を取得
        function getProgressColor(progressRate) {
            if (progressRate >= 100) {
                return '#2e7d32'; // ダークグリーン - 完了
            } else if (progressRate >= 90) {
                return '#4caf50'; // グリーン - ほぼ完了
            } else if (progressRate >= 70) {
                return '#66bb6a'; // ライトグリーン - 完了間近
            } else if (progressRate >= 30) {
                return '#42a5f5'; // ブルー - 進行中
            } else if (progressRate >= 10) {
                return '#90caf9'; // ライトブルー - 開始
            } else {
                return '#e0e0e0'; // 薄いグレー - 未着手
            }
        }

        // 進捗率とバーHTMLを生成（マトリクス表示用）
        function generateProgressBar(version, task, process) {
            // 設定でオフになっている場合は何も表示しない
            if (!showProgressBarsSetting) {
                return '';
            }

            // 実績を集計
            let actualHours = actuals
                .filter(a => a.version === version && a.task === task && a.process === process)
                .reduce((sum, a) => sum + a.hours, 0);

            // 見込残存時間のデータが存在するかチェック
            const remainingData = remainingEstimates
                .filter(r => r.version === version && r.task === task && r.process === process);

            // 見込残存時間を集計
            let remainingHours = remainingData.reduce((sum, r) => sum + r.remainingHours, 0);

            // 見込残存時間のデータが存在しない場合はバーを表示しない
            if (remainingData.length === 0) {
                return '';
            }

            // 進捗率を計算
            let progressRate = 0;

            if (remainingHours === 0 && actualHours > 0) {
                // 見込残存が0hで実績があれば100%（完了）
                progressRate = 100;
            } else if (remainingHours === 0 && actualHours === 0) {
                // 見込残存が0hで実績もなし → 完了または作業不要（100%）
                progressRate = 100;
            } else if (actualHours + remainingHours > 0) {
                // 見込残存データがあれば計算
                progressRate = (actualHours / (actualHours + remainingHours)) * 100;
            }

            const barColor = getProgressColor(progressRate);
            const barWidth = Math.min(progressRate, 100); // 100%を超えても表示は100%まで
            const displayRate = progressRate.toFixed(0);
            const remainingDisplay = remainingHours.toFixed(1);

            let progressBarHtml = '';

            if (progressBarStyle === 'bottom') {
                // セル下部に表示するスタイル（未進捗部分も表示）
                progressBarHtml = `
                    <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 4px; background: #e8e8e8; border-top: 1px solid #d0d0d0; overflow: hidden;" title="進捗率: ${displayRate}% | 実績: ${actualHours.toFixed(1)}h | 残: ${remainingDisplay}h">
                        <div style="height: 100%; width: ${barWidth}%; background: ${barColor}; transition: width 0.3s;"></div>
                    </div>
                `;
            } else {
                // セル内に表示するスタイル（デフォルト）
                const percentageHtml = showProgressPercentageSetting
                    ? `<div style="font-size: 9px; color: #888; margin-top: 2px; text-align: center;">${displayRate}%</div>`
                    : '';

                progressBarHtml = `
                    <div style="margin-top: 6px; position: relative;" title="進捗率: ${displayRate}% | 実績: ${actualHours.toFixed(1)}h | 残: ${remainingDisplay}h">
                        <div style="height: 3px; background: #f0f0f0; border-radius: 2px; overflow: hidden;">
                            <div style="height: 100%; width: ${barWidth}%; background: ${barColor}; transition: width 0.3s;"></div>
                        </div>
                        ${percentageHtml}
                    </div>
                `;
            }

            return progressBarHtml;
        }

        // 対応単位での進捗情報を計算
        function calculateProgress(version, task, process = null, member = null) {
            // 見積工数を集計
            let estimatedHours = estimates
                .filter(e =>
                    e.version === version &&
                    e.task === task &&
                    (process === null || e.process === process) &&
                    (member === null || e.member === member)
                )
                .reduce((sum, e) => sum + e.hours, 0);

            // 実績工数を集計
            let actualHours = actuals
                .filter(a =>
                    a.version === version &&
                    a.task === task &&
                    (process === null || a.process === process) &&
                    (member === null || a.member === member)
                )
                .reduce((sum, a) => sum + a.hours, 0);

            // 見込残存時間を集計
            let remainingHours = remainingEstimates
                .filter(r =>
                    r.version === version &&
                    r.task === task &&
                    (process === null || r.process === process) &&
                    (member === null || r.member === member)
                )
                .reduce((sum, r) => sum + r.remainingHours, 0);

            // 予測総工数 = 実績 + 見込残存
            const eac = actualHours + remainingHours;

            // 進捗率 = 実績 / (実績 + 見込残存) × 100
            const progressRate = (actualHours + remainingHours) > 0
                ? (actualHours / (actualHours + remainingHours)) * 100
                : 0;

            // 状態判定
            let status = 'unknown';
            let statusLabel = '未設定';
            let statusColor = '#999';

            if (remainingHours === 0 && actualHours > 0) {
                status = 'completed';
                statusLabel = '完了';
                statusColor = '#27ae60';
            } else if (estimatedHours > 0) {
                if (eac <= estimatedHours) {
                    status = 'ontrack';
                    statusLabel = '順調';
                    statusColor = '#3498db';
                } else if (eac <= estimatedHours * 1.2) {
                    status = 'warning';
                    statusLabel = '注意';
                    statusColor = '#f39c12';
                } else {
                    status = 'exceeded';
                    statusLabel = '超過';
                    statusColor = '#e74c3c';
                }
            }

            // 差異計算
            const variance = eac - estimatedHours;
            const variancePercent = estimatedHours > 0
                ? ((eac - estimatedHours) / estimatedHours) * 100
                : 0;

            return {
                estimatedHours,
                actualHours,
                remainingHours,
                eac,
                progressRate: Math.round(progressRate * 10) / 10,
                status,
                statusLabel,
                statusColor,
                variance,
                variancePercent: Math.round(variancePercent * 10) / 10,
                hasRemainingData: remainingHours > 0 ||
                    remainingEstimates.some(r => r.version === version && r.task === task)
            };
        }

        // 版数全体の進捗情報を計算
        function calculateVersionProgress(version) {
            const versionEstimates = estimates.filter(e => e.version === version);
            const versionActuals = actuals.filter(a => a.version === version);
            const versionRemaining = remainingEstimates.filter(r => r.version === version);

            const estimatedHours = versionEstimates.reduce((sum, e) => sum + e.hours, 0);
            const actualHours = versionActuals.reduce((sum, a) => sum + a.hours, 0);
            const remainingHours = versionRemaining.reduce((sum, r) => sum + r.remainingHours, 0);

            const eac = actualHours + remainingHours;
            const progressRate = (actualHours + remainingHours) > 0
                ? (actualHours / (actualHours + remainingHours)) * 100
                : 0;

            // タスク数
            const uniqueTasks = new Set([
                ...versionEstimates.map(e => e.task),
                ...versionActuals.map(a => a.task)
            ]);
            const completedTasks = [...uniqueTasks].filter(task => {
                const progress = calculateProgress(version, task);
                return progress.status === 'completed';
            }).length;

            return {
                estimatedHours,
                actualHours,
                remainingHours,
                eac,
                progressRate: Math.round(progressRate * 10) / 10,
                totalTasks: uniqueTasks.size,
                completedTasks,
                hasRemainingData: versionRemaining.length > 0
            };
        }

        // プログレスバーHTMLを生成
        function createProgressBar(progressRate, status, options = {}) {
            const {
                showLabel = true,
                height = '20px',
                showEac = false,
                eac = 0,
                estimated = 0
            } = options;

            const statusColors = {
                completed: '#27ae60',
                ontrack: '#3498db',
                warning: '#f39c12',
                exceeded: '#e74c3c',
                unknown: '#bdc3c7'
            };

            const color = statusColors[status] || statusColors.unknown;
            const clampedRate = Math.min(100, Math.max(0, progressRate));

            // 超過の場合は見積対比でバー表示
            let barWidth = clampedRate;
            let overflowWidth = 0;

            if (status === 'exceeded' && estimated > 0 && eac > 0) {
                barWidth = (estimated / eac) * 100;
                overflowWidth = 100 - barWidth;
            }

            let html = `
                <div style="position: relative; background: #ecf0f1; border-radius: 10px; height: ${height}; overflow: hidden;">
                    <div style="
                        width: ${barWidth}%;
                        height: 100%;
                        background: ${color};
                        border-radius: 10px;
                        transition: width 0.3s ease;
                    "></div>
            `;

            // 超過分のオーバーレイ
            if (overflowWidth > 0) {
                html += `
                    <div style="
                        position: absolute;
                        right: 0;
                        top: 0;
                        width: ${overflowWidth}%;
                        height: 100%;
                        background: repeating-linear-gradient(
                            45deg,
                            ${color},
                            ${color} 5px,
                            rgba(255,255,255,0.3) 5px,
                            rgba(255,255,255,0.3) 10px
                        );
                        border-radius: 0 10px 10px 0;
                    "></div>
                `;
            }

            // ラベル
            if (showLabel) {
                html += `
                    <span style="
                        position: absolute;
                        left: 50%;
                        top: 50%;
                        transform: translate(-50%, -50%);
                        font-size: 11px;
                        font-weight: 600;
                        color: ${clampedRate > 50 ? 'white' : '#333'};
                        text-shadow: ${clampedRate > 50 ? '0 1px 2px rgba(0,0,0,0.2)' : 'none'};
                    ">${progressRate.toFixed(1)}%</span>
                `;
            }

            html += '</div>';

            return html;
        }

        // 状態バッジHTMLを生成
        function createStatusBadge(status, statusLabel) {
            const styles = {
                completed: { bg: '#e8f5e9', color: '#27ae60', icon: String.fromCharCode(10003) },
                ontrack:   { bg: '#e3f2fd', color: '#1976d2', icon: String.fromCharCode(8594) },
                warning:   { bg: '#fff3e0', color: '#f57c00', icon: String.fromCharCode(9888) },
                exceeded:  { bg: '#fce4ec', color: '#c2185b', icon: '!' },
                unknown:   { bg: '#f5f5f5', color: '#999', icon: '?' }
            };

            const style = styles[status] || styles.unknown;

            return `
                <span style="
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 600;
                    background: ${style.bg};
                    color: ${style.color};
                ">
                    <span>${style.icon}</span>
                    <span>${statusLabel}</span>
                </span>
            `;
        }

        // 進捗管理レポートを更新
        function updateProgressReport() {
            const versionFilter = document.getElementById('progressVersionFilter')?.value || 'all';
            const statusFilter = document.getElementById('progressStatusFilter')?.value || 'all';

            // 版数選択肢を更新
            updateProgressVersionOptions();

            // サマリーカードを更新
            renderProgressSummaryCards(versionFilter);

            // 詳細テーブルを更新
            renderProgressDetailTable(versionFilter, statusFilter);
        }

        // 版数選択肢を更新
        function updateProgressVersionOptions() {
            const select = document.getElementById('progressVersionFilter');
            const bulkSelect = document.getElementById('bulkRemainingVersionFilter');
            if (!select) return;

            const versions = [...new Set([
                ...estimates.map(e => e.version),
                ...actuals.map(a => a.version)
            ])].filter(v => v && v.trim() !== '').sort();

            const currentValue = select.value;
            select.innerHTML = '<option value="all">全版数</option>';
            versions.forEach(v => {
                select.innerHTML += `<option value="${v}">${v}</option>`;
            });
            select.value = currentValue || 'all';

            if (bulkSelect) {
                const bulkCurrentValue = bulkSelect.value;
                bulkSelect.innerHTML = '<option value="all">全版数</option>';
                versions.forEach(v => {
                    bulkSelect.innerHTML += `<option value="${v}">${v}</option>`;
                });
                bulkSelect.value = bulkCurrentValue || 'all';
            }
        }

        // サマリーカードをレンダリング
        function renderProgressSummaryCards(versionFilter) {
            const container = document.getElementById('progressSummaryCards');
            if (!container) return;

            // フィルタリング
            let targetVersions = versionFilter === 'all'
                ? [...new Set([...estimates.map(e => e.version), ...actuals.map(a => a.version)])]
                    .filter(v => v && v.trim() !== '')
                : [versionFilter];

            // 全体統計
            let totalEstimated = 0, totalActual = 0, totalRemaining = 0;
            let completedTasks = 0, totalTasks = 0;

            targetVersions.forEach(version => {
                const progress = calculateVersionProgress(version);
                totalEstimated += progress.estimatedHours;
                totalActual += progress.actualHours;
                totalRemaining += progress.remainingHours;
                completedTasks += progress.completedTasks;
                totalTasks += progress.totalTasks;
            });

            const totalEac = totalActual + totalRemaining;
            const overallProgress = totalEac > 0 ? (totalActual / totalEac) * 100 : 0;
            const variance = totalEac - totalEstimated;

            // 状態別カウント
            let statusCounts = { completed: 0, ontrack: 0, warning: 0, exceeded: 0, unknown: 0 };
            targetVersions.forEach(version => {
                const tasks = [...new Set([
                    ...estimates.filter(e => e.version === version).map(e => e.task),
                    ...actuals.filter(a => a.version === version).map(a => a.task)
                ])];
                tasks.forEach(task => {
                    const progress = calculateProgress(version, task);
                    statusCounts[progress.status]++;
                });
            });

            container.innerHTML = `
                <div class="stat-card theme-bg theme-${currentThemeColor}">
                    <h3>全体進捗率</h3>
                    <div class="value">${overallProgress.toFixed(1)}%</div>
                    <div style="font-size: 12px; color: rgba(255,255,255,0.8); margin-top: 5px;">
                        ${completedTasks}/${totalTasks} 対応完了
                    </div>
                </div>
                <div class="stat-card theme-bg theme-${currentThemeColor}">
                    <h3>予測総工数</h3>
                    <div class="value">${totalEac.toFixed(1)}h</div>
                    <div style="font-size: 12px; color: rgba(255,255,255,0.8); margin-top: 5px;">
                        見積: ${totalEstimated.toFixed(1)}h / 差異: ${variance >= 0 ? '+' : ''}${variance.toFixed(1)}h
                    </div>
                </div>
                <div class="stat-card theme-bg theme-${currentThemeColor}">
                    <h3>実績 / 残存</h3>
                    <div class="value">${totalActual.toFixed(1)}h / ${totalRemaining.toFixed(1)}h</div>
                </div>
                <div class="stat-card theme-bg theme-${currentThemeColor}">
                    <h3>状態別</h3>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-top: 8px;">
                        <span style="background: rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 10px; font-size: 12px;">
                            ${String.fromCharCode(10003)} ${statusCounts.completed}
                        </span>
                        <span style="background: rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 10px; font-size: 12px;">
                            ${String.fromCharCode(8594)} ${statusCounts.ontrack}
                        </span>
                        <span style="background: rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 10px; font-size: 12px;">
                            ${String.fromCharCode(9888)} ${statusCounts.warning}
                        </span>
                        <span style="background: rgba(255,255,255,0.2); padding: 3px 8px; border-radius: 10px; font-size: 12px;">
                            ! ${statusCounts.exceeded}
                        </span>
                    </div>
                </div>
            `;
        }

        // 詳細テーブルをレンダリング
        function renderProgressDetailTable(versionFilter, statusFilter) {
            const container = document.getElementById('progressDetailTable');
            if (!container) return;

            // フィルタリング
            let targetVersions = versionFilter === 'all'
                ? [...new Set([...estimates.map(e => e.version), ...actuals.map(a => a.version)])]
                    .filter(v => v && v.trim() !== '').sort()
                : [versionFilter];

            let html = '<div class="table-wrapper"><table style="width: 100%; border-collapse: collapse;">';
            html += `
                <thead>
                    <tr style="background: #f8f9fa;">
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">版数</th>
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">対応名</th>
                        <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">見積</th>
                        <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">実績</th>
                        <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">残存</th>
                        <th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">予測総工数</th>
                        <th style="padding: 10px; text-align: center; border-bottom: 2px solid #ddd; width: 150px;">進捗</th>
                        <th style="padding: 10px; text-align: center; border-bottom: 2px solid #ddd;">状態</th>
                    </tr>
                </thead>
                <tbody>
            `;

            let rowCount = 0;
            targetVersions.forEach(version => {
                const tasks = [...new Set([
                    ...estimates.filter(e => e.version === version).map(e => e.task),
                    ...actuals.filter(a => a.version === version).map(a => a.task)
                ])].sort();

                tasks.forEach(task => {
                    const progress = calculateProgress(version, task);

                    // ステータスフィルタ
                    if (statusFilter !== 'all' && progress.status !== statusFilter) return;

                    rowCount++;
                    const borderColor = {
                        completed: '#27ae60',
                        ontrack: '#3498db',
                        warning: '#f39c12',
                        exceeded: '#e74c3c',
                        unknown: '#ccc'
                    }[progress.status] || '#ccc';

                    html += `
                        <tr style="border-left: 4px solid ${borderColor};">
                            <td style="padding: 10px; border-bottom: 1px solid #eee;"><strong>${version}</strong></td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${task}</td>
                            <td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">${progress.estimatedHours.toFixed(1)}h</td>
                            <td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">${progress.actualHours.toFixed(1)}h</td>
                            <td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee;">
                                ${progress.hasRemainingData
                                    ? progress.remainingHours.toFixed(1) + 'h'
                                    : '<span style="color: #999;">未設定</span>'}
                            </td>
                            <td style="padding: 10px; text-align: right; border-bottom: 1px solid #eee; font-weight: 600;">
                                ${progress.eac.toFixed(1)}h
                                ${progress.variance !== 0
                                    ? `<span style="font-size: 11px; color: ${progress.variance > 0 ? '#e74c3c' : '#27ae60'};">
                                        (${progress.variance > 0 ? '+' : ''}${progress.variance.toFixed(1)})
                                       </span>`
                                    : ''}
                            </td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">
                                ${createProgressBar(progress.progressRate, progress.status, {
                                    showEac: true,
                                    eac: progress.eac,
                                    estimated: progress.estimatedHours
                                })}
                            </td>
                            <td style="padding: 10px; text-align: center; border-bottom: 1px solid #eee;">${createStatusBadge(progress.status, progress.statusLabel)}</td>
                        </tr>
                    `;
                });
            });

            if (rowCount === 0) {
                html += '<tr><td colspan="8" style="text-align: center; color: #999; padding: 40px;">該当するデータがありません</td></tr>';
            }

            html += '</tbody></table></div>';
            container.innerHTML = html;
        }

        // 一括編集モーダルを開く
        function openBulkRemainingModal() {
            updateProgressVersionOptions();
            renderBulkRemainingTable();
            document.getElementById('bulkRemainingModal').style.display = 'flex';
        }

        // 一括編集モーダルを閉じる
        function closeBulkRemainingModal() {
            document.getElementById('bulkRemainingModal').style.display = 'none';
        }

        // 一括編集テーブルをレンダリング
        function renderBulkRemainingTable() {
            const versionFilter = document.getElementById('bulkRemainingVersionFilter')?.value || 'all';
            const tbody = document.getElementById('bulkRemainingTableBody');
            if (!tbody) return;

            // 版数でフィルタリング
            let targetVersions = versionFilter === 'all'
                ? [...new Set([...estimates.map(e => e.version), ...actuals.map(a => a.version)])]
                    .filter(v => v && v.trim() !== '').sort()
                : [versionFilter];

            let html = '';
            let rowIndex = 0;

            targetVersions.forEach(version => {
                // この版数のタスクと工程と担当者の組み合わせを取得
                const combinations = new Map();

                estimates.filter(e => e.version === version).forEach(e => {
                    const key = `${e.task}|${e.process}|${e.member}`;
                    if (!combinations.has(key)) {
                        combinations.set(key, { version, task: e.task, process: e.process, member: e.member, estimatedHours: 0, actualHours: 0 });
                    }
                    combinations.get(key).estimatedHours += e.hours;
                });

                actuals.filter(a => a.version === version).forEach(a => {
                    const key = `${a.task}|${a.process}|${a.member}`;
                    if (!combinations.has(key)) {
                        combinations.set(key, { version, task: a.task, process: a.process, member: a.member, estimatedHours: 0, actualHours: 0 });
                    }
                    combinations.get(key).actualHours += a.hours;
                });

                // 各組み合わせについて行を生成
                combinations.forEach((data, key) => {
                    const existing = getRemainingEstimate(data.version, data.task, data.process, data.member);
                    const remainingHours = existing ? existing.remainingHours : '';
                    const eac = data.actualHours + (parseFloat(remainingHours) || 0);

                    // 状態判定
                    let status = 'unknown';
                    let statusLabel = '未設定';
                    if (remainingHours !== '' && parseFloat(remainingHours) === 0 && data.actualHours > 0) {
                        status = 'completed';
                        statusLabel = '完了';
                    } else if (data.estimatedHours > 0 && remainingHours !== '') {
                        if (eac <= data.estimatedHours) {
                            status = 'ontrack';
                            statusLabel = '順調';
                        } else if (eac <= data.estimatedHours * 1.2) {
                            status = 'warning';
                            statusLabel = '注意';
                        } else {
                            status = 'exceeded';
                            statusLabel = '超過';
                        }
                    }

                    html += `
                        <tr data-row-index="${rowIndex}"
                            data-version="${data.version}"
                            data-task="${data.task}"
                            data-process="${data.process}"
                            data-member="${data.member}">
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">${data.version}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">${data.task}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">${data.process}</td>
                            <td style="padding: 8px; border-bottom: 1px solid #eee;">${data.member}</td>
                            <td style="padding: 8px; text-align: right; border-bottom: 1px solid #eee;">${data.estimatedHours.toFixed(1)}h</td>
                            <td style="padding: 8px; text-align: right; border-bottom: 1px solid #eee;">${data.actualHours.toFixed(1)}h</td>
                            <td style="padding: 8px; text-align: right; border-bottom: 1px solid #eee;">
                                <input type="number"
                                       class="bulk-remaining-input"
                                       value="${remainingHours}"
                                       step="0.5"
                                       min="0"
                                       placeholder="0"
                                       onchange="updateBulkRowStatus(this)"
                                       style="width: 70px; padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; text-align: right;">
                            </td>
                            <td style="padding: 8px; text-align: right; border-bottom: 1px solid #eee;" class="bulk-eac">
                                ${remainingHours !== '' ? eac.toFixed(1) + 'h' : '-'}
                            </td>
                            <td style="padding: 8px; text-align: center; border-bottom: 1px solid #eee;" class="bulk-status">
                                ${createStatusBadge(status, statusLabel)}
                            </td>
                        </tr>
                    `;
                    rowIndex++;
                });
            });

            if (rowIndex === 0) {
                html = '<tr><td colspan="9" style="text-align: center; color: #999; padding: 40px;">該当するデータがありません</td></tr>';
            }

            tbody.innerHTML = html;
        }

        // 一括編集の行ステータスを更新
        function updateBulkRowStatus(input) {
            const row = input.closest('tr');
            const version = row.dataset.version;
            const task = row.dataset.task;
            const process = row.dataset.process;
            const member = row.dataset.member;

            // 見積と実績を再計算
            const estimatedHours = estimates
                .filter(e => e.version === version && e.task === task && e.process === process && e.member === member)
                .reduce((sum, e) => sum + e.hours, 0);
            const actualHours = actuals
                .filter(a => a.version === version && a.task === task && a.process === process && a.member === member)
                .reduce((sum, a) => sum + a.hours, 0);

            const remainingHours = parseFloat(input.value);
            const eacCell = row.querySelector('.bulk-eac');
            const statusCell = row.querySelector('.bulk-status');

            if (!isNaN(remainingHours)) {
                const eac = actualHours + remainingHours;
                eacCell.textContent = eac.toFixed(1) + 'h';

                // 状態判定
                let status = 'unknown';
                let statusLabel = '未設定';
                if (remainingHours === 0 && actualHours > 0) {
                    status = 'completed';
                    statusLabel = '完了';
                } else if (estimatedHours > 0) {
                    if (eac <= estimatedHours) {
                        status = 'ontrack';
                        statusLabel = '順調';
                    } else if (eac <= estimatedHours * 1.2) {
                        status = 'warning';
                        statusLabel = '注意';
                    } else {
                        status = 'exceeded';
                        statusLabel = '超過';
                    }
                }
                statusCell.innerHTML = createStatusBadge(status, statusLabel);
            } else {
                eacCell.textContent = '-';
                statusCell.innerHTML = createStatusBadge('unknown', '未設定');
            }
        }

        // 一括編集を保存
        function saveBulkRemaining() {
            const rows = document.querySelectorAll('#bulkRemainingTableBody tr[data-row-index]');
            let savedCount = 0;

            rows.forEach(row => {
                const version = row.dataset.version;
                const task = row.dataset.task;
                const process = row.dataset.process;
                const member = row.dataset.member;
                const input = row.querySelector('.bulk-remaining-input');
                const value = input?.value;

                if (value !== '' && !isNaN(parseFloat(value))) {
                    saveRemainingEstimate(version, task, process, member, parseFloat(value));
                    savedCount++;
                }
            });

            saveData();
            closeBulkRemainingModal();
            updateReport();

            alert(`${savedCount}件の見込残存時間を保存しました`);
        }

        function editEstimate(id) {
            const estimate = estimates.find(e => e.id === id);
            if (!estimate) {
                alert('データが見つかりません');
                return;
            }

            // フォームに既存データを設定
            document.getElementById('editEstimateId').value = id;
            document.getElementById('editEstimateVersion').value = estimate.version;
            document.getElementById('editEstimateTaskSearch').value = estimate.task;
            document.getElementById('editEstimateProcess').value = estimate.process;
            document.getElementById('editEstimateHours').value = estimate.hours;

            // 対応名リストを生成
            const taskDatalist = document.getElementById('editEstimateTaskList');
            taskDatalist.innerHTML = '';
            const uniqueTasks = [...new Set([...estimates.map(e => e.task), ...actuals.map(a => a.task)])];
            uniqueTasks.sort().forEach(task => {
                const option = document.createElement('option');
                option.value = task;
                taskDatalist.appendChild(option);
            });

            // 担当者選択肢を更新
            const memberSelect = document.getElementById('editEstimateMember');
            const allMembers = new Set();
            estimates.forEach(e => allMembers.add(e.member));
            actuals.forEach(a => allMembers.add(a.member));

            let sortedMembers;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];

                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });

                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });

                sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                sortedMembers = Array.from(allMembers).sort();
            }

            memberSelect.innerHTML = '';
            sortedMembers.forEach(member => {
                const option = document.createElement('option');
                option.value = member;
                option.textContent = member;
                memberSelect.appendChild(option);
            });

            memberSelect.value = estimate.member;

            // 作業月の選択肢を更新
            const workMonthSelect = document.getElementById('editEstimateWorkMonth');
            workMonthSelect.innerHTML = '<option value="">-- 作業月を選択 --</option>';

            // 見積データから作業月を抽出してソート
            const workMonths = [...new Set(estimates.map(e => e.workMonth).filter(m => m))];
            workMonths.sort();

            workMonths.forEach(month => {
                const option = document.createElement('option');
                option.value = month;
                option.textContent = month;
                workMonthSelect.appendChild(option);
            });

            // 現在の作業月を設定
            workMonthSelect.value = estimate.workMonth || '';

            // 複数月設定の検出と表示モード切り替え
            const est = normalizeEstimate(estimate);
            if (est.workMonths && est.workMonths.length > 1) {
                // 複数月モードに切り替え
                document.querySelector('input[name="editWorkMonthMode"][value="multi"]').checked = true;
                toggleEditWorkMonthMode();

                // 開始月・終了月の選択肢を生成
                generateMonthOptions('editStartMonth', est.workMonths[0]);
                generateMonthOptions('editEndMonth', est.workMonths[est.workMonths.length - 1]);

                // 開始月・終了月を設定
                document.getElementById('editStartMonth').value = est.workMonths[0];
                document.getElementById('editEndMonth').value = est.workMonths[est.workMonths.length - 1];

                // 月別工数が設定されているか確認
                if (est.monthlyHours && Object.keys(est.monthlyHours).length > 0) {
                    // 手動設定モードで各月の工数を表示
                    document.querySelector('input[name="editSplitMethod"][value="manual"]').checked = true;
                }

                updateEditMonthPreview();
            } else {
                // 単一月モード（既存の処理）
                document.querySelector('input[name="editWorkMonthMode"][value="single"]').checked = true;
                toggleEditWorkMonthMode();
            }

            // モーダルを表示
            document.getElementById('editEstimateModal').style.display = 'flex';
        }

        function closeEditEstimateModal() {
            document.getElementById('editEstimateModal').style.display = 'none';
        }

        function saveEstimateEdit() {
            const id = parseFloat(document.getElementById('editEstimateId').value);
            const version = document.getElementById('editEstimateVersion').value;
            const task = document.getElementById('editEstimateTaskSearch').value;
            const process = document.getElementById('editEstimateProcess').value;
            const member = document.getElementById('editEstimateMember').value;
            const hours = parseFloat(document.getElementById('editEstimateHours').value);
            const mode = document.querySelector('input[name="editWorkMonthMode"]:checked').value;

            if (!version || !task || !process || !member || !hours) {
                alert('すべての項目を入力してください');
                return;
            }

            // データを更新
            const estimateIndex = estimates.findIndex(e => e.id === id);
            if (estimateIndex === -1) {
                showAlert('データの更新に失敗しました', false);
                return;
            }

            let workMonth = '';
            let workMonths = [];
            let monthlyHours = {};

            if (mode === 'single') {
                // 単一月モード
                workMonth = document.getElementById('editEstimateWorkMonth').value;
                if (workMonth) {
                    workMonths = [workMonth];
                    monthlyHours = { [workMonth]: hours };
                }
            } else {
                // 複数月モード
                const startMonth = document.getElementById('editStartMonth').value;
                const endMonth = document.getElementById('editEndMonth').value;
                const method = document.querySelector('input[name="editSplitMethod"]:checked').value;

                if (!startMonth || !endMonth) {
                    alert('作業期間を正しく設定してください');
                    return;
                }

                if (startMonth > endMonth) {
                    alert('開始月は終了月より前にしてください');
                    return;
                }

                const months = generateMonthRange(startMonth, endMonth);
                workMonth = startMonth; // 最初の月を代表として設定
                workMonths = months;

                if (method === 'equal') {
                    // 均等分割
                    const hoursPerMonth = hours / months.length;
                    months.forEach(month => {
                        monthlyHours[month] = hoursPerMonth;
                    });
                } else {
                    // 手動設定
                    let total = 0;
                    months.forEach((month, index) => {
                        const input = document.getElementById(`editMonthHours_${index}`);
                        const monthHours = input ? parseFloat(input.value) || 0 : 0;
                        monthlyHours[month] = monthHours;
                        total += monthHours;
                    });

                    // 合計チェック
                    if (Math.abs(total - hours) > 0.01) {
                        alert(`月別工数の合計(${total.toFixed(1)}h)が総工数(${hours}h)と一致しません`);
                        return;
                    }
                }
            }

            // 元の見積データを保存（見込残存時間の更新判定に使用）
            const oldEstimate = estimates[estimateIndex];

            // 見積データを更新
            estimates[estimateIndex] = {
                ...estimates[estimateIndex],
                version: version,
                task: task,
                process: process,
                member: member,
                hours: hours,
                workMonth: workMonth,
                workMonths: workMonths,
                monthlyHours: monthlyHours
            };

            // 見込残存時間の更新判定
            // 既存の見込残存時間が未入力の場合のみ、新しい見積時間で更新
            const existingRemaining = remainingEstimates.find(r =>
                r.version === oldEstimate.version &&
                r.task === oldEstimate.task &&
                r.process === oldEstimate.process &&
                r.member === oldEstimate.member
            );

            if (!existingRemaining) {
                // 見込残存時間が未入力の場合、新しい見積時間で設定
                saveRemainingEstimate(version, task, process, member, hours);
            }

            saveData();
            closeEditEstimateModal();

            updateMemberOptions();
            updateQuickTaskList();
            renderEstimateList();
            updateReport();

            showAlert('見積データを更新しました', true);
        }

        // 作業月モードの切り替え
        function toggleEditWorkMonthMode() {
            const mode = document.querySelector('input[name="editWorkMonthMode"]:checked').value;
            const singleSection = document.getElementById('editSingleMonthSection');
            const multiSection = document.getElementById('editMultiMonthSection');

            if (mode === 'single') {
                singleSection.style.display = 'block';
                multiSection.style.display = 'none';
            } else {
                singleSection.style.display = 'none';
                multiSection.style.display = 'block';

                // 月選択肢を初期化
                const startMonthSelect = document.getElementById('editStartMonth');
                const endMonthSelect = document.getElementById('editEndMonth');
                if (!startMonthSelect.value) {
                    // 単一月で登録されていた月を取得（なければ現在月）
                    const singleMonthValue = document.getElementById('editEstimateWorkMonth').value;
                    let defaultMonth;
                    if (singleMonthValue) {
                        defaultMonth = singleMonthValue;
                    } else {
                        const now = new Date();
                        defaultMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                    }
                    generateMonthOptions('editStartMonth', defaultMonth);
                    generateMonthOptions('editEndMonth', defaultMonth);
                }

                updateEditMonthPreview();
            }
        }

        // 編集モーダルの月別プレビュー更新
        function updateEditMonthPreview() {
            const totalHours = parseFloat(document.getElementById('editEstimateHours').value) || 0;
            const startMonth = document.getElementById('editStartMonth').value;
            const endMonth = document.getElementById('editEndMonth').value;
            const method = document.querySelector('input[name="editSplitMethod"]:checked').value;
            const preview = document.getElementById('editMonthPreview');

            if (!startMonth || !endMonth || totalHours <= 0) {
                preview.innerHTML = '<p style="color: #999; font-size: 14px;">総工数と作業期間を入力してください</p>';
                return;
            }

            if (startMonth > endMonth) {
                preview.innerHTML = '<p style="color: #e74c3c; font-size: 14px;">⚠️ 開始月は終了月より前にしてください</p>';
                return;
            }

            const months = generateMonthRange(startMonth, endMonth);

            // 既存の月別工数データを取得（編集中の場合）
            const estimateId = parseFloat(document.getElementById('editEstimateId').value);
            const currentEstimate = estimates.find(e => e.id === estimateId);
            const normalizedEstimate = normalizeEstimate(currentEstimate);
            const currentMonthlyHours = normalizedEstimate && normalizedEstimate.monthlyHours ? normalizedEstimate.monthlyHours : {};

            let html = '<div style="background: white; padding: 15px; border-radius: 5px; border: 1px solid #3498db; max-height: 300px; overflow-y: auto;">';
            html += '<strong style="color: #2c3e50;">📋 月別工数</strong><br>';
            html += '<div style="margin-top: 10px;">';

            if (method === 'equal') {
                const hoursPerMonth = (totalHours / months.length).toFixed(1);
                months.forEach(month => {
                    const [y, m] = month.split('-');
                    html += `<div style="padding: 5px 0; border-bottom: 1px solid #eee;">`;
                    html += `${y}年${parseInt(m)}月: <strong>${hoursPerMonth}h</strong>`;
                    html += `</div>`;
                });
                html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #3498db; font-weight: 600;">`;
                html += `合計: ${totalHours}h (${months.length}ヶ月)`;
                html += `</div>`;
            } else {
                // 手動設定UI
                let calculatedTotal = 0;
                months.forEach((month, index) => {
                    const [y, m] = month.split('-');
                    // 既存データがあればそれを初期値に、なければ0
                    const existingHours = currentMonthlyHours[month] !== undefined ? currentMonthlyHours[month] : 0;
                    calculatedTotal += existingHours;
                    html += `<div style="padding: 5px 0; display: flex; align-items: center; gap: 10px;">`;
                    html += `<label style="flex: 1;">${y}年${parseInt(m)}月:</label>`;
                    html += `<input type="number" id="editMonthHours_${index}" value="${existingHours}" step="0.1" min="0" `;
                    html += `onchange="updateEditManualTotal()" style="width: 100px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;"> h`;
                    html += `</div>`;
                });

                // HTMLを設定
                html += `<div id="editManualTotal" style="margin-top: 10px; padding-top: 10px; border-top: 2px solid #3498db; font-weight: 600;">`;
                const isMatch = Math.abs(calculatedTotal - totalHours) < 0.01;
                const color = isMatch ? '#27ae60' : '#e74c3c';
                html += `合計: <span style="color: ${color};">${calculatedTotal.toFixed(1)}h</span> / 目標: ${totalHours}h`;
                html += `</div>`;
            }

            html += '</div></div>';
            preview.innerHTML = html;
        }

        // 手動設定の合計更新
        function updateEditManualTotal() {
            const totalHours = parseFloat(document.getElementById('editEstimateHours').value) || 0;
            const startMonth = document.getElementById('editStartMonth').value;
            const endMonth = document.getElementById('editEndMonth').value;

            if (!startMonth || !endMonth) return;

            const months = generateMonthRange(startMonth, endMonth);
            let total = 0;

            months.forEach((month, index) => {
                const input = document.getElementById(`editMonthHours_${index}`);
                if (input) {
                    total += parseFloat(input.value) || 0;
                }
            });

            const totalDiv = document.getElementById('editManualTotal');
            if (totalDiv) {
                const diff = total - totalHours;
                const color = Math.abs(diff) < 0.01 ? '#27ae60' : (diff > 0 ? '#e74c3c' : '#f39c12');
                totalDiv.innerHTML = `合計: <span style="color: ${color};">${total.toFixed(1)}h</span> / 目標: ${totalHours}h`;

                if (Math.abs(diff) < 0.01) {
                    totalDiv.innerHTML += ' <span style="color: #27ae60;">✓</span>';
                } else if (diff > 0) {
                    totalDiv.innerHTML += ` <span style="color: #e74c3c;">(+${diff.toFixed(1)}h 超過)</span>`;
                } else {
                    totalDiv.innerHTML += ` <span style="color: #f39c12;">(${diff.toFixed(1)}h 不足)</span>`;
                }
            }
        }

        // 総工数変更時の同期処理
        function syncEditTotalHours() {
            const mode = document.querySelector('input[name="editWorkMonthMode"]:checked');
            if (mode && mode.value === 'multi') {
                updateEditMonthPreview();
            }
        }

        function handleActualTaskSelect() {
            const select = document.getElementById('editActualTaskSelect');
            const input = document.getElementById('editActualTaskSearch');
            const selectedOption = select.options[select.selectedIndex];

            if (select.value === '__NEW__') {
                // 新規入力モード
                select.style.display = 'none';
                input.style.display = 'block';
                input.value = '';
                input.focus();
            } else if (select.value) {
                // 既存の対応を選択
                const version = selectedOption.getAttribute('data-version');
                const process = selectedOption.getAttribute('data-process');

                if (version) {
                    document.getElementById('editActualVersion').value = version;
                }
                if (process) {
                    document.getElementById('editActualProcess').value = process;
                }
            }
        }

        function handleActualTaskInput() {
            // 新規入力時の処理（将来的に拡張可能）
        }

        function handleEstimateTaskInput() {
            // 対応名入力時の処理（将来的に拡張可能）
        }

        // 対応名をクリックして編集
        function editTask(version, taskName) {
            document.getElementById('editTaskOldVersion').value = version;
            document.getElementById('editTaskOldName').value = taskName;

            // 版数リストを更新
            const versionSelect = document.getElementById('editTaskVersion');
            const versions = [...new Set(estimates.map(e => e.version))].sort();
            versionSelect.innerHTML = '<option value="">-- 版数を選択 --</option>';
            versions.forEach(v => {
                const option = document.createElement('option');
                option.value = v;
                option.textContent = v;
                versionSelect.appendChild(option);
            });
            versionSelect.value = version;

            // 対応名を帳票名と対応名に分割
            let formName = '';
            let task = '';
            if (taskName.includes('：')) {
                const parts = taskName.split('：');
                formName = parts[0];
                task = parts.slice(1).join('：');
            } else if (taskName.includes('_')) {
                const parts = taskName.split('_');
                formName = parts[0];
                task = parts.slice(1).join('_');
            } else {
                task = taskName;
            }

            // 帳票名をselectに設定（既存の帳票名なら選択、なければ新規入力モード）
            const formNameSelect = document.getElementById('editTaskFormNameSelect');
            const formNameInput = document.getElementById('editTaskFormName');

            // selectに既に帳票名オプションが存在するか確認
            let formNameExists = false;
            for (let i = 0; i < formNameSelect.options.length; i++) {
                if (formNameSelect.options[i].value === formName) {
                    formNameExists = true;
                    break;
                }
            }

            if (formNameExists) {
                // 既存の帳票名を選択
                formNameSelect.value = formName;
                formNameSelect.style.display = 'block';
                formNameInput.style.display = 'none';
                formNameInput.value = formName;
            } else {
                // 新規入力モード
                formNameSelect.value = '__new__';
                formNameSelect.style.display = 'none';
                formNameInput.style.display = 'block';
                formNameInput.value = formName;
            }

            document.getElementById('editTaskName').value = task;

            // モーダルを表示
            document.getElementById('editTaskModal').style.display = 'flex';
        }

        function closeEditTaskModal() {
            document.getElementById('editTaskModal').style.display = 'none';
        }

        function saveTaskEdit() {
            const oldVersion = document.getElementById('editTaskOldVersion').value;
            const oldTaskName = document.getElementById('editTaskOldName').value;
            const newVersion = document.getElementById('editTaskVersion').value;

            // 帳票名を取得（selectまたはinputから）
            const formNameSelect = document.getElementById('editTaskFormNameSelect');
            const formNameInput = document.getElementById('editTaskFormName');
            const formName = (formNameInput.style.display === 'none' ? formNameSelect.value : formNameInput.value).trim();

            const taskName = document.getElementById('editTaskName').value.trim();

            if (!newVersion || !formName || !taskName) {
                alert('すべての項目を入力してください');
                return;
            }

            // 帳票名と対応名を結合
            const newTaskName = `${formName}：${taskName}`;

            if (oldVersion === newVersion && oldTaskName === newTaskName) {
                alert('版数と対応名が変更されていません');
                return;
            }

            // 該当する見積データを更新
            let updatedCount = 0;
            estimates.forEach((est, index) => {
                if (est.version === oldVersion && est.task === oldTaskName) {
                    estimates[index] = {
                        ...est,
                        version: newVersion,
                        task: newTaskName
                    };
                    updatedCount++;
                }
            });

            // 実績データも更新
            let actualUpdateCount = 0;
            actuals.forEach((act, index) => {
                if (act.version === oldVersion && act.task === oldTaskName) {
                    actuals[index] = {
                        ...act,
                        version: newVersion,
                        task: newTaskName
                    };
                    actualUpdateCount++;
                }
            });

            if (updatedCount > 0) {
                saveData();
                closeEditTaskModal();

                updateMemberOptions();
                updateQuickTaskList();
                renderEstimateList();
                updateReport();

                let message = `${updatedCount}件の見積データを変更しました`;
                if (actualUpdateCount > 0) {
                    message += `\n${actualUpdateCount}件の実績データも変更しました`;
                }
                alert(message);
            } else {
                alert('変更対象のデータが見つかりませんでした');
            }
        }

        // 工程内訳モーダルを表示
        function showProcessBreakdown(version, task, process, filteredActuals, filteredEstimates) {
            const modal = document.getElementById('processBreakdownModal');
            const title = document.getElementById('breakdownModalTitle');
            const content = document.getElementById('breakdownModalContent');

            // タイトルを設定
            title.textContent = `${version} - ${task} [${process}] の内訳`;

            // 担当者別にデータを集計
            const memberData = {};

            // 見積データを集計
            filteredEstimates.forEach(e => {
                if (e.version === version && e.task === task && e.process === process) {
                    if (!memberData[e.member]) {
                        memberData[e.member] = { estimate: 0, actual: 0 };
                    }
                    memberData[e.member].estimate += e.hours;
                }
            });

            // 実績データを集計
            filteredActuals.forEach(a => {
                if (a.version === version && a.task === task && a.process === process) {
                    if (!memberData[a.member]) {
                        memberData[a.member] = { estimate: 0, actual: 0 };
                    }
                    memberData[a.member].actual += a.hours;
                }
            });

            // 担当者が複数いる場合のみ内訳を表示
            const members = Object.keys(memberData);
            if (members.length === 0) {
                content.innerHTML = '<p style="text-align: center; color: #999;">データがありません</p>';
                modal.style.display = 'flex';
                return;
            }

            if (members.length === 1) {
                content.innerHTML = '<p style="text-align: center; color: #999;">この工程は1人が担当しています</p>';
                modal.style.display = 'flex';
                return;
            }

            // 合計値を計算
            let totalEst = 0;
            let totalAct = 0;
            members.forEach(member => {
                const data = memberData[member];
                totalEst += data.estimate;
                totalAct += data.actual;
            });

            // HTMLを生成（グラフとテーブル）
            let html = '<div style="display: flex; flex-direction: column; gap: 30px;">';

            // グラフコンテナ
            html += '<div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">';

            // 見積グラフ
            if (totalEst > 0) {
                html += '<div style="flex: 1; min-width: 250px; max-width: 350px;">';
                html += '<h4 style="text-align: center; margin: 0 0 10px 0; color: #495057; font-size: 14px;">見積内訳</h4>';
                html += '<canvas id="breakdownEstimateChart" class="donut-chart-canvas"></canvas>';
                html += '</div>';
            }

            // 実績グラフ
            if (totalAct > 0) {
                html += '<div style="flex: 1; min-width: 250px; max-width: 350px;">';
                html += '<h4 style="text-align: center; margin: 0 0 10px 0; color: #495057; font-size: 14px;">実績内訳</h4>';
                html += '<canvas id="breakdownActualChart" class="donut-chart-canvas"></canvas>';
                html += '</div>';
            }

            html += '</div>';

            // テーブルを生成
            html += '<div class="table-wrapper"><table>';
            html += '<tr><th>担当者</th><th>見積</th><th>実績</th><th>差異</th></tr>';

            members.sort().forEach(member => {
                const data = memberData[member];
                const diff = data.actual - data.estimate;

                html += '<tr>';
                html += `<td><strong>${member}</strong></td>`;
                html += `<td style="text-align: right;">${data.estimate.toFixed(1)}h</td>`;
                html += `<td style="text-align: right;">${data.actual.toFixed(1)}h</td>`;
                html += `<td style="text-align: right; color: ${diff >= 0 ? '#e74c3c' : '#27ae60'}">${(diff >= 0 ? '+' : '')}${diff.toFixed(1)}h</td>`;
                html += '</tr>';
            });

            // 合計行
            const totalDiff = totalAct - totalEst;
            html += '<tr style="background: #f5f5f5; font-weight: bold; border-top: 2px solid #ddd;">';
            html += '<td>合計</td>';
            html += `<td style="text-align: right;">${totalEst.toFixed(1)}h</td>`;
            html += `<td style="text-align: right;">${totalAct.toFixed(1)}h</td>`;
            html += `<td style="text-align: right; color: ${totalDiff >= 0 ? '#e74c3c' : '#27ae60'}">${(totalDiff >= 0 ? '+' : '')}${totalDiff.toFixed(1)}h</td>`;
            html += '</tr>';

            html += '</table></div>';
            html += '</div>';

            content.innerHTML = html;

            // グラフを描画
            setTimeout(() => {
                if (totalEst > 0) {
                    drawBreakdownDonutChart('breakdownEstimateChart', memberData, 'estimate', members, totalEst);
                }
                if (totalAct > 0) {
                    drawBreakdownDonutChart('breakdownActualChart', memberData, 'actual', members, totalAct);
                }
            }, 0);

            modal.style.display = 'flex';
        }

        // 工程内訳ドーナツグラフを描画
        function drawBreakdownDonutChart(canvasId, memberData, dataType, members, total) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // キャンバスのサイズを設定
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            const isMobile = width < 768;
            const legendHeight = members.length * 16 + 20;
            const centerX = width / 2;
            const centerY = isMobile ? (height - legendHeight) / 2 : height / 2 - 10;
            const radius = isMobile
                ? Math.min(width, height - legendHeight - 40) / 2.5
                : Math.min(width, height - 40) / 2.2;
            const innerRadius = radius * 0.5;

            // 担当者の色を取得（パステルカラー）
            const memberColors = [
                '#667eea', '#f093fb', '#4facfe', '#43e97b',
                '#fa709a', '#30cfd0', '#a8edea', '#fbc2eb',
                '#96e6a1', '#d4fc79', '#84fab0', '#8fd3f4'
            ];

            const getMemberColor = (index) => {
                return memberColors[index % memberColors.length];
            };

            // ドーナツを描画
            let startAngle = -Math.PI / 2;
            members.forEach((member, index) => {
                const value = memberData[member][dataType];
                if (value === 0) return;

                const angle = (value / total) * 2 * Math.PI;
                const endAngle = startAngle + angle;

                ctx.fillStyle = getMemberColor(index);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fill();

                startAngle = endAngle;
            });

            // 中央に合計を表示
            ctx.fillStyle = '#495057';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(total.toFixed(1) + 'h', centerX, centerY - 5);
            ctx.font = '11px sans-serif';
            ctx.fillText(dataType === 'estimate' ? '合計見積' : '合計実績', centerX, centerY + 12);

            // 凡例を描画
            const legendX = 10;
            const legendStartY = isMobile
                ? centerY + radius + 20
                : height - 10 - (members.length * 16);
            let legendY = legendStartY;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.font = isMobile ? '10px sans-serif' : '11px sans-serif';

            members.forEach((member, index) => {
                const value = memberData[member][dataType];
                if (value === 0) return;

                const percentage = (value / total * 100).toFixed(1);

                ctx.fillStyle = getMemberColor(index);
                ctx.fillRect(legendX, legendY, 10, 10);

                ctx.fillStyle = '#495057';
                const label = `${member} (${percentage}%)`;
                ctx.fillText(label, legendX + 15, legendY + 5);

                legendY += isMobile ? 14 : 16;
            });
        }

        function closeProcessBreakdownModal() {
            document.getElementById('processBreakdownModal').style.display = 'none';
        }

        // 見込残存時間入力モーダルを開く
        function openRemainingHoursModal(version, task, process) {
            // 工程の担当者を取得
            const estMembers = new Set();
            const actMembers = new Set();

            estimates.forEach(e => {
                if (e.version === version && e.task === task && e.process === process) {
                    estMembers.add(e.member);
                }
            });

            actuals.forEach(a => {
                if (a.version === version && a.task === task && a.process === process) {
                    actMembers.add(a.member);
                }
            });

            const allMembers = [...new Set([...estMembers, ...actMembers])].sort();

            // 情報表示エリアを更新
            document.getElementById('remainingHoursInfo').innerHTML = `
                <div><strong>版数:</strong> ${version}</div>
                <div><strong>対応名:</strong> ${task}</div>
                <div><strong>工程:</strong> ${process}</div>
            `;

            // 担当者設定
            const select = document.getElementById('remainingHoursMember');
            if (allMembers.length > 1) {
                // 担当者が複数いる場合は選択できるようにする
                document.getElementById('remainingHoursMemberSelect').style.display = 'block';
                select.innerHTML = allMembers.map(m => `<option value="${m}">${m}</option>`).join('');

                // 最初の担当者の見込残存時間と実績リストを表示
                updateRemainingHoursInput(version, task, process, allMembers[0]);
                updateRemainingHoursActualsList(version, task, process, allMembers[0]);

                // 担当者変更時に見込残存時間と実績リストを更新
                select.onchange = function() {
                    updateRemainingHoursInput(version, task, process, this.value);
                    updateRemainingHoursActualsList(version, task, process, this.value);
                };
            } else if (allMembers.length === 1) {
                // 担当者が1人の場合は非表示だが、selectには値を設定
                document.getElementById('remainingHoursMemberSelect').style.display = 'none';
                select.innerHTML = `<option value="${allMembers[0]}">${allMembers[0]}</option>`;
                select.value = allMembers[0];
                updateRemainingHoursInput(version, task, process, allMembers[0]);
                updateRemainingHoursActualsList(version, task, process, allMembers[0]);
            } else {
                // 担当者がいない場合
                document.getElementById('remainingHoursMemberSelect').style.display = 'none';
                select.innerHTML = '';
                document.getElementById('remainingHoursInput').value = '';
                document.getElementById('remainingHoursActualsList').style.display = 'none';
            }

            // モーダルにデータを保存
            document.getElementById('remainingHoursModal').dataset.version = version;
            document.getElementById('remainingHoursModal').dataset.task = task;
            document.getElementById('remainingHoursModal').dataset.process = process;

            // モーダルを表示
            document.getElementById('remainingHoursModal').style.display = 'flex';
        }

        // 見込残存時間の入力フィールドを更新
        function updateRemainingHoursInput(version, task, process, member) {
            const existing = remainingEstimates.find(r =>
                r.version === version &&
                r.task === task &&
                r.process === process &&
                r.member === member
            );

            document.getElementById('remainingHoursInput').value = existing ? existing.remainingHours : '';
        }

        // 実績リストを更新（現在の表示条件でフィルタ）
        function updateRemainingHoursActualsList(version, task, process, member) {
            // 現在のレポートのフィルタ条件を取得
            const filterType = document.getElementById('reportFilterType').value;
            const filterMonth = document.getElementById('reportMonth').value;
            const filterVersion = document.getElementById('reportVersion').value;

            // 該当する実績を取得
            let filteredActuals = actuals.filter(a =>
                a.version === version &&
                a.task === task &&
                a.process === process &&
                a.member === member
            );

            // フィルタ条件に基づいてさらに絞り込み
            if (filterType === 'month' && filterMonth !== 'all') {
                filteredActuals = filteredActuals.filter(a => a.date && a.date.startsWith(filterMonth));
            } else if (filterType === 'version' && filterVersion !== 'all') {
                filteredActuals = filteredActuals.filter(a => a.version === filterVersion);
            }

            // 日付でソート（新しい順）
            filteredActuals.sort((a, b) => {
                const dateA = a.date || '';
                const dateB = b.date || '';
                return dateB.localeCompare(dateA);
            });

            const actualsListDiv = document.getElementById('remainingHoursActualsList');
            const actualsContentDiv = document.getElementById('remainingHoursActualsContent');

            if (filteredActuals.length === 0) {
                actualsListDiv.style.display = 'none';
            } else {
                actualsListDiv.style.display = 'block';

                // 実績リストのHTML生成
                let html = '<div style="font-size: 13px;">';

                // 各実績を表示
                filteredActuals.forEach((actual, index) => {
                    const dateStr = actual.date ? actual.date : '日付なし';
                    const bgColor = index % 2 === 0 ? 'white' : '#f1f3f5';

                    html += `
                        <div style="padding: 8px; background: ${bgColor}; border-radius: 4px; margin-bottom: 4px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 500; color: #333;">${dateStr}</div>
                                ${actual.memo ? `<div style="color: #666; font-size: 12px; margin-top: 2px;">${actual.memo}</div>` : ''}
                            </div>
                            <div style="font-weight: 600; color: #495057; white-space: nowrap; margin-left: 12px;">${actual.hours.toFixed(1)}h</div>
                        </div>
                    `;
                });

                // 合計時間を計算して最後に表示
                const totalHours = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
                html += `<div style="margin-top: 10px; padding: 8px; background: white; border-radius: 4px; font-weight: 600; color: #333;">合計: ${totalHours.toFixed(1)}h</div>`;

                html += '</div>';
                actualsContentDiv.innerHTML = html;
            }
        }

        // 見込残存時間モーダルを閉じる
        function closeRemainingHoursModal() {
            document.getElementById('remainingHoursModal').style.display = 'none';
        }

        // 見込残存時間を保存
        function saveRemainingHoursFromModal() {
            const modal = document.getElementById('remainingHoursModal');
            const version = modal.dataset.version;
            const task = modal.dataset.task;
            const process = modal.dataset.process;
            const member = document.getElementById('remainingHoursMember').value;
            const hours = parseFloat(document.getElementById('remainingHoursInput').value);

            if (!member) {
                alert('担当者が設定されていません');
                return;
            }

            if (isNaN(hours) || hours < 0) {
                alert('正しい時間を入力してください');
                return;
            }

            // 見込残存時間を保存
            saveRemainingEstimate(version, task, process, member, hours);
            saveData(true);

            // モーダルを閉じてから画面を更新
            closeRemainingHoursModal();

            // レポートを更新
            updateReport();

            showAlert('見込残存時間を保存しました', true);
        }

        function showMemberOrderHelp() {
            alert('担当者の表示順を指定できます。\n\n例:\nA,B,C,D\n山田,佐藤,田中\n\n・カンマ区切りで入力\n・指定した順番で表示されます\n・指定していない担当者は後ろにアルファベット順で表示されます');
        }

        function updateAllDisplays() {
            saveData();
            updateMemberOptions();
            renderActualList();
            updateReport();
            showAlert('設定を適用しました', true);
        }
        
        // テーマ関連の関数
        function loadThemeSettings() {
            // データから読み込み（優先）
            const savedSettings = localStorage.getItem('manhour_settings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                if (settings.themeColor) {
                    currentThemeColor = settings.themeColor;
                    document.getElementById('themeColor').value = settings.themeColor;
                }
                if (settings.themePattern) {
                    currentThemePattern = settings.themePattern;
                    document.getElementById('themePattern').value = settings.themePattern;
                }
                if (settings.themeTabColor) {
                    currentTabColor = settings.themeTabColor;
                    document.getElementById('themeTabColor').value = settings.themeTabColor;
                }
                if (settings.themeBackgroundColor) {
                    currentBackgroundColor = settings.themeBackgroundColor;
                    document.getElementById('themeBackgroundColor').value = settings.themeBackgroundColor;
                }
            } else {
                // 旧形式から読み込み（後方互換性）
                const savedColor = localStorage.getItem('manhour_themeColor');
                const savedPattern = localStorage.getItem('manhour_themePattern');
                const savedTabColor = localStorage.getItem('manhour_themeTabColor');
                
                if (savedColor) {
                    currentThemeColor = savedColor;
                    document.getElementById('themeColor').value = savedColor;
                }
                
                if (savedPattern) {
                    currentThemePattern = savedPattern;
                    document.getElementById('themePattern').value = savedPattern;
                }
                
                if (savedTabColor) {
                    currentTabColor = savedTabColor;
                    document.getElementById('themeTabColor').value = savedTabColor;
                }
            }
            
            applyTheme();
        }
        
        function applyTheme() {
            const color = document.getElementById('themeColor').value;
            const pattern = document.getElementById('themePattern').value;
            const tabColor = document.getElementById('themeTabColor').value;
            const backgroundColor = document.getElementById('themeBackgroundColor').value;

            currentThemeColor = color;
            currentThemePattern = pattern;
            currentTabColor = tabColor;
            currentBackgroundColor = backgroundColor;

            // プレビューを更新
            updateThemePreview();

            // 全ての該当要素にテーマを適用
            updateThemeElements();

            // グラフカラースキームが'auto'の場合、プレビューとグラフを更新
            if (selectedChartColorScheme === 'auto') {
                updateChartColorPreview();
                // レポートタブがアクティブな場合、グラフを再描画
                const reportTab = document.getElementById('report');
                if (reportTab && reportTab.classList.contains('active')) {
                    updateReport();
                }
            }

            // データに保存
            saveData(true); // 自動バックアップはスキップ
        }
        
        function updateThemePreview() {
            const preview = document.getElementById('themePreview');
            const colorClass = `theme-${currentThemeColor}`;
            const patternClass = currentThemePattern !== 'none' ? `pattern-${currentThemePattern}` : '';
            
            // 既存のクラスを削除
            preview.className = '';
            preview.classList.add('theme-bg', colorClass);
            if (patternClass) {
                preview.classList.add(patternClass);
            }
        }
        
        function updateThemeElements() {
            // ページ全体の背景
            updateBodyBackground();

            // クイック入力エリア
            const quickInput = document.querySelector('.quick-input');
            if (quickInput) {
                updateElementTheme(quickInput);
            }

            // レポートサマリーカード
            const summaryCards = document.querySelectorAll('.stats-grid .stat-card');
            summaryCards.forEach(card => updateElementTheme(card));

            // 版数ヘッダー
            const versionHeaders = document.querySelectorAll('.version-header');
            versionHeaders.forEach(header => updateElementTheme(header));

            // アクティブタブ
            const activeTab = document.querySelector('.tab.active');
            if (activeTab) {
                updateElementTheme(activeTab);
            }

            // モーダルヘッダー
            const modalHeaders = document.querySelectorAll('.modal-header');
            modalHeaders.forEach(header => {
                // 既存のモーダルテーマクラスを削除
                header.className = header.className.replace(/modal-theme-\w+/g, '').trim();
                header.classList.add('modal-header', `modal-theme-${currentThemeColor}`);
            });

            // 設定タブのレイアウト切り替えボタン
            updateLayoutToggleButtons();

            // セグメントボタンの色を更新
            updateSegmentedButtons();

            // 見積合計カードの色を更新
            const estimateTotalCard = document.getElementById('estimateTotalCard');
            if (estimateTotalCard) {
                const gradients = {
                    'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                    'teal': 'linear-gradient(135deg, #0f766e 0%, #0d9488 100%)',
                    'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                    'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #075985 100%)',
                    'sky': 'linear-gradient(135deg, #0369a1 0%, #0284c7 100%)',
                    'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                    'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                    'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                    'green': 'linear-gradient(135deg, #047857 0%, #059669 100%)',
                    'emerald': 'linear-gradient(135deg, #059669 0%, #10b981 100%)'
                };
                estimateTotalCard.style.background = gradients[currentThemeColor] || gradients['purple'];
            }

            // 見積一覧の担当者別合計カードの色を更新（見積タブがアクティブな場合のみ）
            const estimateTab = document.getElementById('estimate');
            if (estimateTab && estimateTab.classList.contains('active')) {
                renderEstimateList();
            }

            // フローティングフィルタのテーマを更新
            updateFloatingFilterTheme();
        }

        function updateFloatingFilterTheme() {
            const gradients = {
                'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                'teal': 'linear-gradient(135deg, #0f766e 0%, #0d9488 100%)',
                'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #075985 100%)',
                'sky': 'linear-gradient(135deg, #0369a1 0%, #0284c7 100%)',
                'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                'green': 'linear-gradient(135deg, #047857 0%, #059669 100%)',
                'emerald': 'linear-gradient(135deg, #059669 0%, #10b981 100%)'
            };

            const gradient = gradients[currentThemeColor] || gradients['purple'];

            // トグルボタンの背景を更新
            const toggle = document.getElementById('floatingFilterToggle');
            if (toggle) {
                toggle.style.background = gradient;
            }

            // パネルヘッダーの背景を更新
            const header = document.querySelector('.floating-filter-panel-header');
            if (header) {
                header.style.background = gradient;
            }

            // 全てのボタンの背景をリセットしてから、アクティブボタンのみ更新
            document.querySelectorAll('.floating-filter-buttons button, .floating-segment-buttons button').forEach(btn => {
                if (btn.classList.contains('active')) {
                    btn.style.background = gradient;
                } else {
                    btn.style.background = ''; // インラインスタイルをクリア
                }
            });
        }
        
        function updateBodyBackground() {
            const colorGradients = {
                'purple': 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                'deep-blue': 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                'teal': 'linear-gradient(135deg, #0f766e 0%, #14b8a6 100%)',
                'cyan': 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                'ocean': 'linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%)',
                'sky': 'linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%)',
                'indigo': 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                'navy': 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                'slate': 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                'green': 'linear-gradient(135deg, #047857 0%, #10b981 100%)',
                'emerald': 'linear-gradient(135deg, #059669 0%, #34d399 100%)'
            };
            
            // 背景色を決定（個別設定がある場合はそれを使用、なければメインカラー）
            const bgColorToUse = (currentBackgroundColor && currentBackgroundColor !== 'same') 
                ? currentBackgroundColor 
                : currentThemeColor;
            
            const gradient = colorGradients[bgColorToUse] || colorGradients['purple'];
            document.body.style.background = gradient;
        }
        
        function updateElementTheme(element) {
            const isTab = element.classList.contains('tab');
            
            // タブの色を決定
            let tabColorToUse = currentThemeColor;
            if (isTab) {
                if (currentTabColor === 'same') {
                    tabColorToUse = currentThemeColor;
                } else if (currentTabColor === 'default') {
                    // デフォルト色の場合は何もクラスを追加しない
                    tabColorToUse = null;
                } else {
                    tabColorToUse = currentTabColor;
                }
            }
            
            const colorClass = isTab && tabColorToUse ? `tab-theme-${tabColorToUse}` : `theme-${currentThemeColor}`;
            const patternClass = !isTab && currentThemePattern !== 'none' ? `pattern-${currentThemePattern}` : '';
            
            // theme-で始まるクラス、tab-theme-で始まるクラス、pattern-で始まるクラスを削除
            const classes = Array.from(element.classList);
            classes.forEach(cls => {
                if (cls.startsWith('theme-') || cls.startsWith('pattern-') || cls.startsWith('tab-theme-')) {
                    element.classList.remove(cls);
                }
            });
            
            // 新しいテーマを適用
            if (isTab) {
                // タブの場合
                if (tabColorToUse) {
                    // 色指定あり: tab-theme-クラスを追加
                    element.classList.add(`tab-theme-${tabColorToUse}`);
                }
                // currentTabColor === 'default'の場合は何も追加しない（CSSのフォールバックが適用される）
            } else {
                // タブ以外: theme-bgと色クラスを適用
                element.classList.add('theme-bg', colorClass);
                if (patternClass) {
                    element.classList.add(patternClass);
                }
            }
        }

        // 設定タブのレイアウト切り替えボタンの色を更新
        function updateLayoutToggleButtons() {
            const themeColor = getThemeColor();

            // 見積一覧のボタン
            const estimateButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'estimate\'"]');
            if (estimateButtons.length >= 2) {
                const estimateCompact = document.getElementById('estimateFiltersCompact');
                const isCompactActive = estimateCompact && estimateCompact.style.display !== 'none';
                estimateButtons[0].style.background = isCompactActive ? themeColor : 'white';
                estimateButtons[0].style.color = isCompactActive ? 'white' : '#333';
                estimateButtons[1].style.background = !isCompactActive ? themeColor : 'white';
                estimateButtons[1].style.color = !isCompactActive ? 'white' : '#333';
            }

            // 実績一覧のボタン
            const actualButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'actual\'"]');
            if (actualButtons.length >= 2) {
                const actualCompact = document.getElementById('actualFiltersCompact');
                const isCompactActive = actualCompact && actualCompact.style.display !== 'none';
                actualButtons[0].style.background = isCompactActive ? themeColor : 'white';
                actualButtons[0].style.color = isCompactActive ? 'white' : '#333';
                actualButtons[1].style.background = !isCompactActive ? themeColor : 'white';
                actualButtons[1].style.color = !isCompactActive ? 'white' : '#333';
            }

            // レポートのボタン
            const reportButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'report\'"]');
            if (reportButtons.length >= 2) {
                const reportCompact = document.getElementById('reportFiltersCompact');
                const isCompactActive = reportCompact && reportCompact.style.display !== 'none';
                reportButtons[0].style.background = isCompactActive ? themeColor : 'white';
                reportButtons[0].style.color = isCompactActive ? 'white' : '#333';
                reportButtons[1].style.background = !isCompactActive ? themeColor : 'white';
                reportButtons[1].style.color = !isCompactActive ? 'white' : '#333';
            }
        }

        // セグメントボタンの色を更新
        function updateSegmentedButtons() {
            const themeColor = getThemeColor();

            // 見積一覧のセグメントボタン（表示形式）
            const btnEstimateGrouped = document.getElementById('btnEstimateGrouped');
            const btnEstimateMatrix = document.getElementById('btnEstimateMatrix');
            const btnEstimateList = document.getElementById('btnEstimateList');
            if (btnEstimateGrouped && btnEstimateMatrix && btnEstimateList) {
                const estimateViewType = document.getElementById('estimateViewType').value;
                btnEstimateGrouped.style.background = estimateViewType === 'grouped' ? themeColor : 'white';
                btnEstimateGrouped.style.color = estimateViewType === 'grouped' ? 'white' : '#333';
                btnEstimateMatrix.style.background = estimateViewType === 'matrix' ? themeColor : 'white';
                btnEstimateMatrix.style.color = estimateViewType === 'matrix' ? 'white' : '#333';
                btnEstimateList.style.background = estimateViewType === 'list' ? themeColor : 'white';
                btnEstimateList.style.color = estimateViewType === 'list' ? 'white' : '#333';
            }

            // 見積一覧のセグメントボタン（フィルタタイプ：月別/版数別）
            const estimateFilterType = document.getElementById('estimateFilterType');
            const btnEstimateFilterMonth = document.getElementById('btnEstimateFilterMonth');
            const btnEstimateFilterVersion = document.getElementById('btnEstimateFilterVersion');
            if (estimateFilterType && btnEstimateFilterMonth && btnEstimateFilterVersion) {
                const type = estimateFilterType.value;
                btnEstimateFilterMonth.style.background = type === 'month' ? themeColor : 'white';
                btnEstimateFilterMonth.style.color = type === 'month' ? 'white' : '#333';
                btnEstimateFilterVersion.style.background = type === 'version' ? themeColor : 'white';
                btnEstimateFilterVersion.style.color = type === 'version' ? 'white' : '#333';
            }

            // 見積一覧のセグメントボタン（表示月）
            const estimateMonthButtons = document.getElementById('estimateMonthButtons2');
            if (estimateMonthButtons) {
                const estimateMonthFilter = document.getElementById('estimateMonthFilter');
                if (estimateMonthFilter) {
                    updateSegmentButtonSelection('estimateMonthButtons2', estimateMonthFilter.value);
                }
            }

            // 見積一覧のセグメントボタン（版数）
            const estimateVersionButtons = document.getElementById('estimateVersionButtons2');
            if (estimateVersionButtons) {
                const estimateVersionFilter = document.getElementById('estimateVersionFilter');
                if (estimateVersionFilter) {
                    updateSegmentButtonSelection('estimateVersionButtons2', estimateVersionFilter.value);
                }
            }

            // 実績一覧のセグメントボタン（表示形式）
            const btnActualMatrix = document.getElementById('btnActualMatrix');
            const btnActualList = document.getElementById('btnActualList');
            if (btnActualMatrix && btnActualList) {
                const actualViewType = document.getElementById('actualViewType').value;
                btnActualMatrix.style.background = actualViewType === 'matrix' ? themeColor : 'white';
                btnActualMatrix.style.color = actualViewType === 'matrix' ? 'white' : '#333';
                btnActualList.style.background = actualViewType === 'list' ? themeColor : 'white';
                btnActualList.style.color = actualViewType === 'list' ? 'white' : '#333';
            }

            // 実績一覧のセグメントボタン（担当者）
            const actualMemberButtons = document.getElementById('actualMemberButtons2');
            if (actualMemberButtons) {
                const actualMemberSelect = document.getElementById('actualMemberSelect');
                if (actualMemberSelect) {
                    updateSegmentButtonSelection('actualMemberButtons2', actualMemberSelect.value);
                }
            }

            // 実績一覧のセグメントボタン（表示期間）
            const actualMonthButtons = document.getElementById('actualMonthButtons2');
            if (actualMonthButtons) {
                const actualMonthFilter = document.getElementById('actualMonthFilter');
                if (actualMonthFilter) {
                    updateSegmentButtonSelection('actualMonthButtons2', actualMonthFilter.value);
                }
            }

            // レポートのセグメントボタン（表示形式）
            const btnReportSummary = document.getElementById('btnReportSummary');
            const btnReportGrouped = document.getElementById('btnReportGrouped');
            const btnReportMatrix = document.getElementById('btnReportMatrix');
            if (btnReportSummary && btnReportGrouped && btnReportMatrix) {
                const reportViewType = document.getElementById('reportViewType').value;
                btnReportSummary.style.background = reportViewType === 'summary' ? themeColor : 'white';
                btnReportSummary.style.color = reportViewType === 'summary' ? 'white' : '#333';
                btnReportGrouped.style.background = reportViewType === 'grouped' ? themeColor : 'white';
                btnReportGrouped.style.color = reportViewType === 'grouped' ? 'white' : '#333';
                btnReportMatrix.style.background = reportViewType === 'matrix' ? themeColor : 'white';
                btnReportMatrix.style.color = reportViewType === 'matrix' ? 'white' : '#333';
            }

            // レポートのセグメントボタン（表示月）
            const reportMonthButtons = document.getElementById('reportMonthButtons2');
            if (reportMonthButtons) {
                const reportMonth = document.getElementById('reportMonth');
                if (reportMonth) {
                    updateSegmentButtonSelection('reportMonthButtons2', reportMonth.value);
                }
            }

            // レポートのフィルタタイプボタン（月別/版数別）
            const reportFilterType = document.getElementById('reportFilterType');
            if (reportFilterType) {
                const btnFilterMonth = document.getElementById('btnFilterMonth');
                const btnFilterVersion = document.getElementById('btnFilterVersion');
                if (btnFilterMonth && btnFilterVersion) {
                    const type = reportFilterType.value;
                    btnFilterMonth.style.background = type === 'month' ? themeColor : 'white';
                    btnFilterMonth.style.color = type === 'month' ? 'white' : '#333';
                    btnFilterVersion.style.background = type === 'version' ? themeColor : 'white';
                    btnFilterVersion.style.color = type === 'version' ? 'white' : '#333';
                }
            }
        }

        // モーダル外をクリック/タップで閉じる
        function handleModalClose(event) {
            const workModal = document.getElementById('workModal');
            const editActualModal = document.getElementById('editActualModal');
            const editEstimateModal = document.getElementById('editEstimateModal');
            const splitEstimateModal = document.getElementById('splitEstimateModal');
            const otherWorkModal = document.getElementById('otherWorkModal');

            if (event.target === workModal) {
                event.stopPropagation();
                event.preventDefault();
                closeWorkModal();
            }
            if (event.target === editActualModal) {
                event.stopPropagation();
                event.preventDefault();
                closeEditActualModal();
            }
            if (event.target === editEstimateModal) {
                event.stopPropagation();
                event.preventDefault();
                closeEditEstimateModal();
            }
            if (event.target === splitEstimateModal) {
                event.stopPropagation();
                event.preventDefault();
                closeSplitEstimateModal();
            }
            if (event.target === otherWorkModal) {
                event.stopPropagation();
                event.preventDefault();
                closeOtherWorkModal();
            }
        }
        
        window.onclick = handleModalClose;
        window.ontouchend = handleModalClose;

        // 作業月割り当てモードを閉じる
        function closeWorkMonthAssignmentMode() {
            if (workMonthSelectionMode) {
                const checkbox1 = document.getElementById('workMonthSelectionMode');
                const checkbox2 = document.getElementById('workMonthSelectionMode2');
                if (checkbox1) checkbox1.checked = false;
                if (checkbox2) checkbox2.checked = false;
                toggleWorkMonthSelectionMode();
            }
        }

        // セグメントボタンを生成する汎用関数
        function createSegmentButtons(containerId, selectId, items, currentValue, maxItems, onClickHandler) {
            const container = document.getElementById(containerId);
            const select = document.getElementById(selectId);
            const themeColor = getThemeColor();

            if (!container || !select) return;

            // セグメントボタンを表示（横スクロール対応）
            container.style.display = 'flex';
            container.style.overflowX = 'auto';
            container.style.gap = '0';
            select.style.display = 'none';
            container.innerHTML = '';

            items.forEach((item, index) => {
                const button = document.createElement('button');
                button.textContent = item.label;
                button.value = item.value;
                button.style.cssText = `
                    padding: 4px 12px;
                    font-size: 12px;
                    border: none;
                    cursor: pointer;
                    transition: all 0.2s;
                    white-space: nowrap;
                    flex-shrink: 0;
                    ${index > 0 ? 'border-left: 1px solid #dee2e6;' : ''}
                `;

                // 選択状態のスタイル
                if (item.value === currentValue) {
                    button.style.background = themeColor;
                    button.style.color = 'white';
                } else {
                    button.style.background = 'white';
                    button.style.color = '#333';
                }

                button.onclick = () => onClickHandler(item.value, containerId);
                container.appendChild(button);
            });
        }

        // セグメントボタンの選択状態を更新
        function updateSegmentButtonSelection(containerId, value) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const themeColor = getThemeColor();
            const buttons = container.querySelectorAll('button');
            buttons.forEach(btn => {
                if (btn.value === value) {
                    btn.style.background = themeColor;
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'white';
                    btn.style.color = '#333';
                }
            });
        }

        // 実績一覧の担当者選択ハンドラー
        function handleActualMemberChange(value, containerId) {
            document.getElementById('actualMemberSelect').value = value;
            document.getElementById('actualMemberSelect2').value = value;
            updateSegmentButtonSelection(containerId, value);
            renderActualList();
        }

        // 実績一覧の月選択ハンドラー
        function handleActualMonthChange(value, containerId) {
            document.getElementById('actualMonthFilter').value = value;
            document.getElementById('actualMonthFilter2').value = value;
            updateSegmentButtonSelection(containerId, value);
            renderActualList();
        }

        // 月選択同期ヘルパー関数：見積一覧→レポート
        function syncMonthToReport(value) {
            const reportMonth = document.getElementById('reportMonth');
            const reportMonth2 = document.getElementById('reportMonth2');
            if (reportMonth) reportMonth.value = value;
            if (reportMonth2) reportMonth2.value = value;

            // セグメントボタンの選択状態も更新
            const reportMonthButtons2 = document.getElementById('reportMonthButtons2');
            if (reportMonthButtons2) {
                updateSegmentButtonSelection('reportMonthButtons2', value);
            }
        }

        // 月選択同期ヘルパー関数：レポート→見積一覧
        function syncMonthToEstimate(value) {
            const estimateMonthFilter = document.getElementById('estimateMonthFilter');
            const estimateMonthFilter2 = document.getElementById('estimateMonthFilter2');
            if (estimateMonthFilter) estimateMonthFilter.value = value;
            if (estimateMonthFilter2) estimateMonthFilter2.value = value;

            // セグメントボタンの選択状態も更新
            const estimateMonthButtons2 = document.getElementById('estimateMonthButtons2');
            if (estimateMonthButtons2) {
                updateSegmentButtonSelection('estimateMonthButtons2', value);
            }
        }

        // フィルタタイプ同期ヘルパー関数：見積一覧→レポート
        function syncFilterTypeToReport(type) {
            const reportFilterType = document.getElementById('reportFilterType');
            if (reportFilterType && reportFilterType.value !== type) {
                reportFilterType.value = type;
                // UIの表示を更新（無限ループを防ぐため、見積一覧への同期は行わない）
                const monthFilterCompact = document.getElementById('reportMonthFilterCompact');
                const versionFilterCompact = document.getElementById('reportVersionFilterCompact');
                const monthFilterSegmented = document.getElementById('reportMonthFilterSegmented');
                const versionFilterSegmented = document.getElementById('reportVersionFilterSegmented');

                if (type === 'month') {
                    if (monthFilterCompact) monthFilterCompact.style.display = 'flex';
                    if (versionFilterCompact) versionFilterCompact.style.display = 'none';
                    if (monthFilterSegmented) monthFilterSegmented.style.display = 'flex';
                    if (versionFilterSegmented) versionFilterSegmented.style.display = 'none';
                } else {
                    if (monthFilterCompact) monthFilterCompact.style.display = 'none';
                    if (versionFilterCompact) versionFilterCompact.style.display = 'flex';
                    if (monthFilterSegmented) monthFilterSegmented.style.display = 'none';
                    if (versionFilterSegmented) versionFilterSegmented.style.display = 'flex';
                }

                // フィルタタイプボタンの状態更新
                updateFilterTypeButtons(type);
            }
        }

        // フィルタタイプ同期ヘルパー関数：レポート→見積一覧
        function syncFilterTypeToEstimate(type) {
            const estimateFilterType = document.getElementById('estimateFilterType');
            if (estimateFilterType && estimateFilterType.value !== type) {
                estimateFilterType.value = type;
                // UIの表示を更新（無限ループを防ぐため、レポートへの同期は行わない）
                const monthFilterCompact = document.getElementById('estimateMonthFilterCompact');
                const versionFilterCompact = document.getElementById('estimateVersionFilterCompact');
                const monthFilterSegmented = document.getElementById('estimateMonthFilterSegmented');
                const versionFilterSegmented = document.getElementById('estimateVersionFilterSegmented');

                if (type === 'month') {
                    if (monthFilterCompact) monthFilterCompact.style.display = 'flex';
                    if (versionFilterCompact) versionFilterCompact.style.display = 'none';
                    if (monthFilterSegmented) monthFilterSegmented.style.display = 'flex';
                    if (versionFilterSegmented) versionFilterSegmented.style.display = 'none';
                } else {
                    if (monthFilterCompact) monthFilterCompact.style.display = 'none';
                    if (versionFilterCompact) versionFilterCompact.style.display = 'flex';
                    if (monthFilterSegmented) monthFilterSegmented.style.display = 'none';
                    if (versionFilterSegmented) versionFilterSegmented.style.display = 'flex';
                }

                // セグメントボタンの状態更新
                const themeColor = getThemeColor();
                const btnMonth = document.getElementById('btnEstimateFilterMonth');
                const btnVersion = document.getElementById('btnEstimateFilterVersion');

                if (type === 'month') {
                    if (btnMonth) {
                        btnMonth.style.background = themeColor;
                        btnMonth.style.color = 'white';
                    }
                    if (btnVersion) {
                        btnVersion.style.background = 'white';
                        btnVersion.style.color = '#333';
                    }
                } else {
                    if (btnMonth) {
                        btnMonth.style.background = 'white';
                        btnMonth.style.color = '#333';
                    }
                    if (btnVersion) {
                        btnVersion.style.background = themeColor;
                        btnVersion.style.color = 'white';
                    }
                }
            }
        }

        // 版数選択同期ヘルパー関数：見積一覧→レポート
        function syncVersionToReport(value) {
            const reportVersion = document.getElementById('reportVersion');
            const reportVersion2 = document.getElementById('reportVersion2');
            if (reportVersion) reportVersion.value = value;
            if (reportVersion2) reportVersion2.value = value;

            // セグメントボタンの選択状態も更新
            const reportVersionButtons2 = document.getElementById('reportVersionButtons2');
            if (reportVersionButtons2) {
                updateSegmentButtonSelection('reportVersionButtons2', value);
            }
        }

        // 版数選択同期ヘルパー関数：レポート→見積一覧
        function syncVersionToEstimate(value) {
            const estimateVersionFilter = document.getElementById('estimateVersionFilter');
            const estimateVersionFilter2 = document.getElementById('estimateVersionFilter2');
            if (estimateVersionFilter) estimateVersionFilter.value = value;
            if (estimateVersionFilter2) estimateVersionFilter2.value = value;

            // セグメントボタンの選択状態も更新
            const estimateVersionButtons2 = document.getElementById('estimateVersionButtons2');
            if (estimateVersionButtons2) {
                updateSegmentButtonSelection('estimateVersionButtons2', value);
            }
        }

        // 見積一覧の月選択フィルタ変更ハンドラー（select要素用）
        function handleEstimateMonthFilterChange() {
            const value = document.getElementById('estimateMonthFilter').value;

            // レポートの月選択も同期
            syncMonthToReport(value);

            renderEstimateList();
        }

        // レポートの月選択フィルタ変更ハンドラー（select要素用）
        function handleReportMonthFilterChange() {
            const value = document.getElementById('reportMonth').value;

            // 見積一覧の月選択も同期
            syncMonthToEstimate(value);

            updateReport();
        }

        // 見積一覧の版数選択フィルタ変更ハンドラー（select要素用）
        function handleEstimateVersionFilterChange() {
            const value = document.getElementById('estimateVersionFilter').value;

            // レポートの版数選択も同期
            syncVersionToReport(value);

            renderEstimateList();
        }

        // レポートの版数選択フィルタ変更ハンドラー（select要素用）
        function handleReportVersionFilterChange() {
            const value = document.getElementById('reportVersion').value;

            // 見積一覧の版数選択も同期
            syncVersionToEstimate(value);

            updateReport();
        }

        // 見積一覧の月選択ハンドラー（セグメントボタン用）
        function handleEstimateMonthChange(value, containerId) {
            const filterElement = document.getElementById('estimateMonthFilter');
            if (filterElement) {
                filterElement.value = value;
            }
            updateSegmentButtonSelection(containerId, value);

            // レポートの月選択も同期
            syncMonthToReport(value);

            renderEstimateList();
        }

        // 見積一覧の版数選択ハンドラー
        function handleEstimateVersionChange(value, containerId) {
            const filterElement = document.getElementById('estimateVersionFilter');
            if (filterElement) {
                filterElement.value = value;
            }
            updateSegmentButtonSelection(containerId, value);

            // レポートの版数選択も同期
            syncVersionToReport(value);

            renderEstimateList();
        }

        // レポートの月選択ハンドラー（セグメントボタン用）
        function handleReportMonthChange(value, containerId) {
            document.getElementById('reportMonth').value = value;
            document.getElementById('reportMonth2').value = value;
            updateSegmentButtonSelection(containerId, value);

            // 見積一覧の月選択も同期
            syncMonthToEstimate(value);

            updateReport();
        }

        // レポートの版数選択ハンドラー
        function handleReportVersionChange(value, containerId) {
            document.getElementById('reportVersion').value = value;
            const versionSelect2 = document.getElementById('reportVersion2');
            if (versionSelect2) versionSelect2.value = value;
            updateSegmentButtonSelection(containerId, value);

            // 見積一覧の版数選択も同期
            syncVersionToEstimate(value);

            updateReport();
        }

        // レポートのフィルタタイプ変更ハンドラー（コンパクト版）
        function handleReportFilterTypeChange() {
            try {
                const filterTypeEl = document.getElementById('reportFilterType');
                if (!filterTypeEl) return;

                const filterType = filterTypeEl.value;
                const monthFilterCompact = document.getElementById('reportMonthFilterCompact');
                const versionFilterCompact = document.getElementById('reportVersionFilterCompact');
                const monthFilterSegmented = document.getElementById('reportMonthFilterSegmented');
                const versionFilterSegmented = document.getElementById('reportVersionFilterSegmented');

                if (filterType === 'month') {
                    if (monthFilterCompact) monthFilterCompact.style.display = 'flex';
                    if (versionFilterCompact) versionFilterCompact.style.display = 'none';
                    if (monthFilterSegmented) monthFilterSegmented.style.display = 'flex';
                    if (versionFilterSegmented) versionFilterSegmented.style.display = 'none';

                    // 月別フィルタに切り替えた時、デフォルト月が選択されていない場合は設定
                    const reportMonthEl = document.getElementById('reportMonth');
                    if (reportMonthEl && !reportMonthEl.value) {
                        setDefaultReportMonth();
                    }
                } else {
                    if (monthFilterCompact) monthFilterCompact.style.display = 'none';
                    if (versionFilterCompact) versionFilterCompact.style.display = 'flex';
                    if (monthFilterSegmented) monthFilterSegmented.style.display = 'none';
                    if (versionFilterSegmented) versionFilterSegmented.style.display = 'flex';

                    // 版数別フィルタに切り替えた時、デフォルト版数が選択されていない場合は最新版数を設定
                    const reportVersionEl = document.getElementById('reportVersion');
                    if (reportVersionEl && (!reportVersionEl.value || reportVersionEl.value === 'all')) {
                        const options = reportVersionEl.options;
                        if (options.length > 1) {
                            // 'all'以外の最初の版数を選択（最新版数）
                            reportVersionEl.value = options[1].value;
                            // セグメントボタンも更新
                            const reportVersion2El = document.getElementById('reportVersion2');
                            if (reportVersion2El) reportVersion2El.value = options[1].value;
                            updateSegmentButtonSelection('reportVersionButtons2', options[1].value);
                        }
                    }
                }

                // フィルタタイプ切り替えボタンの状態更新
                updateFilterTypeButtons(filterType);

                // 見積一覧のフィルタタイプも同期
                syncFilterTypeToEstimate(filterType);

                // 選択値も同期
                if (filterType === 'month') {
                    const reportMonthEl = document.getElementById('reportMonth');
                    if (reportMonthEl && reportMonthEl.value) {
                        syncMonthToEstimate(reportMonthEl.value);
                    }
                } else {
                    const reportVersionEl = document.getElementById('reportVersion');
                    if (reportVersionEl && reportVersionEl.value) {
                        syncVersionToEstimate(reportVersionEl.value);
                    }
                }

                updateReport();
            } catch (e) {
                console.error('handleReportFilterTypeChange error:', e);
            }
        }

        // レポートのフィルタタイプ設定（セグメント版）
        function setReportFilterType(type) {
            try {
                const filterTypeEl = document.getElementById('reportFilterType');
                if (filterTypeEl) filterTypeEl.value = type;
                handleReportFilterTypeChange();
            } catch (e) {
                console.error('setReportFilterType error:', e);
            }
        }

        // フィルタタイプボタンの表示状態を更新
        function updateFilterTypeButtons(type) {
            const themeColor = getThemeColor();
            const btnMonth = document.getElementById('btnFilterMonth');
            const btnVersion = document.getElementById('btnFilterVersion');

            if (btnMonth) {
                btnMonth.style.background = type === 'month' ? themeColor : 'white';
                btnMonth.style.color = type === 'month' ? 'white' : '#333';
            }
            if (btnVersion) {
                btnVersion.style.background = type === 'version' ? themeColor : 'white';
                btnVersion.style.color = type === 'version' ? 'white' : '#333';
            }
        }

        // テーマカラーから実際の色を取得するヘルパー関数
        function getThemeColor() {
            const themeColors = {
                'purple': '#667eea',
                'deep-blue': '#1e3c72',
                'teal': '#0f766e',
                'cyan': '#0891b2',
                'ocean': '#0c4a6e',
                'sky': '#0369a1',
                'indigo': '#4338ca',
                'navy': '#1e40af',
                'slate': '#334155',
                'green': '#047857',
                'emerald': '#059669'
            };
            return themeColors[currentThemeColor] || '#667eea';
        }

        // セグメントボタン用の関数（見積一覧）
        function setEstimateViewType(type) {
            const viewTypeElement = document.getElementById('estimateViewType');
            if (viewTypeElement) {
                viewTypeElement.value = type;
            }

            // ボタンのスタイルを更新（activeクラス使用）
            const btnGrouped = document.getElementById('btnEstimateGrouped');
            const btnMatrix = document.getElementById('btnEstimateMatrix');
            const btnList = document.getElementById('btnEstimateList');

            // 全てのactiveクラスを削除
            if (btnGrouped) btnGrouped.classList.remove('active');
            if (btnMatrix) btnMatrix.classList.remove('active');
            if (btnList) btnList.classList.remove('active');

            // 選択されたボタンにactiveクラスを追加
            if (type === 'grouped' && btnGrouped) {
                btnGrouped.classList.add('active');
            } else if (type === 'matrix' && btnMatrix) {
                btnMatrix.classList.add('active');
            } else if (type === 'list' && btnList) {
                btnList.classList.add('active');
            }

            renderEstimateList();
        }

        // セグメントボタン用の関数（実績一覧）
        function setActualViewType(type) {
            document.getElementById('actualViewType').value = type;
            // ボタンのスタイルを更新（activeクラス使用）
            const btnMatrix = document.getElementById('btnActualMatrix');
            const btnList = document.getElementById('btnActualList');

            // 全てのactiveクラスを削除
            if (btnMatrix) btnMatrix.classList.remove('active');
            if (btnList) btnList.classList.remove('active');

            // 選択されたボタンにactiveクラスを追加
            if (type === 'matrix' && btnMatrix) {
                btnMatrix.classList.add('active');
            } else if (type === 'list' && btnList) {
                btnList.classList.add('active');
            }
            renderActualList();
        }

        // セグメントボタン用の関数（レポート）
        function setReportViewType(type) {
            document.getElementById('reportViewType').value = type;
            // ボタンのスタイルを更新
            const themeColor = getThemeColor();
            const btnSummary = document.getElementById('btnReportSummary');
            const btnGrouped = document.getElementById('btnReportGrouped');
            const btnMatrix = document.getElementById('btnReportMatrix');
            btnSummary.style.background = type === 'summary' ? themeColor : 'white';
            btnSummary.style.color = type === 'summary' ? 'white' : '#333';
            btnGrouped.style.background = type === 'grouped' ? themeColor : 'white';
            btnGrouped.style.color = type === 'grouped' ? 'white' : '#333';
            btnMatrix.style.background = type === 'matrix' ? themeColor : 'white';
            btnMatrix.style.color = type === 'matrix' ? 'white' : '#333';
            updateReport();
        }

        // レイアウト設定を適用
        function applyLayoutSettings() {
            // 見積一覧のレイアウトを適用
            const estimateCompact = document.getElementById('estimateFiltersCompact');
            const estimateSegmented = document.getElementById('estimateFiltersSegmented');
            if (estimateLayout === 'compact') {
                if (estimateCompact) estimateCompact.style.display = 'flex';
                if (estimateSegmented) estimateSegmented.style.display = 'none';
            } else {
                if (estimateCompact) estimateCompact.style.display = 'none';
                if (estimateSegmented) estimateSegmented.style.display = 'block';
            }

            // 実績一覧のレイアウトを適用
            const actualCompact = document.getElementById('actualFiltersCompact');
            const actualSegmented = document.getElementById('actualFiltersSegmented');
            if (actualLayout === 'compact') {
                if (actualCompact) actualCompact.style.display = 'flex';
                if (actualSegmented) actualSegmented.style.display = 'none';
            } else {
                if (actualCompact) actualCompact.style.display = 'none';
                if (actualSegmented) actualSegmented.style.display = 'block';
            }

            // レポートのレイアウトを適用
            const reportCompact = document.getElementById('reportFiltersCompact');
            const reportSegmented = document.getElementById('reportFiltersSegmented');
            if (reportLayout === 'compact') {
                if (reportCompact) reportCompact.style.display = 'flex';
                if (reportSegmented) reportSegmented.style.display = 'none';
            } else {
                if (reportCompact) reportCompact.style.display = 'none';
                if (reportSegmented) reportSegmented.style.display = 'block';
            }

            // 設定タブのボタンの状態を更新
            updateLayoutToggleButtons();
        }

        // レイアウト切り替え関数（開発/比較用）
        function toggleFilterLayout(page, version) {
            const themeColor = getThemeColor();

            if (page === 'estimate') {
                const compact = document.getElementById('estimateFiltersCompact');
                const segmented = document.getElementById('estimateFiltersSegmented');

                // 設定タブのボタンを更新
                const settingsButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'estimate\'"]');
                const btnCompact = settingsButtons[0];
                const btnSegmented = settingsButtons[1];

                if (version === 'compact') {
                    compact.style.display = 'flex';
                    segmented.style.display = 'none';
                    btnCompact.style.background = themeColor;
                    btnCompact.style.color = 'white';
                    btnSegmented.style.background = 'white';
                    btnSegmented.style.color = '#333';
                    estimateLayout = 'compact';
                    renderEstimateList();
                } else {
                    const viewType = document.getElementById('estimateViewType').value;
                    setEstimateViewType(viewType);
                    compact.style.display = 'none';
                    segmented.style.display = 'block';
                    btnCompact.style.background = 'white';
                    btnCompact.style.color = '#333';
                    btnSegmented.style.background = themeColor;
                    btnSegmented.style.color = 'white';
                    estimateLayout = 'segmented';
                }
                saveData(true);
            } else if (page === 'actual') {
                const compact = document.getElementById('actualFiltersCompact');
                const segmented = document.getElementById('actualFiltersSegmented');

                // 設定タブのボタンを更新
                const settingsButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'actual\'"]');
                const btnCompact = settingsButtons[0];
                const btnSegmented = settingsButtons[1];

                if (version === 'compact') {
                    // セグメント→コンパクトへ切り替え時、値を同期
                    document.getElementById('actualViewMode').value = document.getElementById('actualViewMode2').value;
                    document.getElementById('actualMemberSelect').value = document.getElementById('actualMemberSelect2').value;
                    document.getElementById('actualMonthFilter').value = document.getElementById('actualMonthFilter2').value;
                    compact.style.display = 'flex';
                    segmented.style.display = 'none';
                    btnCompact.style.background = themeColor;
                    btnCompact.style.color = 'white';
                    btnSegmented.style.background = 'white';
                    btnSegmented.style.color = '#333';
                    // グローバル変数を更新
                    actualLayout = 'compact';
                    // 集計を更新
                    renderActualList();
                } else {
                    // コンパクト→セグメントへ切り替え時、値を同期
                    document.getElementById('actualViewMode2').value = document.getElementById('actualViewMode').value;
                    document.getElementById('actualMemberSelect2').value = document.getElementById('actualMemberSelect').value;
                    document.getElementById('actualMonthFilter2').value = document.getElementById('actualMonthFilter').value;
                    // セグメントボタンの状態を同期（setActualViewType内でrenderActualListが呼ばれる）
                    const viewType = document.getElementById('actualViewType').value;
                    setActualViewType(viewType);
                    compact.style.display = 'none';
                    segmented.style.display = 'block';
                    btnCompact.style.background = 'white';
                    btnCompact.style.color = '#333';
                    btnSegmented.style.background = themeColor;
                    btnSegmented.style.color = 'white';
                    // グローバル変数を更新
                    actualLayout = 'segmented';
                }
                // 設定を保存
                saveData(true);
            } else if (page === 'report') {
                const compact = document.getElementById('reportFiltersCompact');
                const segmented = document.getElementById('reportFiltersSegmented');

                // 設定タブのボタンを更新
                const settingsButtons = document.querySelectorAll('#settings button[onclick*="toggleFilterLayout(\'report\'"]');
                const btnCompact = settingsButtons[0];
                const btnSegmented = settingsButtons[1];

                if (version === 'compact') {
                    // セグメント→コンパクトへ切り替え時、値を同期
                    document.getElementById('reportMonth').value = document.getElementById('reportMonth2').value;
                    compact.style.display = 'flex';
                    segmented.style.display = 'none';
                    btnCompact.style.background = themeColor;
                    btnCompact.style.color = 'white';
                    btnSegmented.style.background = 'white';
                    btnSegmented.style.color = '#333';
                    // グローバル変数を更新
                    reportLayout = 'compact';
                    // 集計を更新
                    updateReport();
                } else {
                    // コンパクト→セグメントへ切り替え時、値を同期
                    document.getElementById('reportMonth2').value = document.getElementById('reportMonth').value;
                    // セグメントボタンの状態を同期（setReportViewType内でupdateReportが呼ばれる）
                    const viewType = document.getElementById('reportViewType').value;
                    setReportViewType(viewType);
                    compact.style.display = 'none';
                    segmented.style.display = 'block';
                    btnCompact.style.background = 'white';
                    btnCompact.style.color = '#333';
                    btnSegmented.style.background = themeColor;
                    btnSegmented.style.color = 'white';
                    // グローバル変数を更新
                    reportLayout = 'segmented';
                }
                // 設定を保存
                saveData(true);
            }
        }

        function updateReport() {
            const filterType = document.getElementById('reportFilterType').value;
            const selectedMonth = document.getElementById('reportMonth').value;
            const selectedVersion = document.getElementById('reportVersion').value;
            const viewType = document.getElementById('reportViewType').value;

            let filteredActuals = actuals;
            let filteredEstimates = estimates;

            if (filterType === 'month') {
                // 月別フィルタリング
                if (selectedMonth !== 'all') {
                    // 選択月の実績 + その月の「その他付随作業」を含める
                    filteredActuals = actuals.filter(a => {
                        // その他付随作業は日付が選択月のものを含める
                        if (isOtherWork(a)) {
                            return a.date && a.date.startsWith(selectedMonth);
                        }
                        // 通常の作業は日付が選択月のものを含める
                        return a.date && a.date.startsWith(selectedMonth);
                    });

                    // 複数月対応: workMonthsに含まれる見積をフィルタ
                    filteredEstimates = estimates.filter(e => {
                        const est = normalizeEstimate(e);
                        // workMonthsが空または未定義の場合は全期間表示（常に表示）
                        if (!est.workMonths || est.workMonths.length === 0) {
                            return true;
                        }
                        return est.workMonths.includes(selectedMonth);
                    }).map(e => {
                        // 月別工数を使用
                        const est = normalizeEstimate(e);
                        return {
                            ...est,
                            hours: est.monthlyHours[selectedMonth] || est.hours
                        };
                    });
                } else {
                    // 全期間の場合は正規化のみ
                    filteredEstimates = estimates.map(e => normalizeEstimate(e));
                }
            } else {
                // 版数別フィルタリング
                if (selectedVersion !== 'all') {
                    filteredActuals = actuals.filter(a => a.version === selectedVersion);
                    filteredEstimates = estimates.filter(e => e.version === selectedVersion).map(e => normalizeEstimate(e));
                } else {
                    filteredEstimates = estimates.map(e => normalizeEstimate(e));
                }
            }
            
            // デバッグ情報（コンソール出力）
            if (selectedMonth !== 'all') {
                console.log('=== レポート集計デバッグ ===');
                console.log('選択月:', selectedMonth);
                console.log('全見積数:', estimates.length);
                console.log('フィルタ後見積数:', filteredEstimates.length);
                console.log('全実績数:', actuals.length);
                console.log('フィルタ後実績数:', filteredActuals.length);
                
                // 作業予定月が未設定または空文字の見積を確認
                const noWorkMonthEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.length === 0;
                });
                if (noWorkMonthEstimates.length > 0) {
                    console.log('ℹ️ 作業予定月が未設定の見積:', noWorkMonthEstimates.length, '件');
                    console.log('  これらの見積は全期間として月別集計に含まれます');
                    console.log('  詳細:', noWorkMonthEstimates.map(e => ({
                        version: e.version,
                        task: e.task,
                        workMonths: normalizeEstimate(e).workMonths
                    })));
                }
                
                // 選択月とは異なる作業予定月の見積を確認
                const otherMonthEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.length > 0 && !est.workMonths.includes(selectedMonth);
                });
                if (otherMonthEstimates.length > 0) {
                    console.log('ℹ️ 他の月に予定されている見積:', otherMonthEstimates.length, '件');
                    const monthCounts = {};
                    otherMonthEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        est.workMonths.forEach(m => {
                            monthCounts[m] = (monthCounts[m] || 0) + 1;
                        });
                    });
                    console.log('  月別内訳:', monthCounts);
                }
                
                // 複数月見積の情報
                const multiMonthEstimates = estimates.filter(e => {
                    const est = normalizeEstimate(e);
                    return est.workMonths.length > 1 && est.workMonths.includes(selectedMonth);
                });
                if (multiMonthEstimates.length > 0) {
                    console.log('📅 複数月見積（選択月を含む）:', multiMonthEstimates.length, '件');
                    multiMonthEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        console.log(`  ${est.version} - ${est.task} [${est.process}]:`, est.monthlyHours);
                    });
                }
                
                // 選択月の実績があるが見積がない対応を確認
                const actualTasks = new Set(filteredActuals.map(a => `${a.version}-${a.task}`));
                const estimateTasks = new Set(filteredEstimates.map(e => `${e.version}-${e.task}`));
                const actualOnlyTasks = [...actualTasks].filter(t => !estimateTasks.has(t));
                if (actualOnlyTasks.length > 0) {
                    console.log('ℹ️ 実績のみで見積がない対応:', actualOnlyTasks);
                    console.log('  理由: 見積の作業予定月が設定されていないか、別の月に設定されています');
                }
                
                // 選択月の見積があるが実績がない対応を確認
                const estimateOnlyTasks = [...estimateTasks].filter(t => !actualTasks.has(t));
                if (estimateOnlyTasks.length > 0) {
                    console.log('ℹ️ 見積のみで実績がない対応:', estimateOnlyTasks);
                }
            }
            
            // タイトル更新
            const titleElement = document.getElementById('reportPeriodTitle');
            if (filterType === 'month') {
                if (selectedMonth === 'all') {
                    titleElement.textContent = '全期間の集計';
                } else {
                    const [year, month] = selectedMonth.split('-');
                    titleElement.textContent = `${year}年${parseInt(month)}月の集計`;
                }
            } else {
                if (selectedVersion === 'all') {
                    titleElement.textContent = '全版数の集計';
                } else {
                    titleElement.textContent = `${selectedVersion} の集計`;
                }
            }
            
            const totalEst = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
            const totalAct = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
            const diff = totalAct - totalEst;
            const rate = totalEst > 0 ? (totalAct / totalEst * 100).toFixed(1) : 0;

            // 人日と人月の計算（実働日数ベース）
            let workingDaysPerMonth = 20; // デフォルト
            if (filterType === 'month' && selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                workingDaysPerMonth = getWorkingDays(parseInt(year), parseInt(month));
            }
            const estManDays = (totalEst / 8).toFixed(1);
            const estManMonths = (totalEst / 8 / workingDaysPerMonth).toFixed(2);
            const actManDays = (totalAct / 8).toFixed(1);
            const actManMonths = (totalAct / 8 / workingDaysPerMonth).toFixed(2);

            document.getElementById('totalEstimate').textContent = totalEst.toFixed(1) + 'h';
            document.getElementById('totalActual').textContent = totalAct.toFixed(1) + 'h';
            document.getElementById('totalDiff').textContent = (diff >= 0 ? '+' : '') + diff.toFixed(1) + 'h';
            document.getElementById('actualRate').textContent = rate + '%';
            
            // 補足情報として人日・人月を表示
            document.getElementById('totalEstimateManpower').textContent = `${estManDays}人日 / ${estManMonths}人月`;
            document.getElementById('totalActualManpower').textContent = `${actManDays}人日 / ${actManMonths}人月`;

            // レポート詳細ビューをクリア
            document.getElementById('reportDetailView').innerHTML = '';

            // 分析機能の表示
            renderReportAnalytics(filteredActuals, filteredEstimates, selectedMonth, workingDaysPerMonth);

            // 詳細ビュー表示
            if (viewType === 'grouped') {
                renderReportGrouped(filteredActuals, filteredEstimates);
            } else if (viewType === 'matrix') {
                renderReportMatrix(filteredActuals, filteredEstimates, selectedMonth);
            }
            // viewTypeがnoneの場合は何もしない（分析パネルは保持される）

            renderMemberReport(filteredActuals, filteredEstimates);
            renderVersionReport(filteredActuals, filteredEstimates);
            updateProgressReport();
        }

        // テーマカラーに応じた分析パネルのグラデーションを取得
        function getAnalysisGradients() {
            const gradients = {
                'purple': {
                    phase1: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    phase2: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    phase3: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)'
                },
                'deep-blue': {
                    phase1: 'linear-gradient(135deg, #1e3c72 0%, #2a5298 100%)',
                    phase2: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    phase3: 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)'
                },
                'teal': {
                    phase1: 'linear-gradient(135deg, #0f766e 0%, #14b8a6 100%)',
                    phase2: 'linear-gradient(135deg, #10b981 0%, #34d399 100%)',
                    phase3: 'linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%)'
                },
                'cyan': {
                    phase1: 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)',
                    phase2: 'linear-gradient(135deg, #14b8a6 0%, #2dd4bf 100%)',
                    phase3: 'linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%)'
                },
                'ocean': {
                    phase1: 'linear-gradient(135deg, #0c4a6e 0%, #0284c7 100%)',
                    phase2: 'linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%)',
                    phase3: 'linear-gradient(135deg, #14b8a6 0%, #34d399 100%)'
                },
                'sky': {
                    phase1: 'linear-gradient(135deg, #0369a1 0%, #0ea5e9 100%)',
                    phase2: 'linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%)',
                    phase3: 'linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%)'
                },
                'indigo': {
                    phase1: 'linear-gradient(135deg, #4338ca 0%, #6366f1 100%)',
                    phase2: 'linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%)',
                    phase3: 'linear-gradient(135deg, #06b6d4 0%, #0ea5e9 100%)'
                },
                'navy': {
                    phase1: 'linear-gradient(135deg, #1e40af 0%, #3b82f6 100%)',
                    phase2: 'linear-gradient(135deg, #6366f1 0%, #818cf8 100%)',
                    phase3: 'linear-gradient(135deg, #14b8a6 0%, #2dd4bf 100%)'
                },
                'slate': {
                    phase1: 'linear-gradient(135deg, #334155 0%, #475569 100%)',
                    phase2: 'linear-gradient(135deg, #64748b 0%, #94a3b8 100%)',
                    phase3: 'linear-gradient(135deg, #0891b2 0%, #06b6d4 100%)'
                },
                'green': {
                    phase1: 'linear-gradient(135deg, #047857 0%, #10b981 100%)',
                    phase2: 'linear-gradient(135deg, #34d399 0%, #6ee7b7 100%)',
                    phase3: 'linear-gradient(135deg, #0891b2 0%, #14b8a6 100%)'
                },
                'emerald': {
                    phase1: 'linear-gradient(135deg, #059669 0%, #10b981 100%)',
                    phase2: 'linear-gradient(135deg, #34d399 0%, #6ee7b7 100%)',
                    phase3: 'linear-gradient(135deg, #06b6d4 0%, #22d3ee 100%)'
                }
            };
            return gradients[currentThemeColor] || gradients['purple'];
        }

        function renderReportAnalytics(filteredActuals, filteredEstimates, selectedMonth, workingDaysPerMonth) {
            const container = document.getElementById('reportDetailView');
            let html = '';

            // テーマカラーに応じたグラデーションを取得
            const colors = getAnalysisGradients();

            // Phase 1: 見積精度と異常値表示
            if (reportSettings.accuracyEnabled || reportSettings.anomalyEnabled || reportSettings.warningTasksEnabled) {
                html += `<div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #dee2e6;">`;
                html += `<h3 onclick="togglePhaseCollapse('phase1')" style="margin: 0; color: #495057; font-size: 18px; cursor: pointer; display: flex; align-items: center; user-select: none;">`;
                html += `<span id="phase1-arrow" style="margin-right: 10px; font-size: 14px;">${phaseCollapsed.phase1 ? '▶' : '▼'}</span>`;
                html += 'Phase 1: 見積精度分析</h3>';
                html += `<div id="phase1-content" style="display: ${phaseCollapsed.phase1 ? 'none' : 'block'}; margin-top: 15px;">`;

                // 工程別の精度計算
                if (reportSettings.accuracyEnabled) {
                    const processSummary = {};
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

                    filteredEstimates.forEach(e => {
                        const processKey = processOrder.includes(e.process) ? e.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].estimate += e.hours;
                    });

                    filteredActuals.forEach(a => {
                        const processKey = processOrder.includes(a.process) ? a.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].actual += a.hours;
                    });

                    html += '<div style="background: #ffffff; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #e9ecef;">';
                    html += '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 16px;">工程別見積精度</h4>';
                    html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">';

                    const sortedProcesses = [
                        ...processOrder.filter(p => processSummary[p]),
                        ...(processSummary['その他'] ? ['その他'] : [])
                    ];

                    sortedProcesses.forEach(proc => {
                        const data = processSummary[proc];
                        const accuracy = data.estimate > 0 ? (data.actual / data.estimate * 100).toFixed(1) : 0;
                        const isOverrun = accuracy > 150;
                        const isGood = accuracy >= 80 && accuracy <= 120;

                        html += '<div style="background: #f8f9fa; padding: 10px; border-radius: 6px; text-align: center; border: 1px solid #e9ecef;">';
                        html += `<div style="font-weight: 600; margin-bottom: 5px; color: #495057;">${proc}</div>`;
                        html += `<div style="font-size: 20px; font-weight: bold; color: ${isOverrun ? '#dc3545' : isGood ? '#28a745' : '#ffc107'};">${accuracy}%</div>`;
                        html += `<div style="font-size: 12px; color: #6c757d;">${data.estimate.toFixed(1)}h → ${data.actual.toFixed(1)}h</div>`;
                        html += '</div>';
                    });

                    html += '</div></div>';
                }

                // 異常値の強調表示
                if (reportSettings.anomalyEnabled) {
                    const anomalies = [];
                    const taskSummary = {};

                    filteredEstimates.forEach(e => {
                        const key = `${e.version}-${e.task}-${e.process}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: e.version, task: e.task, process: e.process, estimate: 0, actual: 0 };
                        }
                        taskSummary[key].estimate += e.hours;
                    });

                    filteredActuals.forEach(a => {
                        const key = `${a.version}-${a.task}-${a.process}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: a.version, task: a.task, process: a.process, estimate: 0, actual: 0 };
                        }
                        taskSummary[key].actual += a.hours;
                    });

                    Object.values(taskSummary).forEach(task => {
                        const overrun = task.estimate > 0 ? ((task.actual - task.estimate) / task.estimate * 100) : 0;
                        if (overrun > 50) {
                            anomalies.push({ ...task, overrun });
                        }
                    });

                    if (anomalies.length > 0) {
                        anomalies.sort((a, b) => b.overrun - a.overrun);

                        html += '<div style="background: #fff5f5; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #f5c6cb;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: #721c24; font-size: 16px;">異常値検出（50%以上超過）</h4>';
                        html += `<div style="color: #856404; font-size: 14px; margin-bottom: 10px;">検出数: ${anomalies.length}件</div>`;
                        html += '<div style="max-height: 200px; overflow-y: auto;">';

                        anomalies.slice(0, 10).forEach(anomaly => {
                            html += '<div style="background: #ffffff; padding: 8px; border-radius: 4px; margin-bottom: 5px; font-size: 13px; border: 1px solid #f5c6cb;">';
                            html += `<div style="font-weight: 600; color: #495057;">${anomaly.version} - ${anomaly.task} [${anomaly.process}]</div>`;
                            html += `<div style="color: #495057;">見積: ${anomaly.estimate.toFixed(1)}h → 実績: ${anomaly.actual.toFixed(1)}h <span style="color: #dc3545; font-weight: bold;">(+${anomaly.overrun.toFixed(0)}%)</span></div>`;
                            html += '</div>';
                        });

                        if (anomalies.length > 10) {
                            html += `<div style="text-align: center; padding: 5px; color: #6c757d;">他 ${anomalies.length - 10}件...</div>`;
                        }

                        html += '</div></div>';
                    }
                }

                // 警告タスク一覧
                if (reportSettings.warningTasksEnabled) {
                    const warnings = [];
                    const taskSummary = {};

                    filteredEstimates.forEach(e => {
                        const key = `${e.version}-${e.task}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: e.version, task: e.task, estimate: 0, actual: 0, processes: new Set() };
                        }
                        taskSummary[key].estimate += e.hours;
                        taskSummary[key].processes.add(e.process);
                    });

                    filteredActuals.forEach(a => {
                        const key = `${a.version}-${a.task}`;
                        if (!taskSummary[key]) {
                            taskSummary[key] = { version: a.version, task: a.task, estimate: 0, actual: 0, processes: new Set() };
                        }
                        taskSummary[key].actual += a.hours;
                        taskSummary[key].processes.add(a.process);
                    });

                    Object.values(taskSummary).forEach(task => {
                        const overrun = task.estimate > 0 ? ((task.actual - task.estimate) / task.estimate * 100) : 0;
                        if (overrun > 50) {
                            warnings.push({ ...task, overrun, processCount: task.processes.size });
                        }
                    });

                    if (warnings.length > 0) {
                        warnings.sort((a, b) => b.overrun - a.overrun);

                        html += '<div style="background: #ffffff; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 16px;">要注意タスク</h4>';
                        html += '<div style="max-height: 150px; overflow-y: auto;">';

                        warnings.slice(0, 5).forEach((warning, idx) => {
                            html += '<div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 5px; border: 1px solid #e9ecef;">';
                            html += `<div style="font-weight: 600; color: #495057;">#${idx + 1} ${warning.version} - ${warning.task}</div>`;
                            html += `<div style="font-size: 13px; color: #495057;">見積: ${warning.estimate.toFixed(1)}h → 実績: ${warning.actual.toFixed(1)}h <span style="color: #dc3545; font-weight: bold;">(+${warning.overrun.toFixed(0)}%)</span></div>`;
                            html += `<div style="font-size: 12px; color: #6c757d;">工程数: ${warning.processCount}</div>`;
                            html += '</div>';
                        });

                        html += '</div></div>';
                    }
                }

                html += '</div>'; // close phase1-content
                html += '</div>';
            }

            // Phase 2: グラフと月別推移
            if (reportSettings.chartEnabled || reportSettings.trendEnabled) {
                html += `<div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #dee2e6;">`;
                html += `<h3 onclick="togglePhaseCollapse('phase2')" style="margin: 0; color: #495057; font-size: 18px; cursor: pointer; display: flex; align-items: center; user-select: none;">`;
                html += `<span id="phase2-arrow" style="margin-right: 10px; font-size: 14px;">${phaseCollapsed.phase2 ? '▶' : '▼'}</span>`;
                html += 'Phase 2: ビジュアル分析</h3>';
                html += `<div id="phase2-content" style="display: ${phaseCollapsed.phase2 ? 'none' : 'block'}; margin-top: 15px;">`;

                // 工程別バーチャート
                if (reportSettings.chartEnabled) {
                    const processSummary = {};
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

                    filteredEstimates.forEach(e => {
                        const processKey = processOrder.includes(e.process) ? e.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].estimate += e.hours;
                    });

                    filteredActuals.forEach(a => {
                        const processKey = processOrder.includes(a.process) ? a.process : 'その他';
                        if (!processSummary[processKey]) {
                            processSummary[processKey] = { estimate: 0, actual: 0 };
                        }
                        processSummary[processKey].actual += a.hours;
                    });

                    const maxHours = Math.max(...Object.values(processSummary).map(p => Math.max(p.estimate, p.actual)));

                    html += '<div style="background: #ffffff; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #e9ecef;">';
                    html += '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 16px;">工程別見積vs実績</h4>';

                    const sortedProcesses = [
                        ...processOrder.filter(p => processSummary[p]),
                        ...(processSummary['その他'] ? ['その他'] : [])
                    ];

                    sortedProcesses.forEach(proc => {
                        const data = processSummary[proc];
                        const estWidth = (data.estimate / maxHours * 100).toFixed(1);
                        const actWidth = (data.actual / maxHours * 100).toFixed(1);

                        html += '<div style="margin-bottom: 15px;">';
                        html += `<div style="font-weight: 600; margin-bottom: 5px; color: #495057;">${proc}</div>`;
                        html += '<div style="display: grid; grid-template-columns: 60px 1fr; gap: 10px; align-items: center;">';
                        html += '<div style="text-align: right; font-size: 13px; color: #6c757d;">見積</div>';
                        html += `<div style="background: #e9ecef; border-radius: 4px; height: 20px; position: relative;">`;
                        html += `<div style="background: #4dabf7; height: 100%; width: ${estWidth}%; border-radius: 4px; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; min-width: 30px;">`;
                        html += `<span style="font-size: 12px; font-weight: 600; color: white;">${data.estimate.toFixed(1)}h</span>`;
                        html += '</div></div>';
                        html += '<div style="text-align: right; font-size: 13px; color: #6c757d;">実績</div>';
                        html += `<div style="background: #e9ecef; border-radius: 4px; height: 20px;">`;
                        html += `<div style="background: ${data.actual > data.estimate ? '#dc3545' : '#28a745'}; height: 100%; width: ${actWidth}%; border-radius: 4px; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; min-width: 30px;">`;
                        html += `<span style="font-size: 12px; font-weight: 600; color: white;">${data.actual.toFixed(1)}h</span>`;
                        html += '</div></div>';
                        html += '</div></div>';
                    });

                    html += '</div>';
                }

                // 月別推移分析
                if (reportSettings.trendEnabled && selectedMonth === 'all') {
                    const monthlyData = {};

                    filteredEstimates.forEach(e => {
                        const est = normalizeEstimate(e);
                        est.workMonths.forEach(month => {
                            if (!monthlyData[month]) {
                                monthlyData[month] = { estimate: 0, actual: 0 };
                            }
                            const monthlyHours = est.monthlyHours[month] || 0;
                            monthlyData[month].estimate += monthlyHours;
                        });
                    });

                    filteredActuals.forEach(a => {
                        const month = a.workMonth;
                        if (!monthlyData[month]) {
                            monthlyData[month] = { estimate: 0, actual: 0 };
                        }
                        monthlyData[month].actual += a.hours;
                    });

                    const sortedMonths = Object.keys(monthlyData).sort();

                    if (sortedMonths.length > 1) {
                        html += '<div style="background: #ffffff; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 16px;">月別推移</h4>';

                        const maxMonthlyHours = Math.max(...Object.values(monthlyData).map(m => Math.max(m.estimate, m.actual)));

                        sortedMonths.slice(-6).forEach(month => {
                            const data = monthlyData[month];
                            const [year, monthNum] = month.split('-');
                            const estWidth = (data.estimate / maxMonthlyHours * 100).toFixed(1);
                            const actWidth = (data.actual / maxMonthlyHours * 100).toFixed(1);
                            const diff = data.actual - data.estimate;

                            html += '<div style="margin-bottom: 12px;">';
                            html += `<div style="font-weight: 600; margin-bottom: 5px; color: #495057;">${year}年${parseInt(monthNum)}月</div>`;
                            html += '<div style="display: flex; gap: 5px; align-items: center;">';
                            html += `<div style="flex: 1; background: #e9ecef; border-radius: 4px; height: 24px; position: relative;">`;
                            html += `<div style="background: #4dabf7; height: 100%; width: ${estWidth}%; border-radius: 4px;"></div>`;
                            html += '</div>';
                            html += `<div style="flex: 1; background: #e9ecef; border-radius: 4px; height: 24px;">`;
                            html += `<div style="background: ${data.actual > data.estimate ? '#dc3545' : '#28a745'}; height: 100%; width: ${actWidth}%; border-radius: 4px;"></div>`;
                            html += '</div>';
                            html += `<div style="min-width: 80px; text-align: right; font-size: 13px; color: #495057;">${diff > 0 ? '+' : ''}${diff.toFixed(1)}h</div>`;
                            html += '</div></div>';
                        });

                        html += '</div>';
                    }
                }

                html += '</div>'; // close phase2-content
                html += '</div>';
            }

            // Phase 3: 担当者別分析とインサイト
            if (reportSettings.memberAnalysisEnabled || reportSettings.insightsEnabled) {
                html += `<div style="background: #f8f9fa; padding: 20px; border-radius: 12px; margin: 20px 0; border: 1px solid #dee2e6;">`;
                html += `<h3 onclick="togglePhaseCollapse('phase3')" style="margin: 0; color: #495057; font-size: 18px; cursor: pointer; display: flex; align-items: center; user-select: none;">`;
                html += `<span id="phase3-arrow" style="margin-right: 10px; font-size: 14px;">${phaseCollapsed.phase3 ? '▶' : '▼'}</span>`;
                html += 'Phase 3: 担当者分析とインサイト</h3>';
                html += `<div id="phase3-content" style="display: ${phaseCollapsed.phase3 ? 'none' : 'block'}; margin-top: 15px;">`;

                // 担当者別パフォーマンス
                if (reportSettings.memberAnalysisEnabled) {
                    const memberSummary = {};
                    const memberTasks = {};

                    // 全担当者を抽出
                    const allMembers = new Set();
                    filteredEstimates.forEach(e => allMembers.add(e.member));
                    filteredActuals.forEach(a => allMembers.add(a.member));

                    // 初期化
                    allMembers.forEach(member => {
                        memberSummary[member] = { estimate: 0, actual: 0 };
                        memberTasks[member] = new Set();
                    });

                    // 自動分割ロジック：見積担当者以外の実績を考慮して見積を再配分
                    filteredEstimates.forEach(estimate => {
                        // この見積に対する実績を取得
                        const relatedActuals = filteredActuals.filter(a =>
                            a.version === estimate.version &&
                            a.task === estimate.task &&
                            a.process === estimate.process
                        );

                        // 元の担当者以外の実績を集計
                        let otherMembersActualHours = 0;
                        const otherMembersHours = {};

                        relatedActuals.forEach(actual => {
                            if (actual.member !== estimate.member) {
                                otherMembersActualHours += actual.hours;
                                otherMembersHours[actual.member] = (otherMembersHours[actual.member] || 0) + actual.hours;
                            }
                        });

                        // 元の担当者の見積から他の担当者の実績を引く
                        const originalMemberEstimate = Math.max(0, estimate.hours - otherMembersActualHours);
                        memberSummary[estimate.member].estimate += originalMemberEstimate;
                        memberTasks[estimate.member].add(`${estimate.version}-${estimate.task}`);

                        // 他の担当者には実績分の見積を追加
                        Object.keys(otherMembersHours).forEach(otherMember => {
                            if (!memberSummary[otherMember]) {
                                memberSummary[otherMember] = { estimate: 0, actual: 0 };
                                memberTasks[otherMember] = new Set();
                            }
                            memberSummary[otherMember].estimate += otherMembersHours[otherMember];
                            memberTasks[otherMember].add(`${estimate.version}-${estimate.task}`);
                        });
                    });

                    // 実績を集計
                    filteredActuals.forEach(a => {
                        if (!memberSummary[a.member]) {
                            memberSummary[a.member] = { estimate: 0, actual: 0 };
                            memberTasks[a.member] = new Set();
                        }
                        memberSummary[a.member].actual += a.hours;
                        memberTasks[a.member].add(`${a.version}-${a.task}`);
                    });

                    // 担当者を設定された表示順でソート
                    let members;
                    const memberOrderInput = document.getElementById('memberOrder').value.trim();
                    if (memberOrderInput) {
                        const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                        const memberSet = new Set(Object.keys(memberSummary));
                        const orderedMembers = orderList.filter(m => memberSet.has(m));
                        const unorderedMembers = Object.keys(memberSummary).filter(m => !orderedMembers.includes(m)).sort();
                        members = [...orderedMembers, ...unorderedMembers];
                    } else {
                        members = Object.keys(memberSummary).sort();
                    }

                    if (members.length > 0) {
                        html += '<div style="background: #ffffff; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #e9ecef;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 16px;">担当者別パフォーマンス</h4>';

                        // グラフセクション
                        html += '<div style="margin-bottom: 20px;">';
                        html += '<h5 style="margin: 0 0 10px 0; color: #495057; font-size: 14px; font-weight: 600;">見積 vs 実績 比較</h5>';
                        html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 6px; overflow-x: auto;">';
                        html += '<canvas id="memberComparisonChart" style="max-width: 100%; height: 300px;"></canvas>';
                        html += '</div>';
                        html += '</div>';

                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">';

                        members.forEach(member => {
                            const data = memberSummary[member];
                            const accuracy = data.estimate > 0 ? (data.actual / data.estimate * 100).toFixed(1) : 0;
                            const diff = data.actual - data.estimate;
                            const estManDays = (data.estimate / 8).toFixed(1);
                            const actManDays = (data.actual / 8).toFixed(1);
                            const workingDaysPerMonth = 20;
                            const estManMonths = (data.estimate / 8 / workingDaysPerMonth).toFixed(2);
                            const actManMonths = (data.actual / 8 / workingDaysPerMonth).toFixed(2);
                            const taskCount = memberTasks[member] ? memberTasks[member].size : 0;

                            html += '<div style="background: #f8f9fa; padding: 12px; border-radius: 6px; border: 1px solid #e9ecef;">';
                            html += `<div style="font-weight: 600; margin-bottom: 8px; color: #495057;">${member}</div>`;
                            html += `<div style="font-size: 13px; color: #495057; margin-bottom: 2px;">見積: ${data.estimate.toFixed(1)}h</div>`;
                            html += `<div style="font-size: 12px; color: #6c757d; margin-left: 10px; margin-bottom: 6px;">${estManDays}人日 / ${estManMonths}人月</div>`;
                            html += `<div style="font-size: 13px; color: #495057; margin-bottom: 2px;">実績: ${data.actual.toFixed(1)}h</div>`;
                            html += `<div style="font-size: 12px; color: #6c757d; margin-left: 10px; margin-bottom: 6px;">${actManDays}人日 / ${actManMonths}人月</div>`;
                            html += `<div style="font-size: 13px; color: #495057;">精度: <span style="font-weight: 600;">${accuracy}%</span></div>`;
                            html += `<div style="font-size: 13px; color: #495057;">差分: <span style="color: ${diff > 0 ? '#dc3545' : '#28a745'};">${diff > 0 ? '+' : ''}${diff.toFixed(1)}h</span></div>`;
                            html += `<div style="font-size: 12px; color: #6c757d; margin-top: 5px;">担当タスク: ${taskCount}件</div>`;
                            html += '</div>';
                        });

                        html += '</div>';

                        // 内訳ドーナツグラフセクション
                        html += '<div style="margin-top: 20px;">';
                        html += '<h5 style="margin: 0 0 10px 0; color: #495057; font-size: 14px; font-weight: 600;">担当者別 工数内訳</h5>';
                        html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';

                        members.forEach((member, index) => {
                            html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 6px; text-align: center;">';
                            html += `<div style="font-weight: 600; margin-bottom: 10px; color: #495057;">${member}</div>`;
                            html += `<canvas id="memberDonutChart_${index}" class="donut-chart-canvas"></canvas>`;
                            html += '</div>';
                        });

                        html += '</div></div>';
                        html += '</div>';

                        // グラフ描画データを保存（クロージャーで渡す）
                        const chartData = {
                            members: members,
                            memberSummary: memberSummary,
                            filteredEstimates: filteredEstimates,
                            filteredActuals: filteredActuals
                        };

                        // グラフを描画するための遅延実行
                        setTimeout(() => {
                            drawMemberComparisonChart(chartData.members, chartData.memberSummary);
                            chartData.members.forEach((member, index) => {
                                drawMemberDonutChart(member, index, chartData.filteredEstimates, chartData.filteredActuals);
                            });
                        }, 100);
                    }
                }

                // AIライクなインサイト
                if (reportSettings.insightsEnabled) {
                    const insights = [];

                    // 全体の精度チェック
                    const totalEst = filteredEstimates.reduce((sum, e) => sum + e.hours, 0);
                    const totalAct = filteredActuals.reduce((sum, a) => sum + a.hours, 0);
                    const overallAccuracy = totalEst > 0 ? (totalAct / totalEst * 100) : 0;

                    if (overallAccuracy > 120) {
                        insights.push({
                            type: 'warning',
                            icon: '',
                            title: '見積精度に課題',
                            message: `全体で見積を${(overallAccuracy - 100).toFixed(0)}%超過しています。タスク分解の見直しが必要かもしれません。`
                        });
                    } else if (overallAccuracy >= 90 && overallAccuracy <= 110) {
                        insights.push({
                            type: 'success',
                            icon: '',
                            title: '優れた見積精度',
                            message: `見積精度${overallAccuracy.toFixed(1)}%で、非常に正確な見積ができています。`
                        });
                    }

                    // 最も効率的な工程
                    const processSummary = {};
                    filteredEstimates.forEach(e => {
                        if (!processSummary[e.process]) processSummary[e.process] = { estimate: 0, actual: 0 };
                        processSummary[e.process].estimate += e.hours;
                    });
                    filteredActuals.forEach(a => {
                        if (!processSummary[a.process]) processSummary[a.process] = { estimate: 0, actual: 0 };
                        processSummary[a.process].actual += a.hours;
                    });

                    let bestProcess = null;
                    let bestAccuracy = 1000;
                    Object.entries(processSummary).forEach(([proc, data]) => {
                        if (data.estimate > 0) {
                            const accuracy = Math.abs(100 - (data.actual / data.estimate * 100));
                            if (accuracy < bestAccuracy) {
                                bestAccuracy = accuracy;
                                bestProcess = proc;
                            }
                        }
                    });

                    if (bestProcess) {
                        insights.push({
                            type: 'info',
                            icon: '',
                            title: '最適な工程',
                            message: `${bestProcess}工程の見積精度が最も高く、計画通りに進行しています。`
                        });
                    }

                    // 担当者別の見積・実績・人月表示
                    const memberData = {};
                    filteredEstimates.forEach(e => {
                        if (!memberData[e.member]) memberData[e.member] = { estimate: 0, actual: 0 };
                        memberData[e.member].estimate += e.hours;
                    });
                    filteredActuals.forEach(a => {
                        if (!memberData[a.member]) memberData[a.member] = { estimate: 0, actual: 0 };
                        memberData[a.member].actual += a.hours;
                    });

                    // 担当者を見積工数でソート
                    const memberDataSorted = Object.entries(memberData).sort((a, b) => b[1].estimate - a[1].estimate);

                    // 高負荷担当者のチェック
                    const maxEstMember = memberDataSorted[0];
                    if (maxEstMember && selectedMonth !== 'all') {
                        const manMonths = (maxEstMember[1].estimate / 8 / workingDaysPerMonth).toFixed(2);
                        if (manMonths > 1.2) {
                            const manDays = (maxEstMember[1].estimate / 8).toFixed(1);
                            insights.push({
                                type: 'warning',
                                icon: '',
                                title: '高負荷担当者あり',
                                message: `${maxEstMember[0]}さんの見積工数が${manMonths}人月（${manDays}人日）で、リソース配分の見直しを検討してください。`
                            });
                        }
                    }

                    // タスク完了率
                    const estimatedTasks = new Set(filteredEstimates.map(e => `${e.version}-${e.task}`));
                    const actualTasks = new Set(filteredActuals.map(a => `${a.version}-${a.task}`));
                    const completedTasks = [...estimatedTasks].filter(t => actualTasks.has(t));
                    const completionRate = estimatedTasks.size > 0 ? (completedTasks.length / estimatedTasks.size * 100).toFixed(0) : 0;

                    if (completionRate < 100 && selectedMonth !== 'all') {
                        const pendingCount = estimatedTasks.size - completedTasks.length;
                        insights.push({
                            type: 'info',
                            icon: '',
                            title: '未完了タスクあり',
                            message: `見積済みタスクのうち${pendingCount}件が未完了です。進捗を確認してください。`
                        });
                    }

                    if (insights.length > 0) {
                        html += '<div style="background: #ffffff; padding: 15px; border-radius: 8px; border: 1px solid #e9ecef;">';
                        html += '<h4 style="margin: 0 0 10px 0; color: #495057; font-size: 16px;">インサイト</h4>';

                        insights.forEach(insight => {
                            const bgColor = insight.type === 'warning' ? '#fff5f5' :
                                          insight.type === 'success' ? '#d4edda' :
                                          '#cce5ff';
                            const borderColor = insight.type === 'warning' ? '#f5c6cb' :
                                          insight.type === 'success' ? '#c3e6cb' :
                                          '#b8daff';
                            const textColor = insight.type === 'warning' ? '#721c24' :
                                          insight.type === 'success' ? '#155724' :
                                          '#004085';

                            html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 6px; margin-bottom: 8px; border: 1px solid ${borderColor};">`;
                            html += `<div style="font-weight: 600; margin-bottom: 3px; color: ${textColor};">${insight.title}</div>`;
                            html += `<div style="font-size: 13px; color: ${textColor};">${insight.message}</div>`;
                            html += '</div>';
                        });

                        html += '</div>';
                    }
                }

                html += '</div>'; // close phase3-content
                html += '</div>';
            }

            container.innerHTML += html;
        }

        // 担当者別見積vs実績比較グラフを描画
        function drawMemberComparisonChart(members, memberSummary) {
            const canvas = document.getElementById('memberComparisonChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // キャンバスのサイズを設定
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            // モバイル対応：画面幅に応じてパディングと凡例位置を調整
            const isMobile = width < 768;
            const padding = isMobile
                ? { top: 30, right: 20, bottom: 90, left: 50 }  // モバイル：凡例を下に配置するため bottom を増やす
                : { top: 40, right: 100, bottom: 60, left: 80 };
            const chartWidth = width - padding.left - padding.right;
            const chartHeight = height - padding.top - padding.bottom;

            // データの最大値を取得
            let maxValue = 0;
            members.forEach(member => {
                const data = memberSummary[member];
                maxValue = Math.max(maxValue, data.estimate, data.actual);
            });
            maxValue = Math.ceil(maxValue * 1.1); // 10%余裕を持たせる

            // 背景を塗りつぶす
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);

            // グリッド線を描画
            ctx.strokeStyle = '#dee2e6';
            ctx.lineWidth = 1;
            ctx.setLineDash([2, 2]);
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(padding.left + chartWidth, y);
                ctx.stroke();

                // Y軸ラベル
                const value = maxValue - (maxValue / 5) * i;
                ctx.fillStyle = '#495057';
                ctx.font = isMobile ? '10px sans-serif' : '12px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(value.toFixed(0) + 'h', padding.left - 10, y + 4);
            }
            ctx.setLineDash([]);

            // バーを描画
            // モバイル対応：バー間隔を調整
            const barSpacing = isMobile ? 2 : 5;  // 見積と実績の間隔（モバイルでより狭く）
            const barWidth = isMobile
                ? (chartWidth / members.length) * 0.35  // モバイル：各バーを細く
                : chartWidth / members.length / 2.5;
            const groupWidth = chartWidth / members.length;

            // カラースキームを取得
            const colorScheme = getActiveChartColorScheme();

            members.forEach((member, index) => {
                const data = memberSummary[member];
                const x = padding.left + groupWidth * index + groupWidth / 2;

                // 見積のバー
                const estimateHeight = (data.estimate / maxValue) * chartHeight;
                ctx.fillStyle = colorScheme.barColors.estimate;
                ctx.fillRect(x - barWidth - barSpacing, padding.top + chartHeight - estimateHeight, barWidth, estimateHeight);

                // 実績のバー
                const actualHeight = (data.actual / maxValue) * chartHeight;
                ctx.fillStyle = colorScheme.barColors.actual;
                ctx.fillRect(x + barSpacing, padding.top + chartHeight - actualHeight, barWidth, actualHeight);

                // X軸ラベル（担当者名）
                ctx.fillStyle = '#495057';
                ctx.font = isMobile ? '9px sans-serif' : '11px sans-serif';
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(x, padding.top + chartHeight + 15);
                ctx.rotate(-Math.PI / 6);
                ctx.fillText(member, 0, 0);
                ctx.restore();
            });

            // 凡例を描画（モバイルでは下部に配置）
            if (isMobile) {
                // モバイル：凡例を下部中央に配置
                const legendY = padding.top + chartHeight + 70;
                const legendX = width / 2 - 60;

                ctx.fillStyle = colorScheme.barColors.estimate;
                ctx.fillRect(legendX, legendY, 12, 12);
                ctx.fillStyle = '#495057';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('見積', legendX + 18, legendY + 10);

                ctx.fillStyle = colorScheme.barColors.actual;
                ctx.fillRect(legendX + 60, legendY, 12, 12);
                ctx.fillStyle = '#495057';
                ctx.fillText('実績', legendX + 78, legendY + 10);
            } else {
                // デスクトップ：凡例を右側に配置
                ctx.fillStyle = colorScheme.barColors.estimate;
                ctx.fillRect(padding.left + chartWidth + 10, padding.top, 15, 15);
                ctx.fillStyle = '#495057';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('見積', padding.left + chartWidth + 30, padding.top + 12);

                ctx.fillStyle = colorScheme.barColors.actual;
                ctx.fillRect(padding.left + chartWidth + 10, padding.top + 25, 15, 15);
                ctx.fillStyle = '#495057';
                ctx.fillText('実績', padding.left + chartWidth + 30, padding.top + 37);
            }

            // タイトル
            ctx.fillStyle = '#495057';
            ctx.font = isMobile ? 'bold 12px sans-serif' : 'bold 14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('担当者別 見積 vs 実績 (時間)', width / 2, isMobile ? 18 : 20);
        }

        // 担当者別工数内訳ドーナツグラフを描画
        function drawMemberDonutChart(member, index, filteredEstimates, filteredActuals) {
            const canvasId = `memberDonutChart_${index}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            // キャンバスのサイズを設定
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = rect.height;

            // モバイル対応：凡例の高さを考慮してグラフ位置を調整
            const isMobile = width < 768;
            const legendHeight = 60;  // 凡例の高さの見積もり
            const centerX = width / 2;
            const centerY = isMobile ? (height - legendHeight) / 2 : height / 2 - 10;
            const radius = isMobile
                ? Math.min(width, height - legendHeight - 40) / 2.5
                : Math.min(width, height - 40) / 2.2;
            const innerRadius = radius * 0.5;

            // この担当者の実績を工程別に集計
            const processHours = {};
            filteredActuals
                .filter(a => a.member === member)
                .forEach(a => {
                    const process = a.process || 'その他';
                    processHours[process] = (processHours[process] || 0) + a.hours;
                });

            const processes = Object.keys(processHours);
            if (processes.length === 0) {
                // データがない場合 - より目立つように表示
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);

                ctx.fillStyle = '#6c757d';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('実績データなし', centerX, centerY - 10);

                ctx.font = '12px sans-serif';
                ctx.fillStyle = '#adb5bd';
                ctx.fillText('(見積のみ)', centerX, centerY + 10);
                return;
            }

            const total = processes.reduce((sum, p) => sum + processHours[p], 0);

            // カラースキームを取得
            const colorScheme = getActiveChartColorScheme();

            // フォールバックカラー（定義されていない工程用）
            const fallbackColors = [
                '#667eea', '#f093fb', '#4facfe', '#43e97b',
                '#fa709a', '#30cfd0', '#a8edea', '#fbc2eb'
            ];

            // 工程の色を取得する関数
            const getProcessColor = (process) => {
                // 工程名を大文字に変換して照合
                const upperProcess = process.toUpperCase();
                if (colorScheme.processColors[upperProcess]) {
                    return colorScheme.processColors[upperProcess];
                }
                // 定義されていない工程はフォールバック色を使用
                const unknownProcesses = processes.filter(p => !colorScheme.processColors[p.toUpperCase()]);
                const index = unknownProcesses.indexOf(process);
                return fallbackColors[index % fallbackColors.length];
            };

            // ドーナツを描画
            let startAngle = -Math.PI / 2;
            processes.forEach((process) => {
                const angle = (processHours[process] / total) * 2 * Math.PI;
                const endAngle = startAngle + angle;

                ctx.fillStyle = getProcessColor(process);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);
                ctx.closePath();
                ctx.fill();

                startAngle = endAngle;
            });

            // 中央に合計を表示
            ctx.fillStyle = '#495057';
            ctx.font = 'bold 16px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(total.toFixed(1) + 'h', centerX, centerY - 5);
            ctx.font = '11px sans-serif';
            ctx.fillText('合計実績', centerX, centerY + 12);

            // 凡例を描画
            const legendX = 10;
            // モバイル対応：凡例がグラフに被らないよう下部に配置
            const legendStartY = isMobile
                ? centerY + radius + 20  // グラフの下から余裕を持って配置
                : height - 10 - (processes.length * 16);
            let legendY = legendStartY;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.font = isMobile ? '10px sans-serif' : '11px sans-serif';

            processes.forEach((process) => {
                const percentage = (processHours[process] / total * 100).toFixed(1);

                ctx.fillStyle = getProcessColor(process);
                ctx.fillRect(legendX, legendY, 10, 10);

                ctx.fillStyle = '#495057';
                const label = `${process} (${percentage}%)`;
                ctx.fillText(label, legendX + 15, legendY + 5);

                legendY += isMobile ? 14 : 16;  // モバイルでは行間を詰める
            });
        }

        function renderReportGrouped(filteredActuals, filteredEstimates) {
            const container = document.getElementById('reportDetailView');

            // 選択月の実働日数を取得
            const selectedMonth = document.getElementById('reportMonth').value;
            let workingDaysPerMonth = 20; // デフォルト
            if (selectedMonth !== 'all') {
                const [year, month] = selectedMonth.split('-');
                workingDaysPerMonth = getWorkingDays(parseInt(year), parseInt(month));
            }

            // 版数ごとにグループ化
            const versionGroups = {};
            
            // 見積データを追加（フィルタ済み）
            filteredEstimates.forEach(e => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(e)) {
                    version = 'その他付随作業';
                    taskKey = e.task && e.task.trim() !== '' ? e.task : '未分類作業';
                } else {
                    version = e.version;
                    taskKey = e.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                if (!versionGroups[version][taskKey].estimates[e.process]) {
                    versionGroups[version][taskKey].estimates[e.process] = { members: new Set(), hours: 0 };
                }
                versionGroups[version][taskKey].estimates[e.process].members.add(e.member);
                versionGroups[version][taskKey].estimates[e.process].hours += e.hours;
            });
            
            // 実績データを追加（担当者も集計）
            filteredActuals.forEach(a => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(a)) {
                    version = 'その他付随作業';
                    taskKey = a.task && a.task.trim() !== '' ? a.task : '未分類作業';
                } else {
                    version = a.version;
                    taskKey = a.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                if (!versionGroups[version][taskKey].actuals[a.process]) {
                    versionGroups[version][taskKey].actuals[a.process] = { members: new Set(), hours: 0 };
                }
                versionGroups[version][taskKey].actuals[a.process].members.add(a.member);
                versionGroups[version][taskKey].actuals[a.process].hours += a.hours;
            });
            
            // データがない場合
            if (Object.keys(versionGroups).length === 0) {
                container.innerHTML += '<p style="color: #999; text-align: center; padding: 40px;">該当するデータがありません</p>';
                return;
            }
            
            let html = '<h3 style="margin-top: 30px;">対応別詳細（見積 vs 実績）</h3>';
            html += '<div style="margin-bottom: 30px;">';

            // 版数ごとに表示（「その他付随作業」を最後に）
            const versions = Object.keys(versionGroups).sort((a, b) => {
                if (a === 'その他付随作業') return 1;
                if (b === 'その他付随作業') return -1;
                return a.localeCompare(b);
            });

            versions.forEach(version => {
                // 先にテーブル本体を生成して、データがあるかチェック
                let tableBody = '';
                let versionTotalEst = 0;
                let versionTotalAct = 0;

                Object.values(versionGroups[version]).forEach(taskGroup => {
                    const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];
                    const allProcesses = new Set([...Object.keys(taskGroup.estimates), ...Object.keys(taskGroup.actuals)]);

                    // processOrderに含まれる工程を先に、その後に含まれない工程を追加
                    const sortedProcesses = [
                        ...processOrder.filter(p => allProcesses.has(p)),
                        ...[...allProcesses].filter(p => !processOrder.includes(p))
                    ];

                    if (sortedProcesses.length === 0) return;
                    
                    // 先に合計を計算
                    let totalEst = 0;
                    let totalAct = 0;
                    sortedProcesses.forEach(proc => {
                        const est = taskGroup.estimates[proc] || { members: new Set(), hours: 0 };
                        const act = taskGroup.actuals[proc] || { members: new Set(), hours: 0 };
                        totalEst += est.hours;
                        totalAct += act.hours;
                    });
                    const totalDiff = totalAct - totalEst;

                    // 版数の合計に加算
                    versionTotalEst += totalEst;
                    versionTotalAct += totalAct;
                    
                    // 行を表示
                    sortedProcesses.forEach((proc, index) => {
                        const est = taskGroup.estimates[proc] || { members: new Set(), hours: 0 };
                        const act = taskGroup.actuals[proc] || { members: new Set(), hours: 0 };
                        const diff = act.hours - est.hours;

                        // 実績ベースで担当者を表示（実績がなければ見積）
                        let memberDisplay = '-';
                        const allMembers = new Set([...est.members, ...act.members]);
                        if (act.members.size > 0) {
                            memberDisplay = Array.from(act.members).join(',');
                        } else if (est.members.size > 0) {
                            memberDisplay = Array.from(est.members).join(',');
                        }

                        // 複数担当者がいる場合はクリック可能に
                        const isMultipleMember = allMembers.size > 1;
                        const memberCellStyle = isMultipleMember ?
                            'word-break: break-word; cursor: pointer; color: #3498db; text-decoration: underline;' :
                            'word-break: break-word;';
                        const memberOnclick = isMultipleMember ?
                            `onclick="showProcessBreakdown('${version.replace(/'/g, "\\'")}', '${taskGroup.task.replace(/'/g, "\\'")}', '${proc}', actuals, estimates)" title="クリックして内訳を表示"` :
                            '';

                        // 進捗バーを生成
                        const progressBarHtml = generateProgressBar(version, taskGroup.task, proc);

                        tableBody += '<tr>';
                        if (index === 0) {
                            // 対応名を「：」（全角コロン）で分割して2行表示
                            let taskDisplayHtml = taskGroup.task;
                            if (taskGroup.task.includes('：')) {
                                const parts = taskGroup.task.split('：');
                                const restPart = parts.slice(1).join('：');
                                taskDisplayHtml = `${parts[0]}<br><span style="font-size: 13px; font-weight: normal;">${restPart}</span>`;
                            }
                            tableBody += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; font-weight: 600;">${taskDisplayHtml}</td>`;
                        }
                        tableBody += `<td><span class="badge badge-${proc.toLowerCase()}">${proc}</span></td>`;
                        tableBody += `<td style="${memberCellStyle}" ${memberOnclick}>${memberDisplay}</td>`;
                        tableBody += `<td style="text-align: right;">${est.hours > 0 ? est.hours.toFixed(1) + 'h' : '-'}</td>`;
                        tableBody += `<td style="text-align: right;">${act.hours > 0 ? act.hours.toFixed(1) + 'h' : '-'}</td>`;
                        tableBody += `<td style="text-align: right; color: ${diff > 0 ? '#e74c3c' : diff < 0 ? '#27ae60' : '#666'}">${diff !== 0 ? (diff > 0 ? '+' : '') + diff.toFixed(1) + 'h' : '-'}</td>`;
                        // 進捗バースタイルに応じてセルスタイルを調整
                        const progressCellStyle = progressBarHtml && progressBarStyle === 'bottom'
                            ? 'min-width: 100px; padding: 8px 8px 12px 8px; position: relative;'
                            : 'min-width: 100px; padding: 8px;';
                        tableBody += `<td style="${progressCellStyle}">${progressBarHtml || '<span style="color: #ccc; font-size: 11px;">-</span>'}</td>`;
                        if (index === 0) {
                            tableBody += `<td rowspan="${sortedProcesses.length}" style="vertical-align: top; padding-top: 12px; text-align: right;">
                                <div style="font-weight: 600;">見積: ${totalEst.toFixed(1)}h</div>
                                <div style="font-weight: 600;">実績: ${totalAct.toFixed(1)}h</div>
                                <div style="font-weight: 700; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">差異: ${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}h</div>
                            </td>`;
                        }
                        tableBody += '</tr>';
                    });
                });

                // テーブル本体にデータがある場合のみ表示
                if (tableBody) {
                    const versionTotalDiff = versionTotalAct - versionTotalEst;

                    html += `<div style="margin-bottom: 30px;">`;
                    html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                    html += '<div class="table-wrapper"><table>';
                    html += '<tr><th style="min-width: 150px;">対応名</th><th style="min-width: 80px;">工程</th><th style="min-width: 80px;">担当</th><th style="min-width: 80px;">見積</th><th style="min-width: 80px;">実績</th><th style="min-width: 80px;">差異</th><th style="min-width: 100px;">進捗</th><th style="min-width: 100px;">対応合計</th></tr>';
                    html += tableBody;

                    // 合計行を追加
                    html += '<tr style="background: #f5f5f5; font-weight: bold; border-top: 2px solid #ddd;">';
                    html += `<td style="padding: 12px; position: sticky; left: 0; background: #f5f5f5; z-index: 1;">合計</td>`;
                    html += '<td></td>';
                    html += '<td></td>';
                    html += `<td style="text-align: right;">${versionTotalEst.toFixed(1)}h</td>`;
                    html += `<td style="text-align: right;">${versionTotalAct.toFixed(1)}h</td>`;
                    html += `<td style="text-align: right; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}h</td>`;
                    html += '<td></td>'; // 進捗列
                    html += '<td></td>'; // 対応合計列
                    html += '</tr>';

                    html += '</table></div>';
                    html += '</div>';
                }
            });

            html += '</div>';
            container.innerHTML += html;
        }

        // 見積と実績の乖離率に基づいて背景色を計算
        function getDeviationColor(estimate, actual) {
            // 設定がオフの場合は白を返す
            if (!showDeviationColorsSetting) {
                return '#ffffff';
            }

            if (estimate === 0 && actual === 0) {
                return '#ffffff'; // 両方0は白
            }
            if (estimate === 0 && actual > 0) {
                return '#fffef0'; // 見積なし実績あり：薄い黄
            }
            if (estimate > 0 && actual === 0) {
                return '#f0f8ff'; // 見積のみ：薄い青
            }

            const deviation = ((actual - estimate) / estimate) * 100;

            if (Math.abs(deviation) < 3) {
                return '#ffffff'; // ±3%以内は白
            }

            if (deviation > 0) {
                // 実績 > 見積：赤系（10段階）
                if (deviation < 5) return '#fff8f8';
                if (deviation < 8) return '#fff0f0';
                if (deviation < 12) return '#ffe8e8';
                if (deviation < 18) return '#ffe0e0';
                if (deviation < 25) return '#ffd0d0';
                if (deviation < 35) return '#ffc0c0';
                if (deviation < 50) return '#ffb0b0';
                if (deviation < 70) return '#ffa0a0';
                if (deviation < 100) return '#ff9090';
                return '#ff8080';
            } else {
                // 実績 < 見積：緑系（10段階）
                const absDeviation = Math.abs(deviation);
                if (absDeviation < 5) return '#f8fff8';
                if (absDeviation < 8) return '#f0fff0';
                if (absDeviation < 12) return '#e8ffe8';
                if (absDeviation < 18) return '#e0ffe0';
                if (absDeviation < 25) return '#d0ffd0';
                if (absDeviation < 35) return '#c0ffc0';
                if (absDeviation < 50) return '#b0ffb0';
                if (absDeviation < 70) return '#a0ffa0';
                if (absDeviation < 100) return '#90ff90';
                return '#80ff80';
            }
        }

        function renderReportMatrix(filteredActuals, filteredEstimates, selectedMonth) {
            const container = document.getElementById('reportDetailView');

            // 全期間かつ設定がオンの時のみ色付けする
            const showMonthColors = selectedMonth === 'all' && showMonthColorsSetting;

            // 使用されている月を収集（凡例用）
            const usedMonths = new Set();
            let hasMultipleMonths = false;
            let hasUnassigned = false;

            // 版数ごとにグループ化
            const versionGroups = {};

            // 見積データを追加（フィルタ済み）
            filteredEstimates.forEach(e => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(e)) {
                    version = 'その他付随作業';
                    taskKey = e.task && e.task.trim() !== '' ? e.task : '未分類作業';
                } else {
                    version = e.version;
                    taskKey = e.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }

                // 正規化してworkMonthsを取得 & 複数月・未設定の判定
                const est = normalizeEstimate(e);
                if (est.workMonths && est.workMonths.length > 0) {
                    est.workMonths.forEach(m => usedMonths.add(m));
                    if (est.workMonths.length > 1) {
                        hasMultipleMonths = true;
                    }
                } else {
                    hasUnassigned = true;
                }

                if (!versionGroups[version][taskKey].estimates[e.process]) {
                    versionGroups[version][taskKey].estimates[e.process] = {
                        members: new Set(),
                        hours: 0,
                        workMonths: est.workMonths || []
                    };
                }
                versionGroups[version][taskKey].estimates[e.process].members.add(e.member);
                versionGroups[version][taskKey].estimates[e.process].hours += e.hours;
            });

            // 実績データを追加
            filteredActuals.forEach(a => {
                // 版数または対応名が未設定の場合は「その他付随作業」として扱う
                let version, taskKey;
                if (isOtherWork(a)) {
                    version = 'その他付随作業';
                    taskKey = a.task && a.task.trim() !== '' ? a.task : '未分類作業';
                } else {
                    version = a.version;
                    taskKey = a.task;
                }

                if (!versionGroups[version]) {
                    versionGroups[version] = {};
                }
                if (!versionGroups[version][taskKey]) {
                    versionGroups[version][taskKey] = {
                        task: taskKey,
                        estimates: {},
                        actuals: {}
                    };
                }
                if (!versionGroups[version][taskKey].actuals[a.process]) {
                    versionGroups[version][taskKey].actuals[a.process] = { members: new Set(), hours: 0 };
                }
                versionGroups[version][taskKey].actuals[a.process].members.add(a.member);
                versionGroups[version][taskKey].actuals[a.process].hours += a.hours;
            });
            
            // データがない場合
            if (Object.keys(versionGroups).length === 0) {
                container.innerHTML += '<p style="color: #999; text-align: center; padding: 40px;">該当するデータがありません</p>';
                return;
            }
            
            const processOrder = ['UI', 'PG', 'PT', 'IT', 'ST'];

            let html = '<h3 style="margin-top: 30px;">対応別マトリクス（見積 vs 実績）</h3>';

            // 月カラー凡例を追加（全期間の時のみ）
            if (showMonthColors) {
                html += generateMonthColorLegend(usedMonths, hasMultipleMonths, hasUnassigned);
            }

            html += '<div style="margin-bottom: 30px;">';

            // 版数ごとに表示（「その他付随作業」を最後に）
            const versions = Object.keys(versionGroups).sort((a, b) => {
                if (a === 'その他付随作業') return 1;
                if (b === 'その他付随作業') return -1;
                return a.localeCompare(b);
            });

            versions.forEach(version => {
                // この版数グループ内の全工程を収集
                const versionProcesses = new Set();
                Object.values(versionGroups[version]).forEach(taskGroup => {
                    Object.keys(taskGroup.estimates).forEach(p => versionProcesses.add(p));
                    Object.keys(taskGroup.actuals).forEach(p => versionProcesses.add(p));
                });

                // processOrderに含まれる工程を先に、その後に含まれない工程を追加
                const displayProcesses = [
                    ...processOrder.filter(p => versionProcesses.has(p)),
                    ...[...versionProcesses].filter(p => !processOrder.includes(p))
                ];

                // 先にテーブル本体を生成して、データがあるかチェック
                let tableBody = '';
                let versionTotalEst = 0;
                let versionTotalAct = 0;

                Object.values(versionGroups[version]).forEach(taskGroup => {
                    // 全工程を取得
                    const allProcesses = new Set([...Object.keys(taskGroup.estimates), ...Object.keys(taskGroup.actuals)]);

                    let totalEst = 0;
                    let totalAct = 0;

                    // 先に合計を計算してデータの有無を確認
                    displayProcesses.forEach(proc => {
                        const est = taskGroup.estimates[proc] || { members: new Set(), hours: 0 };
                        const act = taskGroup.actuals[proc] || { members: new Set(), hours: 0 };
                        totalEst += est.hours;
                        totalAct += act.hours;
                    });

                    // 見積または実績のいずれかにデータがある場合のみ行を追加
                    if (totalEst > 0 || totalAct > 0) {
                        // 版数の合計に加算
                        versionTotalEst += totalEst;
                        versionTotalAct += totalAct;

                        // 対応名を「：」（全角コロン）で分割して2行表示
                        let taskDisplayHtml = taskGroup.task;
                        if (taskGroup.task.includes('：')) {
                            const parts = taskGroup.task.split('：');
                            const restPart = parts.slice(1).join('：');
                            taskDisplayHtml = `${parts[0]}<br><span style="font-size: 13px; font-weight: normal;">${restPart}</span>`;
                        }

                        tableBody += '<tr>';
                        tableBody += `<td style="font-weight: 600;">${taskDisplayHtml}</td>`;

                        displayProcesses.forEach(proc => {
                            const est = taskGroup.estimates[proc] || { members: new Set(), hours: 0, workMonths: [] };
                            const act = taskGroup.actuals[proc] || { members: new Set(), hours: 0 };

                            if (est.hours > 0 || act.hours > 0) {
                                const diff = act.hours - est.hours;

                                // 担当者を実績ベースで表示（実績がなければ見積）
                                let memberDisplay = '-';
                                const allMembers = new Set([...est.members, ...act.members]);
                                if (act.members.size > 0) {
                                    memberDisplay = Array.from(act.members).join(',');
                                } else if (est.members.size > 0) {
                                    memberDisplay = Array.from(est.members).join(',');
                                }

                                // 複数担当者がいる場合はクリック可能に（event.stopPropagation()でセルクリックを防ぐ）
                                const isMultipleMember = allMembers.size > 1;
                                const memberStyle = isMultipleMember ?
                                    'cursor: pointer; color: #3498db; text-decoration: underline;' :
                                    '';
                                const memberOnclick = isMultipleMember ?
                                    `onclick="event.stopPropagation(); showProcessBreakdown('${version.replace(/'/g, "\\'")}', '${taskGroup.task.replace(/'/g, "\\'")}', '${proc}', actuals, estimates)" title="クリックして内訳を表示"` :
                                    '';

                                // 乖離率に基づく背景色を計算
                                const deviationBgColor = getDeviationColor(est.hours, act.hours);

                                // 設定がオンの時に月に基づく背景色を適用（乖離色の代わりに）
                                const monthColor = showMonthColors ? getMonthColor(est.workMonths || []) : { bg: '', tooltip: '' };
                                const bgColor = showMonthColors ? monthColor.bg : deviationBgColor;

                                // 進捗バーを生成
                                const progressBarHtml = generateProgressBar(version, taskGroup.task, proc);

                                // 見積と実績の表示形式に応じて分岐
                                let cellHtml = '';
                                if (matrixEstActFormat === 'twoRows') {
                                    // 2行表示
                                    cellHtml = `
                                        <div style="font-size: 0.85em; font-weight: 300; color: #666;">${est.hours > 0 ? est.hours.toFixed(1) : '-'}</div>
                                        <div style="font-weight: 600; margin-top: 2px;">${act.hours > 0 ? act.hours.toFixed(1) : '-'}</div>
                                        <div style="font-size: 11px; color: #666; margin-top: 4px; ${memberStyle}" ${memberOnclick}>(${memberDisplay})</div>
                                        <div style="font-size: 11px; margin-top: 2px; color: ${diff > 0 ? '#e74c3c' : diff < 0 ? '#27ae60' : '#666'}">${diff !== 0 ? (diff > 0 ? '+' : '') + diff.toFixed(1) : '-'}</div>
                                        ${progressBarHtml}
                                    `;
                                } else {
                                    // スラッシュ横並び
                                    cellHtml = `
                                        <div style="font-weight: 600;">${est.hours > 0 ? est.hours.toFixed(1) : '-'} / ${act.hours > 0 ? act.hours.toFixed(1) : '-'}</div>
                                        <div style="font-size: 11px; color: #666; margin-top: 4px; ${memberStyle}" ${memberOnclick}>(${memberDisplay})</div>
                                        <div style="font-size: 11px; margin-top: 2px; color: ${diff > 0 ? '#e74c3c' : diff < 0 ? '#27ae60' : '#666'}">${diff !== 0 ? (diff > 0 ? '+' : '') + diff.toFixed(1) : '-'}</div>
                                        ${progressBarHtml}
                                    `;
                                }

                                // 進捗バースタイルに応じてセルスタイルを調整
                                const matrixCellStyle = progressBarHtml && progressBarStyle === 'bottom'
                                    ? `text-align: center; background: ${bgColor}; padding: 8px 8px 12px 8px; position: relative; cursor: pointer;`
                                    : `text-align: center; background: ${bgColor}; padding: 8px; cursor: pointer;`;

                                // セルクリック時に見込残存時間入力モーダルを開く
                                const cellOnclick = `onclick="openRemainingHoursModal('${version.replace(/'/g, "\\'")}', '${taskGroup.task.replace(/'/g, "\\'")}', '${proc}')"`;

                                tableBody += `<td style="${matrixCellStyle}" ${cellOnclick} ${showMonthColors ? `title="${monthColor.tooltip}"` : ''}>${cellHtml}</td>`;
                            } else {
                                tableBody += `<td style="text-align: center; color: #ccc;">-</td>`;
                            }
                        });

                        const totalDiff = totalAct - totalEst;
                        // 人日・人月を計算（見積・実績それぞれ）
                        const estDays = totalEst / 8;
                        const estMonths = estDays / 20;
                        const actDays = totalAct / 8;
                        const actMonths = actDays / 20;

                        // 合計列の背景色
                        const totalBgColor = getDeviationColor(totalEst, totalAct);

                        // 見積と実績の表示形式 & 人日/人月の表示形式に応じて分岐
                        let totalCellHtml = '';
                        if (matrixEstActFormat === 'slash') {
                            // スラッシュ横並び表示の場合は案1形式
                            totalCellHtml = `
                                <div style="font-weight: 600;">${totalEst.toFixed(1)} / ${totalAct.toFixed(1)}</div>
                                <div style="font-size: 0.85em; color: #666; margin-top: 2px;">${estDays.toFixed(1)}人日/${actDays.toFixed(1)}人日</div>
                                <div style="font-size: 0.85em; color: #666;">${estMonths.toFixed(2)}人月/${actMonths.toFixed(2)}人月</div>
                                <div style="font-size: 11px; margin-top: 2px; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}</div>
                            `;
                        } else {
                            // 2行表示の場合は既存の人日/人月表示形式設定に従う
                            if (matrixDayMonthFormat === 'inline') {
                                // 案1: 横に括弧で表示（デフォルト）
                                totalCellHtml = `
                                    <div style="font-size: 0.85em; font-weight: 300; color: #666;">${totalEst.toFixed(1)} <span style="font-size: 0.9em;">(${estDays.toFixed(1)}人日/${estMonths.toFixed(2)}人月)</span></div>
                                    <div style="font-weight: 600; margin-top: 2px;">${totalAct.toFixed(1)} <span style="font-size: 0.9em; font-weight: 400;">(${actDays.toFixed(1)}人日/${actMonths.toFixed(2)}人月)</span></div>
                                    <div style="font-size: 11px; margin-top: 2px; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}</div>
                                `;
                            } else if (matrixDayMonthFormat === 'separate') {
                                // 案2: 別行で表示
                                totalCellHtml = `
                                    <div style="font-size: 0.85em; font-weight: 300; color: #666;">見積: ${totalEst.toFixed(1)} / 実績: ${totalAct.toFixed(1)}</div>
                                    <div style="font-size: 0.75em; color: #666; margin-top: 2px;">見積: ${estDays.toFixed(1)}人日/${estMonths.toFixed(2)}人月</div>
                                    <div style="font-size: 0.75em; color: #666;">実績: ${actDays.toFixed(1)}人日/${actMonths.toFixed(2)}人月</div>
                                    <div style="font-size: 11px; margin-top: 2px; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}</div>
                                `;
                            } else if (matrixDayMonthFormat === 'side') {
                                // 案3: 右側に表示
                                totalCellHtml = `
                                    <div style="display: flex; justify-content: space-between; font-size: 0.85em; font-weight: 300; color: #666;">
                                        <span>見積 ${totalEst.toFixed(1)}</span><span style="font-size: 0.9em;">${estDays.toFixed(1)}人日/${estMonths.toFixed(2)}人月</span>
                                    </div>
                                    <div style="display: flex; justify-content: space-between; font-weight: 600; margin-top: 2px;">
                                        <span>実績 ${totalAct.toFixed(1)}</span><span style="font-size: 0.9em; font-weight: 400;">${actDays.toFixed(1)}人日/${actMonths.toFixed(2)}人月</span>
                                    </div>
                                    <div style="font-size: 11px; margin-top: 2px; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}</div>
                                `;
                            } else if (matrixDayMonthFormat === 'arrow') {
                                // 案4: 矢印で表示
                                totalCellHtml = `
                                    <div style="font-size: 0.85em; font-weight: 300; color: #666;">見積 ${totalEst.toFixed(1)} → ${estDays.toFixed(1)}人日/${estMonths.toFixed(2)}人月</div>
                                    <div style="font-weight: 600; margin-top: 2px;">実績 ${totalAct.toFixed(1)} → ${actDays.toFixed(1)}人日/${actMonths.toFixed(2)}人月</div>
                                    <div style="font-size: 11px; margin-top: 2px; color: ${totalDiff > 0 ? '#e74c3c' : totalDiff < 0 ? '#27ae60' : '#666'}">${totalDiff > 0 ? '+' : ''}${totalDiff.toFixed(1)}</div>
                                `;
                            }
                        }

                        tableBody += `<td style="text-align: center; background: ${totalBgColor}; padding: 8px;">${totalCellHtml}</td>`;
                        tableBody += '</tr>';
                    }
                });

                // テーブル本体にデータがある場合のみ表示
                if (tableBody) {
                    const versionTotalDiff = versionTotalAct - versionTotalEst;

                    html += `<div style="margin-bottom: 30px;">`;
                    html += `<h3 class="version-header theme-bg theme-${currentThemeColor}" style="color: white; padding: 12px 20px; border-radius: 8px; margin: 0 0 15px 0; font-size: 18px;">${version}</h3>`;
                    html += '<div class="table-wrapper"><table>';
                    html += '<tr><th style="min-width: 200px;">対応名</th>';
                    displayProcesses.forEach(proc => {
                        html += `<th style="min-width: 120px; text-align: center;">${proc}<br><small style="font-weight: normal; opacity: 0.8;">見積/実績</small></th>`;
                    });
                    html += '<th style="min-width: 100px; text-align: center;">合計<br><small style="font-weight: normal; opacity: 0.8;">見積/実績</small></th></tr>';
                    html += tableBody;

                    // 合計行を追加
                    html += '<tr style="background: #f5f5f5; font-weight: bold; border-top: 2px solid #ddd;">';
                    html += `<td style="padding: 12px; position: sticky; left: 0; background: #f5f5f5; z-index: 1;">合計</td>`;
                    // 各工程の列を空にする
                    displayProcesses.forEach(() => {
                        html += '<td></td>';
                    });
                    // 合計列（人日・人月を追加）
                    const totalEstDays = (versionTotalEst / 8).toFixed(1);
                    const totalEstMonths = (versionTotalEst / 8 / 20).toFixed(2);
                    const totalActDays = (versionTotalAct / 8).toFixed(1);
                    const totalActMonths = (versionTotalAct / 8 / 20).toFixed(2);
                    const versionTotalBgColor = getDeviationColor(versionTotalEst, versionTotalAct);

                    // 見積と実績の表示形式 & 人日/人月の表示形式に応じて分岐
                    let versionTotalCellHtml = '';
                    if (matrixEstActFormat === 'slash') {
                        // スラッシュ横並び表示の場合は案1形式
                        versionTotalCellHtml = `
                            <div style="font-weight: 600;">${versionTotalEst.toFixed(1)} / ${versionTotalAct.toFixed(1)}</div>
                            <div style="font-size: 0.85em; color: #666; margin-top: 2px;">${totalEstDays}人日/${totalActDays}人日</div>
                            <div style="font-size: 0.85em; color: #666;">${totalEstMonths}人月/${totalActMonths}人月</div>
                            <div style="font-size: 11px; margin-top: 2px; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}</div>
                        `;
                    } else {
                        // 2行表示の場合は既存の人日/人月表示形式設定に従う
                        if (matrixDayMonthFormat === 'inline') {
                            // 案1: 横に括弧で表示（デフォルト）
                            versionTotalCellHtml = `
                                <div style="font-size: 0.85em; font-weight: 300; color: #666;">${versionTotalEst.toFixed(1)} <span style="font-size: 0.9em;">(${totalEstDays}人日/${totalEstMonths}人月)</span></div>
                                <div style="font-weight: 600; margin-top: 2px;">${versionTotalAct.toFixed(1)} <span style="font-size: 0.9em; font-weight: 400;">(${totalActDays}人日/${totalActMonths}人月)</span></div>
                                <div style="font-size: 11px; margin-top: 2px; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}</div>
                            `;
                        } else if (matrixDayMonthFormat === 'separate') {
                            // 案2: 別行で表示
                            versionTotalCellHtml = `
                                <div style="font-size: 0.85em; font-weight: 300; color: #666;">見積: ${versionTotalEst.toFixed(1)} / 実績: ${versionTotalAct.toFixed(1)}</div>
                                <div style="font-size: 0.75em; color: #666; margin-top: 2px;">見積: ${totalEstDays}人日/${totalEstMonths}人月</div>
                                <div style="font-size: 0.75em; color: #666;">実績: ${totalActDays}人日/${totalActMonths}人月</div>
                                <div style="font-size: 11px; margin-top: 2px; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}</div>
                            `;
                        } else if (matrixDayMonthFormat === 'side') {
                            // 案3: 右側に表示
                            versionTotalCellHtml = `
                                <div style="display: flex; justify-content: space-between; font-size: 0.85em; font-weight: 300; color: #666;">
                                    <span>見積 ${versionTotalEst.toFixed(1)}</span><span style="font-size: 0.9em;">${totalEstDays}人日/${totalEstMonths}人月</span>
                                </div>
                                <div style="display: flex; justify-content: space-between; font-weight: 600; margin-top: 2px;">
                                    <span>実績 ${versionTotalAct.toFixed(1)}</span><span style="font-size: 0.9em; font-weight: 400;">${totalActDays}人日/${totalActMonths}人月</span>
                                </div>
                                <div style="font-size: 11px; margin-top: 2px; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}</div>
                            `;
                        } else if (matrixDayMonthFormat === 'arrow') {
                            // 案4: 矢印で表示
                            versionTotalCellHtml = `
                                <div style="font-size: 0.85em; font-weight: 300; color: #666;">見積 ${versionTotalEst.toFixed(1)} → ${totalEstDays}人日/${totalEstMonths}人月</div>
                                <div style="font-weight: 600; margin-top: 2px;">実績 ${versionTotalAct.toFixed(1)} → ${totalActDays}人日/${totalActMonths}人月</div>
                                <div style="font-size: 11px; margin-top: 2px; color: ${versionTotalDiff > 0 ? '#e74c3c' : versionTotalDiff < 0 ? '#27ae60' : '#666'}">${versionTotalDiff > 0 ? '+' : ''}${versionTotalDiff.toFixed(1)}</div>
                            `;
                        }
                    }

                    html += `<td style="text-align: center; background: ${versionTotalBgColor}; padding: 8px;">${versionTotalCellHtml}</td>`;
                    html += '</tr>';

                    html += '</table></div>';
                    html += '</div>';
                }
            });

            html += '</div>';
            container.innerHTML += html;
        }

        function renderMemberReport(filteredActuals, filteredEstimates) {
            // 見積データと実績データから担当者を動的に抽出
            const allMembers = new Set();
            filteredEstimates.forEach(e => allMembers.add(e.member));
            filteredActuals.forEach(a => allMembers.add(a.member));

            // 表示順が設定されている場合はそれを使用
            let members;
            const memberOrderInput = document.getElementById('memberOrder').value.trim();
            if (memberOrderInput) {
                const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                const orderedMembers = [];
                const unorderedMembers = [];

                // 指定された順序で追加
                orderList.forEach(name => {
                    if (allMembers.has(name)) {
                        orderedMembers.push(name);
                    }
                });

                // 指定されていない担当者を後ろに追加
                Array.from(allMembers).forEach(m => {
                    if (!orderedMembers.includes(m)) {
                        unorderedMembers.push(m);
                    }
                });

                members = [...orderedMembers, ...unorderedMembers.sort()];
            } else {
                members = Array.from(allMembers).sort();
            }

            if (members.length === 0) {
                document.getElementById('memberReport').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">データがありません</p>';
                return;
            }

            // 自動分割ロジック：見積担当者以外の実績を考慮して見積を再配分
            const adjustedEstimates = {};

            // 各担当者の見積工数を初期化
            members.forEach(member => {
                adjustedEstimates[member] = 0;
            });

            // 見積ごとに処理
            filteredEstimates.forEach(estimate => {
                const key = `${estimate.version}_${estimate.task}_${estimate.process}`;

                // この見積に対する実績を取得
                const relatedActuals = filteredActuals.filter(a =>
                    a.version === estimate.version &&
                    a.task === estimate.task &&
                    a.process === estimate.process
                );

                // 元の担当者以外の実績を集計
                let otherMembersActualHours = 0;
                const otherMembersHours = {};

                relatedActuals.forEach(actual => {
                    if (actual.member !== estimate.member) {
                        otherMembersActualHours += actual.hours;
                        otherMembersHours[actual.member] = (otherMembersHours[actual.member] || 0) + actual.hours;
                    }
                });

                // 元の担当者の見積から他の担当者の実績を引く
                const originalMemberEstimate = Math.max(0, estimate.hours - otherMembersActualHours);
                adjustedEstimates[estimate.member] = (adjustedEstimates[estimate.member] || 0) + originalMemberEstimate;

                // 他の担当者には実績分の見積を追加
                Object.keys(otherMembersHours).forEach(otherMember => {
                    adjustedEstimates[otherMember] = (adjustedEstimates[otherMember] || 0) + otherMembersHours[otherMember];
                });
            });

            let html = '<div class="table-wrapper"><table><tr><th>担当者</th><th>見積工数</th><th>実績工数</th><th>差異</th><th>差異率</th></tr>';

            members.forEach(member => {
                const est = adjustedEstimates[member] || 0;
                const act = filteredActuals.filter(a => a.member === member).reduce((sum, a) => sum + a.hours, 0);
                const diff = act - est;
                const rate = est > 0 ? ((diff / est) * 100).toFixed(1) : 0;

                html += `
                    <tr>
                        <td><strong>${member}</strong></td>
                        <td>${est.toFixed(1)}h</td>
                        <td>${act.toFixed(1)}h</td>
                        <td style="color: ${diff >= 0 ? '#e74c3c' : '#27ae60'}">${(diff >= 0 ? '+' : '')}${diff.toFixed(1)}h</td>
                        <td>${rate}%</td>
                    </tr>
                `;
            });

            html += '</table></div>';
            document.getElementById('memberReport').innerHTML = html;
        }

        function renderVersionReport(filteredActuals, filteredEstimates) {
            const versions = [...new Set(filteredEstimates.map(e => e.version))];
            
            if (versions.length === 0) {
                document.getElementById('versionReport').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">該当する見積データがありません</p>';
                return;
            }
            
            let html = '<div class="table-wrapper"><table><tr><th>版数</th><th>見積工数</th><th>実績工数</th><th>進捗率</th></tr>';

            versions.forEach(version => {
                const est = filteredEstimates.filter(e => e.version === version).reduce((sum, e) => sum + e.hours, 0);
                const act = filteredActuals.filter(a => a.version === version).reduce((sum, a) => sum + a.hours, 0);
                const progress = est > 0 ? (act / est * 100).toFixed(1) : 0;

                html += `
                    <tr>
                        <td><strong>${version}</strong></td>
                        <td>${est.toFixed(1)}h</td>
                        <td>${act.toFixed(1)}h</td>
                        <td>${progress}%</td>
                    </tr>
                `;
            });

            html += '</table></div>';
            document.getElementById('versionReport').innerHTML = html;
        }

        function deleteEstimate(id) {
            // 見積データを取得
            const estimate = estimates.find(e => e.id === id);
            if (!estimate) return;

            // 1段階目：詳細情報付きの確認
            const detail = `この見積を削除しますか？\n\n対応名: ${estimate.task}\n工程: ${estimate.process}\n工数: ${estimate.hours}h\n担当: ${estimate.member}`;
            if (!confirm(detail)) return;

            // 2段階目：最終警告
            const warning = '【警告】この操作は取り消せません。\n本当に削除してもよろしいですか？';
            if (!confirm(warning)) return;

            // 削除実行
            estimates = estimates.filter(e => e.id !== id);
            saveData();
            updateEstimateVersionOptions(); // 版数選択肢を更新
            renderEstimateList();
            updateQuickTaskList();
            updateReport();
            showAlert('見積を削除しました', true);
        }

        function deleteTask(version, task) {
            // 対応に紐づく全ての見積データを取得
            const taskEstimates = estimates.filter(e => e.version === version && e.task === task);
            if (taskEstimates.length === 0) return;

            // 工程リストと合計工数を計算
            const processes = taskEstimates.map(e => e.process).join(', ');
            const totalHours = taskEstimates.reduce((sum, e) => sum + e.hours, 0);

            // 1段階目：詳細情報付きの確認
            const detail = `この対応を削除しますか？\n\n版数: ${version}\n対応名: ${task}\n工程数: ${taskEstimates.length}件\n工程: ${processes}\n合計工数: ${totalHours}h`;
            if (!confirm(detail)) return;

            // 2段階目：最終警告
            const warning = '【警告】この操作は取り消せません。\nこの対応に含まれる全ての工程が削除されます。\n本当に削除してもよろしいですか？';
            if (!confirm(warning)) return;

            // 削除実行（対応に紐づく全ての見積を削除）
            estimates = estimates.filter(e => !(e.version === version && e.task === task));
            saveData();
            renderEstimateList();
            updateQuickTaskList();
            updateReport();
            showAlert('対応を削除しました', true);
        }

        // 作業月関連の関数
        function updateWorkMonthOptions() {
            const select = document.getElementById('assignWorkMonth');
            if (!select) return;

            const filter = document.getElementById('estimateMonthFilter');

            // 見積と実績から月を抽出
            const months = new Set();
            
            // 見積から作業予定月を抽出
            estimates.forEach(e => {
                if (e.workMonth) {
                    months.add(e.workMonth);
                }
            });
            
            // 実績から月を抽出
            actuals.forEach(a => {
                if (a.date) {
                    const month = a.date.substring(0, 7); // YYYY-MM
                    months.add(month);
                }
            });
            
            // 現在月の3ヶ月前から6ヶ月後までを追加
            const now = new Date();
            for (let i = -3; i <= 6; i++) {
                const date = new Date(now.getFullYear(), now.getMonth() + i, 1);
                const monthStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                months.add(monthStr);
            }
            
            const sortedMonths = Array.from(months).sort(); // 昇順（古い月→新しい月）
            
            // 割り当て先選択肢を更新
            select.innerHTML = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return `<option value="${m}">${year}年${parseInt(month)}月</option>`;
            }).join('');

            // フィルタ選択肢を更新（存在する場合のみ）
            if (filter) {
                const currentFilterValue = filter.value;
                filter.innerHTML = '<option value="all">全て</option><option value="unassigned">未設定のみ</option>';
                sortedMonths.forEach(m => {
                    const [year, month] = m.split('-');
                    filter.innerHTML += `<option value="${m}">${year}年${parseInt(month)}月</option>`;
                });
                filter.value = currentFilterValue;
            }
        }

        function toggleEstimateEditMode() {
            const checkbox1 = document.getElementById('estimateEditMode');
            const checkbox2 = document.getElementById('estimateEditMode2');

            // イベント元のチェックボックスを特定して状態を同期
            if (checkbox1 && checkbox2) {
                if (event && event.target === checkbox1) {
                    checkbox2.checked = checkbox1.checked;
                    estimateEditMode = checkbox1.checked;
                } else if (event && event.target === checkbox2) {
                    checkbox1.checked = checkbox2.checked;
                    estimateEditMode = checkbox2.checked;
                } else {
                    // イベントがない場合（プログラムから呼ばれた場合）
                    estimateEditMode = checkbox1.checked;
                    checkbox2.checked = checkbox1.checked;
                }
            } else if (checkbox1) {
                estimateEditMode = checkbox1.checked;
            } else if (checkbox2) {
                estimateEditMode = checkbox2.checked;
            }

            // 見積一覧を再描画
            renderEstimateList();
        }

        function toggleWorkMonthSelectionMode() {
            const checkbox1 = document.getElementById('workMonthSelectionMode');
            const checkbox2 = document.getElementById('workMonthSelectionMode2');

            // どちらかのチェックボックスから呼ばれた場合、状態を同期
            if (checkbox1 && checkbox2) {
                if (event && event.target === checkbox1) {
                    checkbox2.checked = checkbox1.checked;
                    workMonthSelectionMode = checkbox1.checked;
                } else if (event && event.target === checkbox2) {
                    checkbox1.checked = checkbox2.checked;
                    workMonthSelectionMode = checkbox2.checked;
                } else {
                    // イベントがない場合（プログラムから呼ばれた場合）
                    workMonthSelectionMode = checkbox1.checked;
                    checkbox2.checked = checkbox1.checked;
                }
            } else if (checkbox1) {
                workMonthSelectionMode = checkbox1.checked;
            }

            const modePanel = document.getElementById('workMonthAssignmentMode');

            if (workMonthSelectionMode) {
                modePanel.style.display = 'block';
                selectedEstimateIds.clear();
                updateSelectedWorkHours();
                initDragHandle(); // ドラッグ機能を初期化
            } else {
                modePanel.style.display = 'none';
                selectedEstimateIds.clear();
            }

            renderEstimateList();
        }
        
        // ドラッグ機能の初期化
        function initDragHandle() {
            const dragHandle = document.getElementById('dragHandle');
            const panel = document.getElementById('workMonthAssignmentMode');
            
            if (!dragHandle || !panel) return;
            
            let isDragging = false;
            let startY = 0;
            let startTop = 20; // 初期位置
            
            // 保存された位置を復元
            const savedTop = localStorage.getItem('manhour_panelTop');
            if (savedTop) {
                startTop = parseInt(savedTop);
                panel.style.top = startTop + 'px';
            }
            
            // マウスイベント
            dragHandle.addEventListener('mousedown', function(e) {
                isDragging = true;
                startY = e.clientY;
                const currentTop = parseInt(panel.style.top) || 20;
                startTop = currentTop;
                dragHandle.style.background = 'rgba(0,0,0,0.2)';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const deltaY = e.clientY - startY;
                let newTop = startTop + deltaY;
                
                // 画面内に制限（最小10px、最大は画面高さ-パネル高さ-10px）
                const panelHeight = panel.offsetHeight;
                const maxTop = window.innerHeight - panelHeight - 10;
                newTop = Math.max(10, Math.min(newTop, maxTop));
                
                panel.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    dragHandle.style.background = 'rgba(0,0,0,0.1)';
                    // 位置を保存
                    const currentTop = parseInt(panel.style.top) || 20;
                    localStorage.setItem('manhour_panelTop', currentTop);
                }
            });
            
            // タッチイベント
            dragHandle.addEventListener('touchstart', function(e) {
                isDragging = true;
                startY = e.touches[0].clientY;
                const currentTop = parseInt(panel.style.top) || 20;
                startTop = currentTop;
                dragHandle.style.background = 'rgba(0,0,0,0.2)';
                e.preventDefault();
            });
            
            document.addEventListener('touchmove', function(e) {
                if (!isDragging) return;
                
                const deltaY = e.touches[0].clientY - startY;
                let newTop = startTop + deltaY;
                
                // 画面内に制限
                const panelHeight = panel.offsetHeight;
                const maxTop = window.innerHeight - panelHeight - 10;
                newTop = Math.max(10, Math.min(newTop, maxTop));
                
                panel.style.top = newTop + 'px';
            });
            
            document.addEventListener('touchend', function() {
                if (isDragging) {
                    isDragging = false;
                    dragHandle.style.background = 'rgba(0,0,0,0.1)';
                    // 位置を保存
                    const currentTop = parseInt(panel.style.top) || 20;
                    localStorage.setItem('manhour_panelTop', currentTop);
                }
            });
        }

        function toggleEstimateSelection(id, event) {
            if (!workMonthSelectionMode) return;
            
            event.stopPropagation();
            
            if (selectedEstimateIds.has(id)) {
                selectedEstimateIds.delete(id);
            } else {
                selectedEstimateIds.add(id);
            }
            
            updateSelectedWorkHours();
            renderEstimateList();
        }

        function selectTaskEstimates(version, task, event) {
            if (!workMonthSelectionMode) return;
            
            event.stopPropagation();
            
            // この対応の全工程を取得
            const taskEstimates = estimates.filter(e => e.version === version && e.task === task);
            const taskIds = taskEstimates.map(e => e.id);
            
            // 全て選択されているかチェック
            const allSelected = taskIds.every(id => selectedEstimateIds.has(id));
            
            if (allSelected) {
                // 全て選択解除
                taskIds.forEach(id => selectedEstimateIds.delete(id));
            } else {
                // 全て選択
                taskIds.forEach(id => selectedEstimateIds.add(id));
            }
            
            updateSelectedWorkHours();
            renderEstimateList();
        }

        function updateSelectedWorkHours() {
            const selectedEstimates = estimates.filter(e => selectedEstimateIds.has(e.id));
            const totalHours = selectedEstimates.reduce((sum, e) => sum + e.hours, 0);
            const days = totalHours / 8;

            // 現在の月の実働日数を取得（デフォルト）
            const workingDaysPerMonth = getCurrentMonthWorkingDays();
            const months = days / workingDaysPerMonth;

            document.getElementById('selectedWorkHours').textContent =
                `選択中: ${totalHours.toFixed(1)}h (${days.toFixed(1)}人日 / ${months.toFixed(2)}人月)`;
        }

        function executeWorkMonthAssignment() {
            if (selectedEstimateIds.size === 0) {
                alert('作業を選択してください');
                return;
            }
            
            const workMonth = document.getElementById('assignWorkMonth').value;
            const [year, month] = workMonth.split('-');
            
            if (!confirm(`選択した${selectedEstimateIds.size}件の作業に「${year}年${parseInt(month)}月」を割り当てますか？`)) {
                return;
            }
            
            // 選択された見積に作業月を設定
            estimates.forEach(e => {
                if (selectedEstimateIds.has(e.id)) {
                    e.workMonth = workMonth;
                }
            });
            
            selectedEstimateIds.clear();
            saveData();
            updateWorkMonthOptions();
            updateSelectedWorkHours();
            renderEstimateList();
            updateReport();
            
            alert('作業月を割り当てました');
        }

        function cancelWorkMonthSelection() {
            selectedEstimateIds.clear();
            updateSelectedWorkHours();
            renderEstimateList();
        }

        function deleteActual(id) {
            if (!confirm('この実績を削除しますか?')) return;
            actuals = actuals.filter(a => a.id !== id);
            saveData();
            updateMonthOptions();
            renderActualList();
            renderTodayActuals();
            updateReport();
            showAlert('実績を削除しました', true);
        }

        function exportBackup() {
            autoBackup();
            showAlert('バックアップを作成しました', true);
        }

        function importBackup() {
            document.getElementById('fileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.json')) {
                // JSONファイルの処理
                const reader = new FileReader();
                reader.onerror = function(e) {
                    console.error('ファイル読み込みエラー:', reader.error);
                    const message = debugModeEnabled
                        ? 'ファイルの読み込みに失敗しました: ' + reader.error.message
                        : 'ファイルの読み込みに失敗しました';
                    showAlert(message, false);
                };
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (confirm('現在のデータを復元したデータで上書きしますか？')) {
                            estimates = data.estimates || [];
                            actuals = data.actuals || [];
                            companyHolidays = data.companyHolidays || [];
                            vacations = data.vacations || [];
                            remainingEstimates = data.remainingEstimates || [];

                            // 次のIDを設定
                            if (companyHolidays.length > 0) {
                                nextCompanyHolidayId = Math.max(...companyHolidays.map(h => h.id)) + 1;
                            }
                            if (vacations.length > 0) {
                                nextVacationId = Math.max(...vacations.map(v => v.id)) + 1;
                            }

                            // 設定を復元
                            if (data.settings) {
                                // テーマ設定を復元
                                if (data.settings.themeColor) {
                                    currentThemeColor = data.settings.themeColor;
                                    document.getElementById('themeColor').value = data.settings.themeColor;
                                }
                                if (data.settings.themePattern) {
                                    currentThemePattern = data.settings.themePattern;
                                    document.getElementById('themePattern').value = data.settings.themePattern;
                                }
                                if (data.settings.themeTabColor) {
                                    currentTabColor = data.settings.themeTabColor;
                                    document.getElementById('themeTabColor').value = data.settings.themeTabColor;
                                }
                                if (data.settings.themeBackgroundColor) {
                                    currentBackgroundColor = data.settings.themeBackgroundColor;
                                    document.getElementById('themeBackgroundColor').value = data.settings.themeBackgroundColor;
                                }

                                // レイアウト設定を復元
                                if (data.settings.estimateLayout) estimateLayout = data.settings.estimateLayout;
                                if (data.settings.actualLayout) actualLayout = data.settings.actualLayout;
                                if (data.settings.reportLayout) reportLayout = data.settings.reportLayout;

                                // 月色分け設定を復元
                                if (data.settings.showMonthColors !== undefined) {
                                    showMonthColorsSetting = data.settings.showMonthColors;
                                    const checkbox = document.getElementById('showMonthColorsCheckbox');
                                    if (checkbox) checkbox.checked = data.settings.showMonthColors;
                                }

                                // 乖離率背景色設定を復元
                                if (data.settings.showDeviationColors !== undefined) {
                                    showDeviationColorsSetting = data.settings.showDeviationColors;
                                    const checkbox = document.getElementById('showDeviationColorsCheckbox');
                                    if (checkbox) checkbox.checked = data.settings.showDeviationColors;
                                }

                                // 進捗バー表示設定を復元
                                if (data.settings.showProgressBars !== undefined) {
                                    showProgressBarsSetting = data.settings.showProgressBars;
                                    const checkbox = document.getElementById('showProgressBarsCheckbox');
                                    if (checkbox) checkbox.checked = data.settings.showProgressBars;
                                }

                                // 進捗バーのパーセンテージ表示設定を復元
                                if (data.settings.showProgressPercentage !== undefined) {
                                    showProgressPercentageSetting = data.settings.showProgressPercentage;
                                    const checkbox = document.getElementById('showProgressPercentageCheckbox');
                                    if (checkbox) checkbox.checked = data.settings.showProgressPercentage;
                                }

                                // 進捗バーのスタイル設定を復元
                                if (data.settings.progressBarStyle) {
                                    progressBarStyle = data.settings.progressBarStyle;
                                    const radioButton = document.querySelector(`input[name="progressBarStyle"][value="${data.settings.progressBarStyle}"]`);
                                    if (radioButton) radioButton.checked = true;
                                }

                                // デフォルト表示形式を復元
                                if (data.settings.defaultEstimateViewType) {
                                    const select = document.getElementById('defaultEstimateViewType');
                                    if (select) select.value = data.settings.defaultEstimateViewType;
                                }
                                if (data.settings.defaultReportViewType) {
                                    const select = document.getElementById('defaultReportViewType');
                                    if (select) select.value = data.settings.defaultReportViewType;
                                }

                                // 担当者表示順を復元
                                if (data.settings.memberOrder) {
                                    document.getElementById('memberOrder').value = data.settings.memberOrder;
                                }

                                // Stickyフィルタ設定を復元
                                if (data.settings.stickyFilterEnabled !== undefined) {
                                    localStorage.setItem('stickyFilterEnabled', data.settings.stickyFilterEnabled);
                                    const checkbox = document.getElementById('stickyFilterEnabled');
                                    if (checkbox) checkbox.checked = data.settings.stickyFilterEnabled;
                                    if (data.settings.stickyFilterEnabled) {
                                        enableStickyFilters();
                                    } else {
                                        disableStickyFilters();
                                    }
                                }

                                // フローティングフィルタ設定を復元
                                if (data.settings.floatingFilterEnabled !== undefined) {
                                    localStorage.setItem('floatingFilterEnabled', data.settings.floatingFilterEnabled);
                                    const checkbox = document.getElementById('floatingFilterEnabled');
                                    if (checkbox) checkbox.checked = data.settings.floatingFilterEnabled;
                                }

                                // デバッグモード設定を復元
                                if (data.settings.debugModeEnabled !== undefined) {
                                    debugModeEnabled = data.settings.debugModeEnabled;
                                    localStorage.setItem('debugModeEnabled', debugModeEnabled);
                                    const checkbox = document.getElementById('debugModeEnabled');
                                    if (checkbox) checkbox.checked = debugModeEnabled;
                                }
                            } else if (data.memberOrder) {
                                // 旧形式（settingsがない場合）の後方互換性
                                document.getElementById('memberOrder').value = data.memberOrder;
                            }

                            saveData(true); // 復元時は自動バックアップをスキップ

                            // テーマを適用
                            applyTheme();

                            // レイアウトを適用
                            applyLayoutSettings();

                            updateMonthOptions();
                            updateActualMonthOptions();
                            updateMemberOptions();
                            updateQuickTaskList();
                            renderEstimateList();
                            renderActualList();
                            renderTodayActuals();
                            updateReport();
                            renderCompanyHolidayList();

                            showAlert('データを復元しました', true);
                        }
                    } catch (error) {
                        console.error('ファイル読み込みエラー:', error);
                        const message = debugModeEnabled
                            ? 'ファイルの読み込みに失敗しました: ' + error.message
                            : 'ファイルの読み込みに失敗しました';
                        showAlert(message, false);
                    }
                };
                reader.readAsText(file);
            } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
                // Excelファイルの処理
                handleExcelImport(file);
            } else {
                alert('対応していないファイル形式です。JSON または Excel ファイルを選択してください。');
            }
            
            event.target.value = '';
        }

        async function handleExcelImport(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(arrayBuffer);
                
                const estimatesSheet = workbook.getWorksheet('見積データ');
                const actualsSheet = workbook.getWorksheet('実績データ');
                
                if (!estimatesSheet || !actualsSheet) {
                    alert('Excelファイルに「見積データ」と「実績データ」のシートが必要です');
                    return;
                }
                
                // 見積データの読み込み
                const newEstimates = [];
                estimatesSheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // ヘッダー行をスキップ
                    
                    const version = row.getCell(1).value;
                    const task = row.getCell(2).value;
                    const process = row.getCell(3).value;
                    const member = row.getCell(4).value;
                    const hours = parseFloat(row.getCell(5).value);
                    
                    if (version && task && process && member && hours) {
                        newEstimates.push({
                            id: Date.now() + Math.random(),
                            version: String(version),
                            task: String(task),
                            process: String(process),
                            member: String(member),
                            hours: hours,
                            createdAt: new Date().toISOString()
                        });
                    }
                });
                
                // 実績データの読み込み
                const newActuals = [];
                actualsSheet.eachRow((row, rowNumber) => {
                    if (rowNumber === 1) return; // ヘッダー行をスキップ
                    
                    const dateValue = row.getCell(1).value;
                    const version = row.getCell(2).value;
                    const task = row.getCell(3).value;
                    const process = row.getCell(4).value;
                    const member = row.getCell(5).value;
                    const hours = parseFloat(row.getCell(6).value);
                    
                    // 日付の処理
                    let dateStr = '';
                    if (dateValue instanceof Date) {
                        dateStr = dateValue.toISOString().split('T')[0];
                    } else if (typeof dateValue === 'string') {
                        dateStr = dateValue;
                    } else if (typeof dateValue === 'number') {
                        // Excel のシリアル値を日付に変換
                        const date = new Date((dateValue - 25569) * 86400 * 1000);
                        dateStr = date.toISOString().split('T')[0];
                    }
                    
                    if (dateStr && version && task && process && member && hours) {
                        newActuals.push({
                            id: Date.now() + Math.random(),
                            date: dateStr,
                            version: String(version),
                            task: String(task),
                            process: String(process),
                            member: String(member),
                            hours: hours,
                            createdAt: new Date().toISOString()
                        });
                    }
                });
                
                if (newEstimates.length === 0 && newActuals.length === 0) {
                    alert('データが見つかりませんでした。Excelのフォーマットを確認してください。');
                    return;
                }
                
                if (confirm(`見積: ${newEstimates.length}件、実績: ${newActuals.length}件のデータを読み込みました。\n現在のデータを上書きしますか？`)) {
                    estimates = newEstimates;
                    actuals = newActuals;
                    saveData(true); // 復元時は自動バックアップをスキップ
                    
                    updateMonthOptions();
                    updateActualMonthOptions();
                    updateMemberOptions();
                    updateQuickTaskList();
                    renderEstimateList();
                    renderActualList();
                    renderTodayActuals();
                    updateReport();
                    
                    alert('Excelデータを読み込みました');
                }
                
            } catch (error) {
                console.error('Excel読み込みエラー:', error);
                const message = debugModeEnabled
                    ? 'Excelファイルの読み込みに失敗しました: ' + error.message
                    : 'Excelファイルの読み込みに失敗しました';
                alert(message);
            }
        }
        
        // Excel出力機能
        async function exportToExcel() {
            try {
                const workbook = new ExcelJS.Workbook();
                
                // 実績データの期間を取得
                let minDate = null;
                let maxDate = null;
                
                actuals.forEach(a => {
                    const date = new Date(a.date);
                    if (!minDate || date < minDate) minDate = date;
                    if (!maxDate || date > maxDate) maxDate = date;
                });
                
                // 実績データがない場合は現在月を使用
                if (!minDate || !maxDate) {
                    const now = new Date();
                    minDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    maxDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                }
                
                // 担当者一覧を取得（表示順を考慮）
                let members = [...new Set(actuals.map(a => a.member))];

                // 表示順が指定されている場合（設定で定めた順序を使用）
                const memberOrderInput = document.getElementById('memberOrder').value.trim();
                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = [];
                    const unorderedMembers = [];
                    
                    // 指定された順序で追加
                    orderList.forEach(name => {
                        if (members.includes(name)) {
                            orderedMembers.push(name);
                        }
                    });
                    
                    // 指定されていない担当者を後ろに追加
                    members.forEach(m => {
                        if (!orderedMembers.includes(m)) {
                            unorderedMembers.push(m);
                        }
                    });
                    
                    members = [...orderedMembers, ...unorderedMembers.sort()];
                } else {
                    members.sort();
                }
                
                // 担当者ごとに実績シートを作成
                members.forEach(member => {
                    const worksheet = workbook.addWorksheet(`実績_${member}`);
                    
                    // ヘッダー行
                    worksheet.columns = [
                        { header: '日付', key: 'date', width: 12, style: { numFmt: 'yyyy/mm/dd' } },
                        { header: '曜日', key: 'weekday', width: 8 },
                        { header: '備考', key: 'note', width: 15 },
                        { header: '作業', key: 'work', width: 50 },
                        { header: '時間(h)', key: 'hours', width: 10 }
                    ];
                    
                    // ヘッダーのスタイル
                    worksheet.getRow(1).font = { bold: true };
                    worksheet.getRow(1).fill = {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFD3D3D3' }
                    };
                    
                    // 全日付を生成（土日祝日含む）
                    const currentDate = new Date(minDate);
                    while (currentDate <= maxDate) {
                        const dateStr = currentDate.toISOString().split('T')[0];
                        const weekday = ['日', '月', '火', '水', '木', '金', '土'][currentDate.getDay()];
                        
                        // 祝日チェック
                        const holiday = getHoliday(dateStr);
                        const note = holiday || '';
                        
                        // この日付のこの担当者の実績を取得
                        const dayActuals = actuals.filter(a => 
                            a.date === dateStr && a.member === member
                        );
                        
                        if (dayActuals.length === 0) {
                            // 実績がない日も出力
                            worksheet.addRow({
                                date: new Date(currentDate),
                                weekday: weekday,
                                note: note,
                                work: '',
                                hours: ''
                            });
                        } else {
                            // 実績がある場合、各実績を行として追加
                            dayActuals.forEach((actual, index) => {
                                // 作業名を「版数_対応名_工程」の形式に
                                const workName = `${actual.version}_${actual.task}_${actual.process}`;
                                
                                worksheet.addRow({
                                    date: new Date(currentDate),
                                    weekday: weekday,
                                    note: note,
                                    work: workName,
                                    hours: actual.hours
                                });
                            });
                        }
                        
                        // 次の日へ
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    
                    // 罫線と日付フォーマットを設定
                    worksheet.eachRow((row, rowNumber) => {
                        row.eachCell((cell, colNumber) => {
                            cell.border = {
                                top: { style: 'thin' },
                                left: { style: 'thin' },
                                bottom: { style: 'thin' },
                                right: { style: 'thin' }
                            };
                            
                            // 日付列（1列目）の表示形式を設定
                            if (colNumber === 1 && rowNumber > 1) {
                                cell.numFmt = 'yyyy/mm/dd';
                            }
                        });
                    });
                    
                    // 土日祝日に色を付ける
                    let currentRow = 2; // ヘッダーの次から
                    const checkDate = new Date(minDate);
                    while (checkDate <= maxDate) {
                        const day = checkDate.getDay();
                        const dateStr = checkDate.toISOString().split('T')[0];
                        const isHoliday = getHoliday(dateStr) !== null;
                        
                        // この日付の行数を取得
                        const dayActuals = actuals.filter(a => 
                            a.date === dateStr && a.member === member
                        );
                        const rowCount = Math.max(1, dayActuals.length);
                        
                        if (day === 0 || isHoliday) {
                            // 日曜日または祝日（赤）
                            for (let i = 0; i < rowCount; i++) {
                                worksheet.getRow(currentRow + i).fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: 'FFFFCCCC' }
                                };
                            }
                        } else if (day === 6) {
                            // 土曜日（青）
                            for (let i = 0; i < rowCount; i++) {
                                worksheet.getRow(currentRow + i).fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: 'FFCCCCFF' }
                                };
                            }
                        }
                        
                        currentRow += rowCount;
                        checkDate.setDate(checkDate.getDate() + 1);
                    }
                });
                
                // 見積シートを作成
                const estimateSheet = workbook.addWorksheet('見積');
                
                estimateSheet.columns = [
                    { header: '版数', key: 'version', width: 15 },
                    { header: '作業月', key: 'workMonth', width: 12 },
                    { header: '対応名', key: 'task', width: 40 },
                    { header: '工程', key: 'process', width: 10 },
                    { header: '担当', key: 'member', width: 12 },
                    { header: '見積工数', key: 'hours', width: 12 }
                ];
                
                // ヘッダーのスタイル
                estimateSheet.getRow(1).font = { bold: true };
                estimateSheet.getRow(1).fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'FFD3D3D3' }
                };
                
                // 見積データを追加
                estimates.forEach(est => {
                    const normalized = normalizeEstimate(est);
                    
                    // 作業月の表示
                    let workMonthDisplay = '';
                    if (normalized.workMonths.length === 0) {
                        workMonthDisplay = '未設定';
                    } else if (normalized.workMonths.length === 1) {
                        const [y, m] = normalized.workMonths[0].split('-');
                        workMonthDisplay = `${y}年${parseInt(m)}月`;
                    } else {
                        const [y1, m1] = normalized.workMonths[0].split('-');
                        const [y2, m2] = normalized.workMonths[normalized.workMonths.length - 1].split('-');
                        workMonthDisplay = `${y1}年${parseInt(m1)}月〜${y2}年${parseInt(m2)}月`;
                    }
                    
                    estimateSheet.addRow({
                        version: est.version,
                        workMonth: workMonthDisplay,
                        task: est.task,
                        process: est.process,
                        member: est.member,
                        hours: est.hours
                    });
                });
                
                // 罫線を追加
                estimateSheet.eachRow((row, rowNumber) => {
                    row.eachCell((cell) => {
                        cell.border = {
                            top: { style: 'thin' },
                            left: { style: 'thin' },
                            bottom: { style: 'thin' },
                            right: { style: 'thin' }
                        };
                    });
                });
                
                // ファイル名を生成
                const now = new Date();
                const timestamp = `${now.getFullYear()}${String(now.getMonth() + 1).padStart(2, '0')}${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}`;
                const filename = `工数管理_${timestamp}.xlsx`;
                
                // ファイルをダウンロード
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
                
                showAlert('Excelファイルをダウンロードしました', true);
                
            } catch (error) {
                console.error('Excel出力エラー:', error);
                alert('Excelファイルの出力に失敗しました: ' + error.message);
            }
        }
        
        // 打ち合わせを全員分追加
        function addMeeting() {
            console.log('addMeeting called');
            const hours = parseFloat(document.getElementById('meetingHours').value);

            // カレンダーからの日付があればそれを使用、なければ今日の日付
            const modal = document.getElementById('otherWorkModal');
            let date;
            if (modal.dataset.calendarDate) {
                date = modal.dataset.calendarDate;
            } else {
                const today = new Date();
                date = today.toISOString().split('T')[0];
            }
            
            console.log('hours:', hours, 'date:', date);
            
            if (!hours || hours <= 0) {
                alert('工数を入力してください');
                return;
            }
            
            // 全担当者を取得
            const members = new Set();
            estimates.forEach(e => members.add(e.member));
            actuals.forEach(a => members.add(a.member));
            
            console.log('members:', Array.from(members));
            
            if (members.size === 0) {
                alert('担当者が登録されていません。先に見積または実績を登録してください。');
                return;
            }
            
            // 全担当者分の実績を追加
            let count = 0;
            members.forEach(member => {
                actuals.push({
                    id: Date.now() + count,
                    date: date,
                    version: '',  // 版数なし
                    task: '打ち合わせ',
                    process: '',
                    member: member,
                    hours: hours
                });
                count++;
            });
            
            console.log('actuals added, count:', count);
            
            saveData();
            renderActualList();
            renderTodayActuals();
            updateReport();
            
            // 入力欄をクリアしてモーダルを閉じる
            document.getElementById('meetingHours').value = '';
            closeOtherWorkModal();
            
            alert(`打ち合わせを${members.size}名分登録しました（${date}）`);
        }
        
        // その他作業を追加
        function addOtherWork() {
            console.log('addOtherWork called');
            const workName = document.getElementById('otherWorkName').value.trim();
            const member = document.getElementById('otherWorkMember').value;
            const hours = parseFloat(document.getElementById('otherWorkHours').value);

            // カレンダーからの日付があればそれを使用、なければ今日の日付
            const modal = document.getElementById('otherWorkModal');
            let date;
            if (modal.dataset.calendarDate) {
                date = modal.dataset.calendarDate;
            } else {
                const today = new Date();
                date = today.toISOString().split('T')[0];
            }
            
            console.log('workName:', workName, 'member:', member, 'hours:', hours, 'date:', date);
            
            if (!workName) {
                alert('作業名を入力してください');
                return;
            }
            
            if (!member) {
                alert('担当者を選択してください');
                return;
            }
            
            if (!hours || hours <= 0) {
                alert('工数を入力してください');
                return;
            }
            
            // その他作業を追加
            actuals.push({
                id: Date.now(),
                date: date,
                version: '',  // 版数なし
                task: workName,
                process: '',
                member: member,
                hours: hours
            });
            
            console.log('other work added');
            
            saveData();
            renderActualList();
            renderTodayActuals();
            updateReport();
            
            // 入力欄をクリアしてモーダルを閉じる
            document.getElementById('otherWorkName').value = '';
            document.getElementById('otherWorkMember').value = '';
            document.getElementById('otherWorkHours').value = '';
            closeOtherWorkModal();
            
            alert(`その他作業を登録しました（${date}）`);
        }
        
        // その他作業モーダルを開く
        function openOtherWorkModal() {
            // 担当者リストを更新
            const otherWorkMemberSelect = document.getElementById('otherWorkMember');
            if (otherWorkMemberSelect) {
                // 担当者を抽出
                const members = new Set();
                estimates.forEach(e => members.add(e.member));
                actuals.forEach(a => members.add(a.member));
                
                // 表示順でソート
                let sortedMembers;
                const memberOrderInput = document.getElementById('memberOrder').value.trim();
                if (memberOrderInput) {
                    const orderList = memberOrderInput.split(',').map(m => m.trim()).filter(m => m);
                    const orderedMembers = [];
                    const unorderedMembers = [];
                    
                    orderList.forEach(name => {
                        if (members.has(name)) {
                            orderedMembers.push(name);
                        }
                    });
                    
                    Array.from(members).forEach(m => {
                        if (!orderedMembers.includes(m)) {
                            unorderedMembers.push(m);
                        }
                    });
                    
                    sortedMembers = [...orderedMembers, ...unorderedMembers.sort()];
                } else {
                    sortedMembers = Array.from(members).sort();
                }
                
                otherWorkMemberSelect.innerHTML = '<option value="">選択...</option>';
                sortedMembers.forEach(member => {
                    const option = document.createElement('option');
                    option.value = member;
                    option.textContent = member;
                    otherWorkMemberSelect.appendChild(option);
                });
            }
            
            document.getElementById('otherWorkModal').style.display = 'flex';
            // 打ち合わせタブをアクティブにする
            switchOtherWorkTab('meeting');
        }
        
        // その他作業モーダルを閉じる
        function closeOtherWorkModal() {
            const modal = document.getElementById('otherWorkModal');
            modal.style.display = 'none';

            // カレンダー日付データをクリア
            delete modal.dataset.calendarDate;

            // モーダルタイトルをリセット
            document.querySelector('#otherWorkModal .modal-header h3').textContent = 'その他作業を登録';
        }
        
        // その他作業モーダルのタブを切り替え
        function switchOtherWorkTab(tab) {
            const meetingTab = document.getElementById('meetingTab');
            const customTab = document.getElementById('customTab');
            const meetingForm = document.getElementById('meetingForm');
            const customForm = document.getElementById('customForm');
            
            if (tab === 'meeting') {
                meetingTab.classList.add('active');
                customTab.classList.remove('active');
                meetingForm.style.display = 'block';
                customForm.style.display = 'none';
            } else {
                meetingTab.classList.remove('active');
                customTab.classList.add('active');
                meetingForm.style.display = 'none';
                customForm.style.display = 'block';
            }
        }

        // フィルタ固定表示設定の保存
        // Stickyフィルタのイベントハンドラー保持用
        let stickyScrollHandler = null;
        let stickyResizeHandler = null;

        function saveStickyFilterSetting() {
            const checkbox = document.getElementById('stickyFilterEnabled');
            if (!checkbox) return;
            const enabled = checkbox.checked;
            localStorage.setItem('stickyFilterEnabled', enabled);

            // 設定変更時に機能を有効/無効化
            if (enabled) {
                enableStickyFilters();
            } else {
                disableStickyFilters();
            }
        }

        // フィルタ固定表示設定の読み込み
        function loadStickyFilterSetting() {
            const saved = localStorage.getItem('stickyFilterEnabled');
            const enabled = saved === null || saved === 'true';
            const checkbox = document.getElementById('stickyFilterEnabled');
            if (checkbox) {
                checkbox.checked = enabled;
            }
            return enabled;
        }

        // Stickyフィルタを有効化
        function enableStickyFilters() {
            // 既に有効な場合は何もしない
            if (stickyScrollHandler) return;

            const container = document.querySelector('.container');
            if (!container) return;

            // 全てのsticky-filter-containerを取得
            const stickyFilters = document.querySelectorAll('.sticky-filter-container');

            // 各フィルタにプレースホルダーを作成（既存のものがない場合のみ）
            stickyFilters.forEach(filter => {
                // 既存のプレースホルダーをチェック
                const existingPlaceholder = filter.previousElementSibling;
                if (!existingPlaceholder || !existingPlaceholder.classList.contains('sticky-placeholder')) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'sticky-placeholder';
                    filter.parentNode.insertBefore(placeholder, filter);
                }
            });

            // スクロールイベント監視（windowスクロール）
            stickyScrollHandler = function() {
                stickyFilters.forEach(filter => {
                    // 表示されているフィルタのみ処理
                    if (filter.offsetParent === null) return;

                    const placeholder = filter.previousElementSibling;
                    if (!placeholder) return;

                    const containerRect = container.getBoundingClientRect();

                    // プレースホルダーの現在位置を取得（元々あった位置）
                    const placeholderRect = placeholder.getBoundingClientRect();

                    // プレースホルダーが画面上端に達したら固定
                    if (placeholderRect.top <= 0 && !filter.classList.contains('is-sticky')) {
                        // Sticky化
                        const filterHeight = filter.offsetHeight;
                        placeholder.style.height = filterHeight + 'px';
                        placeholder.classList.add('active');
                        filter.classList.add('is-sticky');

                        // containerの幅に合わせる
                        filter.style.width = containerRect.width + 'px';
                        filter.style.left = containerRect.left + 'px';
                    }
                    // プレースホルダーが画面上端より下にある場合は固定解除
                    else if (placeholderRect.top > 0 && filter.classList.contains('is-sticky')) {
                        // Sticky解除
                        placeholder.classList.remove('active');
                        placeholder.style.height = '';
                        filter.classList.remove('is-sticky');
                        filter.style.width = '';
                        filter.style.left = '';
                    }
                });
            };

            window.addEventListener('scroll', stickyScrollHandler);

            // ウィンドウリサイズ時の対応
            stickyResizeHandler = function() {
                const containerRect = container.getBoundingClientRect();
                stickyFilters.forEach(filter => {
                    if (filter.classList.contains('is-sticky')) {
                        filter.style.width = containerRect.width + 'px';
                        filter.style.left = containerRect.left + 'px';
                    }
                });
            };

            window.addEventListener('resize', stickyResizeHandler);
        }

        // Stickyフィルタを無効化
        function disableStickyFilters() {
            // イベントリスナーを削除
            if (stickyScrollHandler) {
                window.removeEventListener('scroll', stickyScrollHandler);
                stickyScrollHandler = null;
            }
            if (stickyResizeHandler) {
                window.removeEventListener('resize', stickyResizeHandler);
                stickyResizeHandler = null;
            }

            // 全てのsticky状態をリセット
            const stickyFilters = document.querySelectorAll('.sticky-filter-container');
            stickyFilters.forEach(filter => {
                filter.classList.remove('is-sticky');
                filter.style.width = '';
                filter.style.left = '';

                // プレースホルダーもリセット
                const placeholder = filter.previousElementSibling;
                if (placeholder && placeholder.classList.contains('sticky-placeholder')) {
                    placeholder.classList.remove('active');
                    placeholder.style.height = '';
                }
            });
        }

        // フィルタ部分のSticky表示制御（初期化）
        function initStickyFilters() {
            // 設定を確認
            const enabled = loadStickyFilterSetting();
            if (enabled) {
                enableStickyFilters();
            }
        }

        // ページ読み込み時に初期化
        document.addEventListener('DOMContentLoaded', function() {
            initStickyFilters();
            loadFloatingFilterSetting(); // フローティングフィルタ設定を読み込み
        });

        // ========================================
        // フローティングフィルタパネル
        // ========================================

        // フローティングフィルタ設定の保存
        function saveFloatingFilterSetting() {
            const checkbox = document.getElementById('floatingFilterEnabled');
            if (!checkbox) return;
            const enabled = checkbox.checked;
            localStorage.setItem('floatingFilterEnabled', enabled);

            // 設定変更時にボタンの表示/非表示を切り替え
            // レポートタブにいる場合のみ反映
            const reportTab = document.getElementById('report');
            if (reportTab && reportTab.classList.contains('active')) {
                if (enabled) {
                    showFloatingFilterButton();
                } else {
                    hideFloatingFilterButton();
                }
            }
        }

        // フローティングフィルタ設定の読み込み
        function loadFloatingFilterSetting() {
            const saved = localStorage.getItem('floatingFilterEnabled');
            const enabled = saved === null || saved === 'true';
            const checkbox = document.getElementById('floatingFilterEnabled');
            if (checkbox) {
                checkbox.checked = enabled;
            }
            return enabled;
        }

        // デバッグモード設定の保存
        function saveDebugModeSetting() {
            const checkbox = document.getElementById('debugModeEnabled');
            if (!checkbox) return;
            debugModeEnabled = checkbox.checked;
            localStorage.setItem('debugModeEnabled', debugModeEnabled);
        }

        // デバッグモード設定の読み込み
        function loadDebugModeSetting() {
            const saved = localStorage.getItem('debugModeEnabled');
            debugModeEnabled = saved === 'true';
            const checkbox = document.getElementById('debugModeEnabled');
            if (checkbox) {
                checkbox.checked = debugModeEnabled;
            }
        }

        // フローティングフィルタボタンを表示
        function showFloatingFilterButton() {
            const enabled = loadFloatingFilterSetting();
            if (!enabled) return;

            const toggle = document.getElementById('floatingFilterToggle');
            if (toggle) {
                toggle.style.display = 'flex';
            }
        }

        // フローティングフィルタボタンを非表示
        function hideFloatingFilterButton() {
            const toggle = document.getElementById('floatingFilterToggle');
            const panel = document.getElementById('floatingFilterPanel');
            if (toggle) {
                toggle.style.display = 'none';
            }
            if (panel) {
                panel.classList.remove('show');
            }
        }

        // フローティングパネルの開閉トグル
        function toggleFloatingFilterPanel(event) {
            if (event) {
                event.stopPropagation(); // イベント伝播を防ぐ
            }
            const panel = document.getElementById('floatingFilterPanel');
            if (panel) {
                if (panel.classList.contains('show')) {
                    panel.classList.remove('show');
                } else {
                    panel.classList.add('show');
                    // パネルを開く時に状態を同期
                    syncFloatingFilters();
                }
            }
        }

        // メインフィルタの状態をフローティングパネルに同期
        function syncFloatingFilters() {
            // フィルタタイプの同期
            const mainFilterType = document.getElementById('reportFilterType');
            if (mainFilterType) {
                const filterType = mainFilterType.value;
                setFloatingFilterType(filterType, false);
            }

            // 月フィルタの同期（セグメントボタンを生成）
            const mainReportMonth = document.getElementById('reportMonth');
            const floatingMonthButtons = document.getElementById('floatingMonthButtons');
            if (mainReportMonth && floatingMonthButtons) {
                const currentValue = mainReportMonth.value;
                floatingMonthButtons.innerHTML = '';

                // オプションからボタンを生成
                Array.from(mainReportMonth.options).forEach(option => {
                    const btn = document.createElement('button');
                    btn.textContent = option.text;
                    btn.onclick = function(e) {
                        e.stopPropagation();
                        syncFloatingMonthFilter(option.value);
                    };
                    if (option.value === currentValue) {
                        btn.classList.add('active');
                    }
                    floatingMonthButtons.appendChild(btn);
                });
            }

            // 版数フィルタの同期（セグメントボタンを生成）
            const mainReportVersion = document.getElementById('reportVersion');
            const floatingVersionButtons = document.getElementById('floatingVersionButtons');
            if (mainReportVersion && floatingVersionButtons) {
                const currentValue = mainReportVersion.value;
                floatingVersionButtons.innerHTML = '';

                // オプションからボタンを生成
                Array.from(mainReportVersion.options).forEach(option => {
                    const btn = document.createElement('button');
                    btn.textContent = option.text;
                    btn.onclick = function(e) {
                        e.stopPropagation();
                        syncFloatingVersionFilter(option.value);
                    };
                    if (option.value === currentValue) {
                        btn.classList.add('active');
                    }
                    floatingVersionButtons.appendChild(btn);
                });
            }

            // 表示形式の同期
            const mainViewType = document.getElementById('reportViewType');
            if (mainViewType) {
                const viewType = mainViewType.value;
                setFloatingViewType(viewType, false);
            }

            // テーマを適用
            updateFloatingFilterTheme();
        }

        // フィルタタイプの設定（月別/版数別）
        function setFloatingFilterType(type, applyToMain = true) {
            const monthBtn = document.getElementById('floatingFilterMonth');
            const versionBtn = document.getElementById('floatingFilterVersion');
            const monthGroup = document.getElementById('floatingMonthGroup');
            const versionGroup = document.getElementById('floatingVersionGroup');

            if (type === 'month') {
                monthBtn.classList.add('active');
                versionBtn.classList.remove('active');
                monthGroup.style.display = 'block';
                versionGroup.style.display = 'none';
            } else {
                monthBtn.classList.remove('active');
                versionBtn.classList.add('active');
                monthGroup.style.display = 'none';
                versionGroup.style.display = 'block';
            }

            // メインフィルタに反映
            if (applyToMain) {
                const mainFilterType = document.getElementById('reportFilterType');
                if (mainFilterType) {
                    mainFilterType.value = type;
                    handleReportFilterTypeChange();
                }
            }

            // テーマカラーを適用
            updateFloatingFilterTheme();
        }

        // 表示形式の設定
        function setFloatingViewType(type, applyToMain = true) {
            const summaryBtn = document.getElementById('floatingViewSummary');
            const groupedBtn = document.getElementById('floatingViewGrouped');
            const matrixBtn = document.getElementById('floatingViewMatrix');

            // 全てのボタンからactiveを削除
            summaryBtn.classList.remove('active');
            groupedBtn.classList.remove('active');
            matrixBtn.classList.remove('active');

            // 対応するボタンにactiveを追加
            if (type === 'summary') {
                summaryBtn.classList.add('active');
            } else if (type === 'grouped') {
                groupedBtn.classList.add('active');
            } else if (type === 'matrix') {
                matrixBtn.classList.add('active');
            }

            // メインフィルタに反映
            if (applyToMain) {
                const mainViewType = document.getElementById('reportViewType');
                if (mainViewType) {
                    mainViewType.value = type;
                    updateReport();
                }
            }

            // テーマカラーを適用
            updateFloatingFilterTheme();
        }

        // 月フィルタの同期
        function syncFloatingMonthFilter(value) {
            const mainMonth = document.getElementById('reportMonth');
            if (mainMonth) {
                mainMonth.value = value;
                handleReportMonthFilterChange();
                // ボタンの状態を更新
                syncFloatingFilters();
            }
        }

        // 版数フィルタの同期
        function syncFloatingVersionFilter(value) {
            const mainVersion = document.getElementById('reportVersion');
            if (mainVersion) {
                mainVersion.value = value;
                handleReportVersionFilterChange();
                // ボタンの状態を更新
                syncFloatingFilters();
            }
        }

        // パネル外クリックで閉じる
        document.addEventListener('click', function(event) {
            const panel = document.getElementById('floatingFilterPanel');
            const toggle = document.getElementById('floatingFilterToggle');

            if (!panel || !toggle) return;

            // パネルが開いている場合のみ処理
            if (panel.classList.contains('show')) {
                // クリックがパネル内、またはトグルボタンの場合は何もしない
                if (panel.contains(event.target) || toggle.contains(event.target)) {
                    return;
                }
                // それ以外の場合はパネルを閉じる
                event.stopPropagation();
                event.preventDefault();
                panel.classList.remove('show');
            }
        }, true); // キャプチャフェーズで実行

        // パネル内のクリックでイベント伝播を止める（見込残存時間モーダルが開くのを防ぐ）
        document.addEventListener('DOMContentLoaded', function() {
            const panel = document.getElementById('floatingFilterPanel');
            if (panel) {
                panel.addEventListener('click', function(event) {
                    event.stopPropagation();
                });
            }
        });
    </script>
</body>
</html>
